% can run this in mobaxterm too:
% byobu
% Rscript -e "library(knitr); knit('TranscriptomicsDataAnalysis.Rnw')"
% pdflatex TranscriptomicsDataAnalysis.tex -> press R 

% now I have figured out that I can convert the rmd to tex too

% set the global build options to knitr instead of sweave to have more options 
\documentclass[12pt, a4paper, english,twoside, openany]{report}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
%\usepackage{hyperref}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{anyfontsize}
\usepackage{float}
\usepackage{textcomp}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\usepackage[utf8]{inputenc}
\usepackage{alphabeta}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{atbegshi}
\usepackage{lastpage}
\usepackage{refcount}% http://ctan.org/pkg/{lastpage,refcount}
\definecolor{tn}{HTML}{2d9b9b}
\definecolor{tp}{HTML}{044c54}
\definecolor{fn}{HTML}{cf4c4e}
\definecolor{fp}{HTML}{77070a}

\usepackage{geometry}
\geometry{
	papersize={21cm,29.7cm},
	layoutsize={21cm,29.7cm},
	left=18mm,
	right=18mm,
	top=18mm,
	bottom=18mm
}

\hypersetup{
    pdfauthor = {Dr. ir. Kim De Paepe},
    pdftitle = {Report Microarray Transcriptomics Data Analysis},
    pdfsubject = {Bio-informatics,statistics},
    pdfkeywords = {microarray, human transcriptome, whole transcript assay, gene array, CMET}
}

\setlength{\parskip}{1em}
\setcounter{secnumdepth}{5} \setcounter{tocdepth}{5}

\begin{document}
%\SweaveOpts{concordance=TRUE}
%\SweaveOpts{concordance=TRUE}

\input{title}
\tableofcontents
\listoffigures
\listoftables

%!Rnw weave = knitr
<<global,include=FALSE,cache=FALSE>>=
library(knitr)
  opts_chunk$set(
  concordance=TRUE,
  echo=FALSE,
  fig.path='SweaveFigures/plot-',
  cache.lazy = FALSE,
  fig.align='center'
  )
  opts_knit$set(
  self.contained=FALSE
  )

options(width=60)
options(knitr.table.format = "latex")
options(digits=2)
  
path <- "/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/"
dpi <- 600

sanitize <- function(str) {
  result <- str
  result <- gsub("&", "\\\\&", result, fixed = TRUE)
  result <- gsub("_", "\\\\_", result, fixed = TRUE)
  result
}

options(digits = 22)
@

<<Load packages,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=FALSE>>=
# Load data
  library(gtools)
# library(gdata)

# Formatting data
library(reshape2)
library(plyr)
library(dplyr)
library(tidyr)
#library(stringi)  
#library(stringr)
#library(splitstackshape)
library(kableExtra)
library(formattable)
library(data.table)
library(texPreview)

# Plotting data
library(ggplot2)
library(ggrepel)
library(cowplot)
library(pacman)
library(RColorBrewer)
library(colorspace)
library(corrgram)
library(corrplot)
library(GGally)
library(circlize)
library(magick)
source(paste0(path,'KDP_scale.R'))
library(ggforce)
library(ggpubr)
#library(plot3D)
#library(igraph)

# Export data
library(openxlsx)

# Univariate statistics
#library(moments)
#library(asbio) 
#library(multcompView) 
#library(gvlma)

# Multivariate statistical analysis
# library(car)
# library(cluster)
# library(stats)
# library(ropls)
library(mixOmics)
library(ComplexHeatmap)
# library(scales)

# Processing Illumina amplicon sequencing data
library(phyloseq)
library(microbiome)
library(vegan)
# library(DESeq2)

# Processing Affimetrix transcriptomics data
library(Matrix)
library(lattice)
library(fdrtool)
library(rpart)
library(oligo)
library(pd.hugene.2.1.st)
library(hugene21sttranscriptcluster.db)
library(org.Hs.eg.db)
library(limma)
library(Biobase)
library(Biostrings)
library(genefilter)
library(RCurl)
options(RCurlOptions=list(http.version=HTTP_VERSION_1_0))
library(biomaRt)
library(AnnotationDbi)
library(plotROC)
library(arrayQualityMetrics)
library(doParallel)
library(doSNOW)
library(topGO)
source('/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/gglocator.R')
library(ReactomePA)
library(gage)
library(pathview)

# User defined functions
source(paste0(path,"KDP_papertheme_smallsize.R"))
source(paste0(path,"getmode.R"))
papertheme(ggplot(),sizeselect=8)
source(paste0(path,'lm_eqn.R'))
source('/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KDP_volcano_limma_thresholdselect.R')
@

<<Define colors,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=FALSE>>=
# General colors   
  threecolors= c("#323C4D","#A03D44","#98B736")
  fourcolors = c("darkorange2","#feb24c","#bcbddc","#756bb1") 
  sevencolors = c("#9BD0E3","#DFDA5F","#9FDF9D","#E3B1D2","#E3B573","#6EDFC4","#B2E078")
  elevencolors = c("#000000","#CD6600","#36648B","#008B00","#7A378B","#838B83","#8B0000","#323C4D","#A03D44","#98B736","#C8ADA4")
  fifteencolors <- c("#000000","#CD6600","#36648B","#008B00","#7A378B","#838B83","#8B0000","#323C4D","#C9A325","#A03D44","#98B736","#C8ADA4","#BB5236","#7FCD50","#AB5CC7")
  thirtycolors=c("#323F24","#CB51D7","#72E245","#DE4F2D","#81DDC7","#6584C6","#CFAE3C","#914261","#BFDC86","#CDC6BE","#D3469A","#3C315A","#607B30","#DD4469","#5B9072","#CA9FC7","#7F592D","#5A656D","#D1867F","#4C2426","#79B6CE","#6E67D1","#CBDC3F","#63D98B","#97362B","#CBB37D","#7E3F85","#CF8338","#5DA73A","#CB80D0")
  thirtyfourcolors <- c("#323F24","#CB51D7","#72E245","#81DDC7","#6584C6","#DE4F2D","#CFAE3C","#914261","#BFDC86","#CDC6BE","#D3469A","#3C315A","#607B30","#DD4469","#5B9072","#CA9FC7","#7F592D","#5A656D","#D1867F","#4C2426","#79B6CE","#6E67D1","#CBDC3F","#63D98B","#97362B","#CBB37D","#7E3F85","#CF8338","#5DA73A","#CB80D0","#7eb96b","#9366e9","#ffdab9","#7eb96b")
  
# Colors for factors in experiment 2
  donorcolors_40<- c("#7eb96b","#9366e9","#6eb729","#b55edb","#46c353","#a92fa4","#afc52e","#3468e5","#b4a823","#5a4fc4","#82cf62","#e357bc","#4b9925","#cf6bd6","#369039","#e53486","#39c685","#bc2c84","#8eab32","#6b4bb1","#e1b338","#6574de","#ea952a","#4691eb","#e96f2d","#366bb3","#bfbf51","#a475e0","#64862b","#8f449d","#839331","#ed84da","#428b50","#e32851","#47cebe","#bc2d1e","#59bfec","#ec5438","#3db6c0","#e93e73","#6ebf92","#ef5fa0","#349176","#d73e50","#3793c2","#c14d17","#6c99d9","#c37524","#988ce5","#b79c36","#d58fe9","#4d6b26","#9f6bbb","#887e22","#714e98","#b58427","#5f5ba3","#e2a35a","#42548c","#ee915a","#727ab3","#a7571b","#aaa4e5","#585a16","#e09fd9","#2a6a45","#d44375","#a1b86c","#bf5b98","#bbb16c","#96487e","#888f50","#b7365d","#69672d","#b785c4","#7b5d16","#f18eb6","#a07f3d","#c980ae","#dab27a","#9b3956","#8f7042","#cf6589","#8f5527","#8e5170","#f3775a","#85424d","#ee9f81","#aa3a3a","#c18c63","#d5687b","#c77c48","#e48c8f","#97411f","#f48671","#a46442","#dd696c","#af615c","#d45945","#c76952")
  visitcolors_6 <- brewer.pal(7,"Set2")[c(1:5,7)]
  peptancolors_2 <- c("darkorange2","#756bb1") #c("#cdc0b0","#5f9ea0")
  peptancolors_3 <- c("#20b2aa","darkorange2","#756bb1")
  peptancolors_4 <- c("#20b2aa","#8b0a50","darkorange2","#756bb1")
  peptancolors_PCP <- c("#20b2aa","#8b0a50","darkorange2")
  peptancolors_PIIm <- c("#20b2aa","#8b0a50","#756bb1")
  dosecolors_5 <- c("#421010","#00008B","#FFA500","#008080","#ff3030")
  BSScolors_7 <-  c("#9BD0E3","#DFDA5F","#9FDF9D","#E3B1D2","#E3B573","#6EDFC4","#B2E078")
  SCFAcolors_8 <- brewer.pal(8,"Dark2")
  type_dosecolors11 <- c("#ee7600FF","#ee7600CC","#ee7600A6","#ee760073","#ee760040","#756bb1FF","#756bb1D9","#756bb1A6","#756bb173","#756bb140","#756bb10D")
  type_dosecolors10 <- c("#8b0a50","#ee7600FF","#ee7600A6","#ee760073","#ee760040","#8b0a50","#756bb1FF","#756bb1A6","#756bb173","#756bb140")
  type_dosecolors8 <- c("#ee7600FF","#ee7600A6","#ee760073","#ee760040","#756bb1FF","#756bb1A6","#756bb173","#756bb140")
  type_dosecolors_PCP <- c("#8b0a50","#ee7600FF","#ee7600A6","#ee760073","#ee760040")
  type_dosecolors_PIIm <- c("#8b0a50","#756bb1FF","#756bb1A6","#756bb173","#756bb140")
  eightcolors = c("#9BD0E3","#DFDA5F","#9FDF9D","#E3B1D2","#E3B573","#6EDFC4","#B2E078","#008B00")
  eightcolors=c("#7B4B71","#C5CD42","#C44F44","#91B7C0","#484934","#BA9C5F","#B167C8","#69C467")
  ninecolors = c("#C8ADA4","#7FCD50","#AB5CC7","#BB5236","#50354B","#535F37","#CCB24D","#C54F80","#7E91C5")
  tencolors = c("#C8ADA4","#7FCD50","#AB5CC7","#BB5236","#50354B","#535F37","#CCB24D","#C54F80","#7E91C5","#7CCCAC")
  elevencolors = c("#000000","#CD6600","#36648B","#008B00","#7A378B","#838B83","#8B0000","#323C4D","#A03D44","#98B736","#C8ADA4")
  twelvecolors <- c("#000000","#CD6600","#36648B","#008B00","#7A378B","#838B83","#8B0000","#323C4D","#A03D44","#98B736","#C8ADA4","#BB5236")
  fifteencolors <- c("#000000","#CD6600","#36648B","#008B00","#7A378B","#838B83","#8B0000","#323C4D","#C9A325","#A03D44","#98B736","#C8ADA4","#BB5236","#7FCD50","#AB5CC7")
  twelvecolors <- c("#008B00","#7A378B","#838B83","#8B0000","#323C4D","#A03D44","#98B736","#C8ADA4","#BB5236" ,"#7FCD50","#AB5CC7","#C9A325")

  
  samplecolors <- c("#ee7600FF","#ee7600A6","#ee760040","#756bb1FF","#756bb1A6","#756bb140","#8b0a50FF","#8b0a50A6","#8b0a5040","#20b2aa")
  sample_nocontrolcolors <- c("#ee7600FF","#ee7600A6","#ee760040","#756bb1FF","#756bb1A6","#756bb140","#8b0a50FF","#8b0a50A6","#8b0a5040")
  exsamplecolors <- c("#66545eFF","#66545eCC","#66545e99","#66545e66","#a39193FF","#a39193CC","#a3919399","#a3919366","#aa6f73FF","#aa6f73CC","#aa6f7399","#aa6f7366","#eea990FF","#eea990CC","#eea99099","#eea99066","#f6e0b5FF","#f6e0b5CC","#f6e0b599","#f6e0b566","#ffe9dcFF","#ffe9dcCC","#ffe9dc99","#ffe9dc66")
  
  probetypecolors <- c("#f0e68c","#00688bA6","#00688b80","#00688b59","#00688b33","#ff3030A6","#ff303040","#afeeeeA6","#afeeee33")
  affx_bac_colors <- c("#00008bFF","#00008bA6","#00008b40","#ff1493FF","#ff1493A6","#ffb90fFF","#ffb90fA6","#8b0000FF","#8b0000A6")
  affx_bac_colors_4 <- c("#00008bFF","#ff1493FF","#ffb90fFF","#8b0000FF")
  affx_polyA_colors <-  c("#00008bFF","#00008bD9","#00008bB3","#00008b8C","#00008b66","#00008b40","#ff1493FF","#ff1493D9","#ff1493B3","#ff14938C","#ff149366","#ff149310","#8b0000FF","#8b0000D9","#8b0000B3","#8b00008C","#8b000066","#8b000040","#ffb90fFF","#ffb90fD9","#ffb90fB3","#ffb90f8C","#ffb90f66","#ffb90f40","#32cd32FF","#32cd32D9","#32cd32B3")
  affx_polyA_colors_5 <-  c("#00008bFF","#ff1493FF","#8b0000FF","#ffb90fFF","#32cd32FF")
  housekeepingcolors <- c("#bcd2ee","#a2b5cd","#6e7b8b")
  posnegcolors <- c("#d27d7d","#07b8b4")
 
# Quality of graphs
  dpi <- 300
  dpitiff <- 300
@







\chapter{Affymetrix Human Gene 2.1 ST Array Strip}
Affymetrix Hugene microarrays contain a high density of oligonucleotide probes to profile human gene expression through hybridization with labeled cDNA obtained from mRNA transcripts. Each transcript is detected by a particular group of 25mer probe sequences (median of 21 unique probes), known as a probeset/probe-group \cite{Upton2009}. In total, the HuGene ST array consists of $>$ 1.35 million probes (Table \ref{intro:table1}).

<<Affymetrix array design,include=FALSE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
# Table with useful information
  C1 <- c("Total probes","Exon-level probe sets","Gene-level probe sets","NM and XM – RefSeq coding transcript, well-established and provisional annotations","NR and XR – RefSeq non-coding transcript, well-established and provisional annotations","Total RefSeq transcripts","RS (Entrez) gene count","lincRNA transcripts Derived from the Broad Institute’s Human Body Map lincRNAs and \nTUCP (transcripts of uncertain coding potential) catalog and lncRNA db","ERCC probe sets1","Background probes","Poly-A controls","Hybridization controls")
  C2 <- c("$>$1.35 million","$>$418,000","$>$48,000","$>$33,500","$>$6,500","$>$40,000","$>$25,000","$>$11,000","92","Antigenomic set","dap, lys, phe, thr, trpn","BioB, BioC, BioD, CreX")
  affydesign <- data.frame(C1,C2)
  affydesign$C1 <- linebreak(affydesign$C1,align = c("l"), double_escape = F, linebreaker = "\n")
@

<<Affymetrix array design table,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
# Table with useful information
kable(affydesign,escape = F,booktabs = T,linesep= "",caption = "\\label{intro:table1} Affymetrix Human Gene 2.1 ST Array Strip design specifications.",col.names = NULL,format="latex")  %>% kable_paper() %>% column_spec(1, bold = T)  %>% kable_styling(font_size = 8)
# add ,format="html" after col.names = NULL in kable to see it in viewer
@

Signals from multiple individual probes targeting one transcript need to be merged into a single measure
of expression for a gene in a process called summarization, which is discussed in detail below \cite{Upton2009}.

\section{Triple coculture human cell model}
A reproducible, versatile triple coculture \emph{in vitro} model consisting of immune-like, goblet and epithelial cells in indirect contact with attached gut microbes was developed to permit the mechanistic study of complex microbiota-host interactions in the human gut. The model consisted of a collagen coating with confluent THP-1, LS-174T and T84 cells in DMEM/F-12 at the basolateral side, in indirect contact with an apical bacterial biofilm adhered to a solidified agar-mucin layer covering the Transwell polycarbonate membrane filter (0.4 µm pores). Microbial biofilms were composed of gut microbes derived from a distal colon compartment of the Simulator of the Human Intestinal Microbial Ecosystem (SHIME), with or without \emph{Lactobacillus rhamnosus} GG LMG 18243 (LGG) addition. Transcriptome samples of the 16 hours coincubated triple coculture model with either SHIME or SHIME + LGG microbiota were compared to an untreated Blank condition. For more details, see Materials \& Methods in the manuscript entitled `Versatile human \emph{in vitro} triple coculture model coincubated with adhered gut microbes reproducibly mimics pro-inflammatory host-microbe interactions in the colon' by Beterams et al. 2021.

\section{Example data}
Besides the acquired data form the triple cell coculture model, Affymetrix example data was analyzed in parallel acting as a reference to benchmark the obtained quality metrics. The example dataset consists of quadruplicate microarrays hybridized with liver, muscle, spleen and testes tissue RNA, alongside 100\% of Stratagene's Universal Human Reference RNA and 100\% of Ambion's Human Brain Reference RNA. The latter two are termed MAQCA and MAQCB, and are derived from the Microarray Quality Consortium (MAQC) \cite{Lippa2010}.

%The MAQC project has examined the use of a diverse set of external controls for a number of platforms, noted that external controls have yet to be widely used for performance assessment, and made recommendations for doing so. Analysis of the control signals to assess performance was largely through quantitative characterization of the slope of the signal-concentration curve. A significant observation from this work was the identification of outlier data at one participant’s site using principal component analysis (PCA) of the external controls. More recent analysis of the various spikein controls employed in the measurements for the MAQC project demonstrated promise that the spike-in controls were informative of “outlying” arrays, and that they exhibit behavior that is independent of the sample type.










\chapter{Read in .CEL files, annotation and library files}
Microarray data was loaded and further processed in \verb+\Sexpr{sanitize(R.Version()$version.string)}+ running on a \verb+\Sexpr{sanitize(R.Version()$platform)}+ platform.

\section{CEL files}
The transcriptomics data consists of a series of CEL files containing raw intensities for each probe on the mircoarray (probe level intensity data on a per-chip basis) generated by the Affymetrix software. Data was imported as a GeneFeatureSet using the Oligo package (version \Sexpr{packageVersion("oligo")}). Data transformations are not applied upon data import, but were manually performed afterwards.

<<Load .CEL files, extract raw expression values and add metadata,include=FALSE,results='hide',warning=TRUE,message=FALSE,cache=TRUE>>=
# Load .cel files
  celpath = paste0(path,"CELfiles")
  listcelfiles = list.files(celpath,full.names=TRUE)
  CELdata = read.celfiles(listcelfiles,pkgname = "pd.hugene.2.1.st",sampleNames =  c("Blank1","Blank2","Blank3","HelaControl","SHIME1","SHIME2","SHIME3","SHIME_LGG1","SHIME_LGG2","SHIME_LGG3"))
  CELdata
  class(CELdata)

# Add sample metadata
  metadata <- read.csv2(paste0(path,"Metadata.csv"),fill=TRUE,sep=";",header=T,na.strings=T)
  rownames(metadata) <- rownames(CELdata@phenoData)
  varmetadata <- data.frame(labeldDescription=colnames(metadata),channel=factor("ALL"))
  pd <- new('AnnotatedDataFrame', data=metadata, varMetadata=varmetadata)
  phenoData(CELdata) <- pd
  metadata_nocontrol <- metadata %>% subset(Condition!="Control")

# Sample name order for graphs
  samplevel <-  c("Blank1","Blank2","Blank3","SHIME1","SHIME2","SHIME3","SHIME_LGG1","SHIME_LGG2","SHIME_LGG3","HelaControl")
  sampleplotname <- c("Blank1","Blank2","Blank3","SHIME1","SHIME2","SHIME3","SHIME \n LGG1","SHIME \n LGG2","SHIME \n LGG3","HelaControl")


# Data stored in an ExpressionSet
  ## Query experiment annotation data
     CELdata@experimentData

  ## Query sample information
     CELsampledata <- CELdata@phenoData
     CELsampledata
     pData(CELdata)

  ## Query feature information
     CELdata@featureData
     fData(CELdata)

  ## Extract expression values (= intensities)
     CELdata_expr = exprs(CELdata)
     dim(CELdata_expr)
     class(CELdata_expr)
     CELdata_int = oligo::intensity(CELdata)
     dim(CELdata_int)
     class(CELdata_int)
     CELdata@assayData
@

Metadata is provided in the phenodata field of the GeneFeatureSet. The following variables were included:
<<Metadata variables,results='markup',include=TRUE,warning=FALSE,message=FALSE,cache=TRUE,tidy.opts=list(keep.blank.line=FALSE, width.cutoff=50),cache=TRUE>>=
# Overview of metadata variables
  colnames(metadata)
@

<<Load example .CEL files, extract raw expression values and add metadata,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
# Load .cel files
  excelpath = paste0(path,"exampleCELfiles")
  listexcelfiles = list.files(excelpath,full.names=TRUE)
  EXCELdata = read.celfiles(listexcelfiles,pkgname = "pd.hugene.2.1.st",sampleNames =  c("Liver1","Liver2","Liver3","Liver4","MAQCA1","MAQCA2","MAQCA3","MAQCA4","MAQCB1","MAQCB2","MAQCB3","MAQCB4","Muscle1","Muscle2","Muscle3","Muscle4","Spleen1","Spleen2","Spleen3","Spleen4","Testes1","Testes2","Testes3","Testes4"))
  EXCELdata
  class(EXCELdata)

# Sample name order for graphs
  exsamplevel <-  c("Liver1","Liver2","Liver3","Liver4","Muscle1","Muscle2","Muscle3","Muscle4","Spleen1","Spleen2","Spleen3","Spleen4","Testes1","Testes2","Testes3","Testes4","MAQCA1","MAQCA2","MAQCA3","MAQCA4","MAQCB1","MAQCB2","MAQCB3","MAQCB4")

# Look at sample data
  EXCELsampledata <- EXCELdata@phenoData
@

\section{Annotation files}
Probe and probeset IDs (also called feature and feature set ID), as well as, probe sequence info are contained in the GeneFeatureSet created from the .CELdata thanks to the associated annotation package: \citation(`pd.hugene.2.1.st'). This annotation package is based on the `HuGene-2\_1-st-v1.na36.hg19.probeset.csv' and `HuGene-2\_1-st-v1.na36.hg19.transcript.csv' files. Annotation (and summarization, see below) can be performed either at probeset (target = probeset; corresponding to an exon) or at transcript (target = core; corresponding to a gene) level. Traditionally, Affymetrix arrays (the so-called 3’ IVT arrays) were probeset based: a certain fixed group of probes were part of a probeset which represented a certain gene or transcript (note however, that a gene can be represented by multiple probesets). The more recent `Gene' and `Exon' Affymetrix arrays are exon based and hence there are two levels of summarization to get to the gene level. The `probeset' summarization leads to the exon level. The gene/transcript level is given by `transcript clusters' \cite{Klaus2016}.

Feature IDs (`fid') are assigned to individual features or probes (sequences on the microarray) and are identical between exon and gene level analysis, while the feature set IDs (`man\_fsetid') differ for the exon or transcript level analysis. Feature set IDs are not unique (all the probes within a feature set have the same feature set ID). Note that feature IDs are also not unique, as the same fid can occur multiple times, in different probesets/transcript clusters. Therefore a unique identifier combining the feature and feature set IDs is constructed.

<<Query probe information in CEldata object,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
# Get probe and probeset names: Probenames from the .CEL object can be accessed and will return a string with the probeset names for each probe on the array (1025088 non-unique names for gene level analysis). The unique probeset names can be acquired through the probesetNames command.
  probenames_core <- probeNames(CELdata,target="core") # same name may occur multiple times (multiple probes within same transcript)
  length(probenames_core)
  probenames_core[duplicated(probenames_core,fromLast=FALSE)|duplicated(probenames_core,fromLast=TRUE)]
  unique(probenames_core)
  length(unique(probenames_core))
  probesetnames_core <-probesetNames(CELdata,target="core") # the unique transcript names
  length(probesetnames_core)

  probenames_probeset <- probeNames(CELdata,target="probeset")
  length(probenames_probeset)
  probenames_probeset[duplicated(probenames_probeset,fromLast=FALSE)|duplicated(probenames_probeset,fromLast=TRUE)]
  unique(probenames_probeset)
  length(unique(probenames_probeset))
  probesetnames_probeset <-probesetNames(CELdata,target="probeset")
  length(probesetnames_probeset)

# Get probe information and order in same way as the probenames output is given - probeType BG or PM gives same results. bg probes are part of the pm probe subset.
  probe_annotation_core <- getProbeInfo(CELdata,probeType = "pm",target="core",sortBy = "fid",field=c('fid', 'fsetid', 'type','x','y','chrom'))
  probe_annotation_core$uniqueid <- paste(probe_annotation_core$man_fsetid,probe_annotation_core$fid,sep="_")
  dim(probe_annotation_core)
  length(unique(probe_annotation_core$man_fsetid))
  length(unique(probe_annotation_core$fid))
  setdiff(probenames_core,probe_annotation_core$man_fsetid)
  setdiff(probesetnames_core,probe_annotation_core$man_fsetid)

  probe_annotation_probeset <- getProbeInfo(CELdata,probeType = "pm",target="probeset",sortBy = "fid",field=c('fid', 'fsetid', 'type','x','y','chrom'))
  probe_annotation_probeset$uniqueid <- paste(probe_annotation_probeset$man_fsetid,probe_annotation_probeset$fid,sep="_")
  dim(probe_annotation_probeset)
  length(unique(probe_annotation_probeset$man_fsetid))
  length(unique(probe_annotation_probeset$fid))
  setdiff(probenames_probeset,probe_annotation_probeset$man_fsetid)
  setdiff(probesetnames_probeset,probe_annotation_probeset$man_fsetid)

  setdiff(probe_annotation_core$fid,probe_annotation_probeset$fid)
  setdiff(probe_annotation_probeset$fid,probe_annotation_core$fid)

# Accessing probe sequences of the perfect match probes
  oligo::bgSequence(CELdata)
  length(oligo::bgSequence(CELdata))

  pmsequence_core <- oligo::pmSequence(CELdata,target="core")
  pmsequence_core
  length(pmsequence_core)
  length(unique(pmsequence_core))
  length(pmsequence_core[duplicated(pmsequence_core)])

  pmsequence_probeset <- oligo::pmSequence(CELdata,target="probeset")
  pmsequence_probeset
  length(pmsequence_probeset)
  length(unique(pmsequence_probeset))
  length(pmsequence_probeset[duplicated(pmsequence_probeset)])

# Accessing indices of the perfect match probes: indices are the same as the fid
  pmindex_core <- oligo::pmindex(CELdata,target="core")
  length(pmindex_core)
  length(unique(pmindex_core))
  pmindex_core[duplicated(pmindex_core,fromLast=FALSE)|duplicated(pmindex_core,fromLast=TRUE)]
  length(pmindex_core[duplicated(pmindex_core,fromLast=FALSE)|duplicated(pmindex_core,fromLast=TRUE)])

  pmindex_probeset <- oligo::pmindex(CELdata,target="probeset")
  length(pmindex_probeset)
  pmindex_probeset[duplicated(pmindex_probeset,fromLast=FALSE)|duplicated(pmindex_probeset,fromLast=TRUE)]
  length(unique(pmindex_probeset))
  length(pmindex_probeset[duplicated(pmindex_probeset,fromLast=FALSE)|duplicated(pmindex_probeset,fromLast=TRUE)])

  setdiff(pmindex_probeset,pmindex_core)

# Match indices and sequences of the perfect match probes (indices are the same as the fids)
  #pm_indexsequence_core <- cbind(pmindex_core,data.frame(pmsequence_core))
  #pm_indexsequence_probeset <- cbind(pmindex_probeset,data.frame(pmsequence_probeset))

# Link probe ID and probe sequences contained in the GeneFeatureSet
  data(pmSequence) #load the probe sequences as dataset
  class(pmSequence)
  setdiff(probe_annotation_core$fid,pmSequence[["fid"]])

  idx <- match(probe_annotation_core$fid,pmSequence[["fid"]])
  probesequence_core <- pmSequence[idx,] #find probe IDs in the sequence dataframe
  probesequence_core <- data.frame(fid=probesequence_core["fid"],sequence = as.character(probesequence_core[["sequence"]]),stringsAsFactors=FALSE) # similar as previous but in dataframe format
  setdiff(probe_annotation_core$fid,probesequence_core$fid)
  setdiff(probesequence_core$fid,probe_annotation_core$fid)
  #probe_annotation_core <- cbind(probe_annotation_core,probesequence_core)
  probe_annotation_core <- plyr::join(probe_annotation_core,probesequence_core,by="fid","full",match="first")

  idx <- match(probe_annotation_probeset$fid,pmSequence[["fid"]])
  probesequence_probeset <- pmSequence[idx,] #find probe IDs in the sequence dataframe
  probesequence_probeset <- data.frame(fid=probesequence_probeset["fid"],sequence = as.character(probesequence_probeset[["sequence"]]),stringsAsFactors=FALSE) # similar as previous but in dataframe format
  setdiff(probe_annotation_probeset$fid,probesequence_probeset$fid)
  setdiff(probesequence_probeset$fid,probe_annotation_probeset$fid)
  #probe_annotation_probeset <- cbind(probe_annotation_probeset,probesequence_probeset)
  probe_annotation_probeset <- plyr::join(probe_annotation_probeset,probesequence_probeset,by="fid","full",match="first")

# Assign the combined fid and fsetid as rownames
  rownames(probe_annotation_core) <- probe_annotation_core$uniqueid
  rownames(probe_annotation_probeset) <- probe_annotation_probeset$uniqueid

# Find the duplicate, non-unique fids?
  probe_annotation_core[duplicated(probe_annotation_core$fid,fromLast=FALSE)|duplicated(probe_annotation_core$fid,fromLast=TRUE),]
  probe_annotation_probeset[duplicated(probe_annotation_probeset$fid,fromLast=FALSE)|duplicated(probe_annotation_probeset$fid,fromLast=TRUE),]

# Access GC content of perfect matching probes
  Nucleotidecounts_core <- Biostrings::alphabetFrequency(oligo::pmSequence(CELdata,target="core"), baseOnly=TRUE)
  GCcontent_core <- ordered(Nucleotidecounts_core [, "G"]+Nucleotidecounts_core [, "C"])
  GCcontent_core
  GCcontent_core_annotated <- mutate(probe_annotation_core,GCcontent=as.numeric(as.character(GCcontent_core)))

  Nucleotidecounts_probeset <- Biostrings::alphabetFrequency(oligo::pmSequence(CELdata,target="probeset"), baseOnly=TRUE)
  GCcontent_probeset <- ordered(Nucleotidecounts_probeset [, "G"]+Nucleotidecounts_probeset [, "C"])
  GCcontent_probeset
@

<<Table with probe information in CEldata object,results='markup',include=TRUE,warning=FALSE,message=FALSE,cache=TRUE,tidy.opts=list(keep.blank.line=FALSE, width.cutoff=50)>>=
# Example
  head(probe_annotation_core)
  head(probe_annotation_probeset)
@

<<Query probe information in AffyGenePDInfo or ChipDb object via sql language,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
# Load AffyGenePDInfo for human gene ST 2.1 array
  pd.hugene.2.1.st # Chip geometry: 1190*1190=1416100 = right number of features pd.hugene.2.1.st
  ls("package:pd.hugene.2.1.st")
  class(pd.hugene.2.1.st)
  pd.hugene.2.1.st@getdb()
  pd.hugene.2.1.st@tableInfo
  pd.hugene.2.1.st@annotation

  Hugene_AffyGenePDInfo <- db(pd.hugene.2.1.st)
  class(Hugene_AffyGenePDInfo)

  dbGetQuery(Hugene_AffyGenePDInfo, "select * from chrom_dict;")
  dbGetQuery(Hugene_AffyGenePDInfo, "select * from core_mps;")
  dbGetQuery(Hugene_AffyGenePDInfo, "select * from featureSet;")
  dbGetQuery(Hugene_AffyGenePDInfo, "select * from level_dict;")
  dbGetQuery(Hugene_AffyGenePDInfo, "select * from pmfeature;")
  dbGetQuery(Hugene_AffyGenePDInfo, "select * from type_dict;")

# Query SQL database
  dbGetQuery(Hugene_AffyGenePDInfo, "select distinct fsetid, type from featureSet;")
  table(dbGetQuery(Hugene_AffyGenePDInfo, "select fsetid from pmfeature;")[,1])

# ChipDb object
  hugene21sttranscriptcluster.db
  class(hugene21sttranscriptcluster.db)
  ls("package:hugene21sttranscriptcluster.db")

  columns(hugene21sttranscriptcluster.db) # columns available to search via select
  keytypes(hugene21sttranscriptcluster.db) #fields to use as keys to query the db
  keys(hugene21sttranscriptcluster.db,keytype = "UNIPROT")

  test <- "16650687"
  select(hugene21sttranscriptcluster.db,keys=unique(test),columns=c("SYMBOL","GENENAME"),keytype = "PROBEID") # select keys we want to look up values for (keys), what we want returned back (columns) and the type of keys that we are passing in (keytype)
@

<<Link probe IDs to ENSEMBL IDs,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
# Loading most recent ensembl homo sapiens gene dataset
  listEnsemblArchives()
  ensembl <- useMart("ENSEMBL_MART_ENSEMBL", dataset="hsapiens_gene_ensembl",host='ensembl.org',archive=FALSE)
# List the available attributes and filters
  ensembllist <- listAttributes(ensembl)
  ensemblfilters <- listFilters(ensembl)
# Look for a specific ensembl gene eg GAPHD https://www.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000111640;r=12:6534512-6538374  ACTB: https://www.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000075624;r=7:5526409-5563902 HMBS:https://www.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000256269;r=11:119084866-119093549
  housekeeping_geneIDs <- getBM(attributes=c("affy_hugene_2_0_st_v1","ensembl_gene_id","entrezgene_id","external_gene_name"), filters="ensembl_gene_id",values=c("ENSG00000111640","ENSG00000075624","ENSG00000256269"), mart=ensembl) # ,"definition_1006"
  housekeeping_geneIDs
  housekeeping_geneIDs_query <- c(na.omit(housekeeping_geneIDs[,1]))

## Loading required package: GenomeInfoDb
conn <- db(CELdata) # results similar to when querying Hugene_AffyGenePDInfo
fields <- 'fsetid, start, stop'
tables <- 'featureSet'
sql <- paste("select", fields,"from", tables,"WHERE featureSet.fsetid=16650673")  #:probeIDs_query
dbGetQuery(conn,sql)
@

<<Load excel annotation files from Affymetrix website,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
# Load annotation files obtained from the affymetrix website - https://www.thermofisher.com/order/catalog/product/902114#/902114
  annotationpath = paste0(path,"AnnotationFiles/")
  annotation_transcript <- read.table(file = paste0(annotationpath,"HuGene-2_1-st-v1.na36.hg19.transcript.csv"), header = T, sep = ",",quote = "\"", dec = ".")
  annotation_probeset<- read.table(file = paste0(annotationpath,"HuGene-2_1-st-v1.na36.hg19.probeset.csv"), header = T, sep = ",",quote = "\"", dec = ".")

  unique(annotation_transcript$category)
  annotation_transcript_main <- annotation_transcript %>% subset(category=="main")
  annotation_transcript_rescue <- annotation_transcript %>% subset(category=="rescue")
  annotation_transcript_controlbgpantigenomic <- annotation_transcript %>% subset(category=="control->bgp->antigenomic")
  annotation_transcript_normgeneexon <- annotation_transcript %>% subset(category=="normgene->exon")
  annotation_transcript_normgeneintron <- annotation_transcript %>% subset(category=="normgene->intron")
  annotation_transcript_normgeneexon <- annotation_transcript %>% subset(category=="normgene->exon")
  annotation_transcript_controlaffxbacspike<- annotation_transcript %>% subset(category=="control->affx->bac_spike")
  annotation_transcript_controlaffxpolyaspike <- annotation_transcript %>% subset(category=="control->affx->polya_spike")
  annotation_transcript_reporter <- annotation_transcript %>% subset(category=="reporter")
  annotation_transcript_controlaffxercc <- annotation_transcript %>% subset(category=="control->affx->ercc")
  dim(annotation_transcript)
  length(unique(probenames_core))

  unique(annotation_probeset$probeset_type)
  annotation_probeset_main <- annotation_probeset %>% subset(probeset_type=="main")
  annotation_probeset_rescue <- annotation_probeset %>% subset(probeset_type=="rescue")
  annotation_probeset_controlaffx <- annotation_probeset %>% subset(probeset_type=="control->affx")
  annotation_probeset_controlbgpantigenomic <- annotation_probeset %>% subset(probeset_type=="control->bgp->antigenomic")
  annotation_probeset_normgeneintron <- annotation_probeset %>% subset(probeset_type=="normgene->intron")
  annotation_probeset_controlaffxbacspike<- annotation_probeset %>% subset(probeset_type=="control->affx->bac_spike")
  annotation_probeset_controlaffxpolyaspike <- annotation_probeset %>% subset(probeset_type=="control->affx->polya_spike")
  annotation_probeset_reporter <- annotation_probeset %>% subset(probeset_type=="Reporter")
  annotation_probeset_controlaffxercc <- annotation_probeset %>% subset(probeset_type=="control->affx->ercc")
  dim(annotation_probeset)
  length(unique(probenames_probeset))

# Check if probeset names in Affymetrix csv files correspond to the automatic probeset names assigned by oligo
  length(unique(probe_annotation_core$man_fsetid))
  setdiff(annotation_transcript$probeset_id,probe_annotation_core$man_fsetid) # transcript corresponds to the core option

  length(unique(probe_annotation_probeset$man_fsetid))
  setdiff(probe_annotation_probeset$man_fsetid,annotation_probeset$probeset_id) # probeset corresponds to the probeset level
  annotation_probeset_notinoligo <- annotation_probeset[ setdiff(probe_annotation_core$man_fsetid,annotation_probeset$probeset_id),]

  unique(setdiff(probe_annotation_probeset$man_fsetid,probe_annotation_core$man_fsetid))
  unique(setdiff(probe_annotation_core$man_fsetid,probe_annotation_probeset$man_fsetid))
  length(unique(setdiff(probe_annotation_probeset$man_fsetid,probe_annotation_core$man_fsetid))) # 347468 - 5391 in common
  length(unique(setdiff(probe_annotation_core$man_fsetid,probe_annotation_probeset$man_fsetid))) # 48226 - 5391 in common

# Compare with fset ids and transcript_cluster_ids that can be queried in the Hugene_AffyGenePDInfo
  probe_fsetid <- dbGetQuery(Hugene_AffyGenePDInfo, "select fsetid from featureSet;")
  dim(probe_fsetid)

  length(setdiff(annotation_transcript$probeset_id,probe_fsetid$fsetid))
  setdiff(annotation_transcript$probeset_id,probe_fsetid$fsetid)

  length(setdiff(annotation_probeset$probeset_id,probe_fsetid$fsetid))
  setdiff(annotation_probeset$probeset_id,probe_fsetid$fsetid)

  probe_transcriptclusterid <- dbGetQuery(Hugene_AffyGenePDInfo, "select transcript_cluster_id from featureSet;")
  dim(probe_transcriptclusterid)

  # transcript cluster ID is identical to probeset ID in the transcript file
  length(setdiff(annotation_transcript$probeset_id,probe_transcriptclusterid$transcript_cluster_id)) # 1626 more ids in the transcript probeset ID
  length(setdiff(probe_transcriptclusterid$transcript_cluster_id,annotation_transcript$probeset_id)) # 0
  setdiff(annotation_transcript$probeset_id,probe_transcriptclusterid$transcript_cluster_id)
  setdiff(annotation_transcript$probeset_id,annotation_transcript$transcript_cluster_id)

  # transcript cluster ID is different from probeset ID in the probeset file: indicates which probesets are in the same cluster
  length(setdiff(annotation_probeset$probeset_id,probe_transcriptclusterid$transcript_cluster_id)) # 349094 more ids in the probeset probesetID
  length(setdiff(probe_transcriptclusterid$transcript_cluster_id,annotation_probeset$probeset_id)) # 48226 more ids in the transcript cluster ID then
@

There are \Sexpr{nrow(annotation_probeset)} probesets and \Sexpr{nrow(annotation_transcript)} transcript clusters. The mapping of probesets to transcript cluster IDs can be viewed in the probeset csv file. In the transcript csv file the probeset ID is identical to the transcript cluster ID. The following annotation columns are present:

<<Probeset and transcript annotation information,results='markup',include=TRUE,warning=FALSE,message=FALSE,cache=TRUE,tidy.opts=list(keep.blank.line=FALSE, width.cutoff=50)>>=
  colnames(annotation_transcript)
  colnames(annotation_probeset)
@

\section{Library files}
Additional information about the probes is contained in the Affymetrix library files which are also integrated in the oligo annotation package: citation (`pd.hugene.2.1.st'). The following additional information is provided in these files:

<<Load library files from Affymetrix website,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
  libfilespath = "/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/LibFiles/"

  lib_bed <- read.table(file = paste0(libfilespath,"HuGene-2_1-st-v1.hg19.bed"), header = F, sep = "\t",quote = "\"", dec = ".",fill=TRUE)
  # https://genome.ucsc.edu/FAQ/FAQformat.html#format1: lib_bed[1,]
  lib_fasta <- read.table(file = paste0(libfilespath,"HuGene-2_1-st-v1.hg19.probe.fa"), header = F, sep = "\t",quote = "\"", dec = ".",fill=TRUE)
  lib_tabular <- read.table(file = paste0(libfilespath,"HuGene-2_1-st-v1.hg19.probe.tab"), header = T, sep = "\t",quote = "\"", dec = ".",fill=TRUE)
  lib_bgp <- read.table(file = paste0(libfilespath,"HuGene-2_1-st.bgp"), header = T, sep = "\t",quote = "\"", dec = ".",fill=TRUE)
  lib_mps <- read.table(file = paste0(libfilespath,"HuGene-2_1-st.mps"), header = T, sep = "\t",quote = "\"", dec = ".",fill=TRUE)
  lib_pgf <- read.table(file = paste0(libfilespath,"HuGene-2_1-st.pgf"), header = F, sep = "\t",quote = "\"", dec = ".",fill=TRUE)
  lib_ps <- read.table(file = paste0(libfilespath,"HuGene-2_1-st.ps"), header = F, sep = "\t",quote = "\"", dec = ".",fill=TRUE)
  lib_qcc <- read.table(file = paste0(libfilespath,"HuGene-2_1-st.qcc"), header = F, sep = "\t",quote = "\"", dec = ".",fill=TRUE)
@

<<Probe information from affymetrix library files,results='markup',include=TRUE,warning=FALSE,message=FALSE,cache=TRUE,tidy.opts=list(keep.blank.line=FALSE, width.cutoff=50)>>=
# Probe sequence information:
  colnames(lib_tabular)
# Background probe file that lists the probes to use for background correction:
  colnames(lib_bgp)
  unique(lib_bgp$probe_type)
# Meta-probeset file specifies a new probeset ID as a container of one or more probesets. For example, an MPS file can define a new gene level probeset as a set of existing exon level probesets to summarize the data to the gene level.
  colnames(lib_mps)
# The PGF (probe group file) provides information about what probes are contained within a probeset and information about the nature of the probes necessary for analysis.
  lib_pgf[1:9,]
# The PS (probeset list file) specifies a list of probeset IDs.
  lib_ps[1,]
# The QCC file is used to define quality assessment groupings (defines group membership for probesets on a chip).
  lib_qcc[5225,]
  unique(lib_qcc[lib_qcc$V4==1,]$V3)
@

Some more information about the data fields:
\begin{itemize}
\item Probex en Probey refer to the x and y coordinates for probe locations on the array.
\item Assembly refers to the genome assembly version used for the array design data: in this case the UCSC hg19 build which corresponds to the NCBI GRCh37 build was used. The design-time vs. annotation-time version of the genome assembly may differ since  array designs are occasionally mapped or `lifted' to an updated version of the genome assembly for improved annotation by the NetAffxAnalysis Center.
\item Seqname refers to the	sequence name for the genomic location of probes (chromosome).
\item Start	refers to the starting coordinate of probe genomic location (1-based).
\item Stop	refers to the ending coordinate of probe genomic location (1-based).
\item Strand refers to the sequence strand of probe genomic location (+ or -).
\item Probe sequence refers to the probe sequence.
\item Sense/Antisense refers to the Strandedness of the target which the probe detects.
\item Category(also called probeset type) refers to the array design category of the probe: this can be either main or different types of controls (outlined below).
\item An atom refers to a particular collection of probes that are interrogating the same position. For expression arrays an atom is usually a probe pair (pm and mm probe pair) for arrays of the HG-U133 series, or a single pm probe for arrays like Human Gene or Exon ST that do not contain mismatch probes.
\item Group name identifies the group(s) of which the probeset is a member.
\end{itemize}

Affymetrix ATP or Array Power Tools uses the library and annotation files and creates additional CDF (Chip Description Files) containing the Chip layout information (i.e. what probes are where on the chip and how are they grouped into probesets) and CHP files containing probeset summary information (ie probeset signal, gene-level information) on a per chip basis. In R a pdInfoPackage built using the pdInfoBuilder collates the cdf, probe and annotation data together: citation (`pd.hugene.2.1.st'). This .pd information can be queried through sql commands. Alternatively probenames (`fid'), probeset names (`fset\_id'), probe information (x,y,chrom,type), probe sequences and GC content can be interrogated from the .CEL data through Oligo commands. Finally, the data can be reclassified post-normalization using ChipDb objects (explained hereinafter).

<<Identify control probes,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
  Hugene_AffyGenePDInfo <- db(pd.hugene.2.1.st)
# Explore the probeset types
  probetypes_options <- data.frame(dbGetQuery(Hugene_AffyGenePDInfo, "select distinct * from type_dict;"))
  probetypes <- dbGetQuery(Hugene_AffyGenePDInfo, "select type,transcript_cluster_id,fsetid from featureSet;")

# Verify if probeset types correspond to what can be found in the Affymetrix csv files and add type_id
  length(unique(probetypes$fsetid))
  setdiff(probetypes$fsetid,annotation_probeset$probeset_id)
  setdiff(probetypes$fsetid,annotation_transcript$probeset_id)

  unique(probetypes$type)
  probetypes[which(is.na(probetypes$type)),]
  annotation_probeset[annotation_probeset$probeset_id=="17118481",] # NA corresponds to Reporter and rescue type

  probetypes$type_id <- mapvalues(probetypes$type,from=c(probetypes_options$type,NA),to=c(probetypes_options$type_id,"Reporter+Rescue"))
  probetypes$type_id <- factor(probetypes$type_id,levels=c("main","control->affx","control->affx->bac_spike","control->affx->polya_spike","normgene->intron","control->bgp->antigenomic","control->affx->ercc","Reporter+Rescue"))

  setdiff(probetypes$fsetid,probe_annotation_probeset$man_fsetid)
  setdiff(probetypes$fsetid,probe_annotation_core$man_fsetid) # there are less entries in the transcript/core annotation

  probe_annotation_core$type <- mapvalues(probe_annotation_core$type,from=NA,to="Reporter+Rescue")
  probe_annotation_probeset$type <- mapvalues(probe_annotation_probeset$type,from=NA,to="Reporter+Rescue")
  probe_annotation_core$type <- factor(probe_annotation_core$type,levels=c("main","control->affx","control->affx->bac_spike","control->affx->polya_spike","normgene->intron","control->bgp->antigenomic","control->affx->ercc","Reporter+Rescue"))
  probe_annotation_probeset$type <- factor(probe_annotation_probeset$type,levels=c("main","control->affx","control->affx->bac_spike","control->affx->polya_spike","normgene->intron","control->bgp->antigenomic","control->affx->ercc","Reporter+Rescue"))

# Add probe subtype information
  unique(lib_qcc[lib_qcc$V4==1,]$V1)
  unique(lib_qcc[lib_qcc$V4==1,]$V3)

  probetypes$subtype_id <- mapvalues(probetypes$transcript_cluster_id,from=lib_qcc$V1,to=lib_qcc$V3)
  probetypes$subtype_id <- mapvalues(probetypes$fsetid,from=lib_qcc$V1,to=lib_qcc$V3)

  probe_annotation_core$subtype <- mapvalues(probe_annotation_core$man_fsetid,from=lib_qcc$V1,to=lib_qcc$V3)
  probe_annotation_probeset$subtype <- mapvalues(probe_annotation_probeset$man_fsetid,from=lib_qcc$V1,to=lib_qcc$V3)

# Add probe pos/neg control information
  ## What are the positive and negative controls?
  unique(lib_qcc$V2)
  ## Add them to the annotation df
  probetypes$posneg <- mapvalues(probetypes$transcript_cluster_id,from=lib_qcc$V1,to=lib_qcc$V2)
  probetypes$posneg <- mapvalues(probetypes$fsetid,from=lib_qcc$V1,to=lib_qcc$V2)

  probe_annotation_core$posneg <- mapvalues(probe_annotation_core$man_fsetid,from=lib_qcc$V1,to=lib_qcc$V2)
  probe_annotation_probeset$posneg <- mapvalues(probe_annotation_probeset$man_fsetid,from=lib_qcc$V1,to=lib_qcc$V2)
  ## negative controls correspond to introns?
  probe_annotation_core[probe_annotation_core$posneg=="neg_control",] # = normgene ->introns
  ## positive controls are part of the main probeset
  probe_annotation_core[probe_annotation_core$posneg=="pos_control",] # I guess this is normgene -> exon

# Add the positive controls as normgene -> exon in the type column
  probetypes$type_id <- factor(probetypes$type_id,levels=c("main","control->affx","control->affx->bac_spike","control->affx->polya_spike","normgene->exon","normgene->intron","control->bgp->antigenomic","control->affx->ercc","Reporter+Rescue"))
  probetypes[probetypes$posneg=="pos_control",]$type_id <- "normgene->exon"

  probe_annotation_core$type <- factor(probe_annotation_core$type,levels=c("main","control->affx","control->affx->bac_spike","control->affx->polya_spike","normgene->exon","normgene->intron","control->bgp->antigenomic","control->affx->ercc","Reporter+Rescue"))
  probe_annotation_core[probe_annotation_core$posneg=="pos_control",]$type <- "normgene->exon"

  probe_annotation_probeset$type <- factor(probe_annotation_probeset$type,levels=c("main","control->affx","control->affx->bac_spike","control->affx->polya_spike","normgene->exon","normgene->intron","control->bgp->antigenomic","control->affx->ercc","Reporter+Rescue"))
  probe_annotation_probeset[probe_annotation_probeset$posneg=="pos_control",]$type <- "normgene->exon"

# # Probe types added to dataframe
#   probe_annotation_core_types <- probe_annotation_core
#   probe_annotation_core_types$type_id <- mapvalues(probe_annotation_core$man_fsetid,from=probetypes$transcript_cluster_id,to=probetypes$type_id)
#   probe_annotation_core_types$subtype_id <- mapvalues(probe_annotation_core$man_fsetid,from=probetypes$transcript_cluster_id,to=probetypes$subtype_id)
#   probe_annotation_core_types$posneg <- mapvalues(probe_annotation_core$man_fsetid,from=probetypes$transcript_cluster_id,to=probetypes$posneg)
#
#   probe_annotation_probeset_types <- probe_annotation_probeset
#   probe_annotation_probeset_types$type_id <- mapvalues(probe_annotation_probeset$man_fsetid,from=probetypes$fsetid,to=probetypes$type_id)
#   probe_annotation_probeset_types$subtype_id <- mapvalues(probe_annotation_probeset$man_fsetid,from=probetypes$fsetid,to=probetypes$subtype_id)
#   probe_annotation_probeset_types$posneg <- mapvalues(probe_annotation_probeset$man_fsetid,from=probetypes$fsetid,to=probetypes$posneg)

# Summarize probeset counts per probeset type
  probetypes_summary <- probetypes %>% group_by(type_id) %>% summarise(n())
  probetypes_summary

  ## Is equivalent to:
  probetypes_count <- data.frame(table(dbGetQuery(Hugene_AffyGenePDInfo, "select type from featureSet;")[,1]))
  colnames(probetypes_count) <- c("type","frequency")
  probetypes_count$type <- as.numeric(as.character(probetypes_count$type))
  na.omit(plyr::join(probetypes_options,probetypes_count,by="type","full"))
  ## or also:
  annotation_probeset %>% group_by(probeset_type) %>% summarise(n())
  annotation_transcript %>% group_by(category) %>% summarise(n())

# Summarize probe counts per probeset type
  probe_annotation_core_summary <- probe_annotation_core %>% group_by(type) %>% summarise(n())
  probe_annotation_core_summary

# Add information about the probes
  info <- c("Probesets which are part of the main design","Standard Affymetrix spike control probeset (ie bacterial and polyA spikes)","Probesets which hybridize to pre-labeled Affymetrix bacterial spike controls (BioB, BioC, BioD, and Cre).\nThis category is useful in identifying problems with the hybridization, washing, scanning and/or chip.","Probesets which hybridize to  polyadenylated RNA spikes (Lys, Phe, Thr, and Dap). \nThis category is useful in identifying problems with the target preparation (amplification/labeling).","Probesets against exon regions of a set of housekeeping genes acting as positive controls.\nThis category is useful in identifying problems with sample extraction.","Probesets against intron regions of a set of housekeeping genes acting as negative controls.", "Antigenomic background probesets. Important to determine signal to noise ratio. \nUsed for background correction.","ERCC RNA Spike-In Control Mixes defined by the External RNA Controls Consortium \n= pre-formulated sets of 92 polyadenylated transcripts from the ERCC plasmid reference library of  \nNIST-certified DNA plasmids that are designed to produce a set of transcripts 250–2000 nt in length that \nmimic natural eukaryotic mRNAs. \nThe transcripts are traceable through the manufacturing process to the NIST plasmid reference material.","Probesets against mRNA sequences which did not align (or poorly aligned) to the genome.")
  probetypes_summary$proben <- probe_annotation_core_summary$`n()`
  probetypes_summary$info <- info
  probetypes_summary$info <- linebreak(probetypes_summary$info,align = c("l"), double_escape = F, linebreaker = "\n")
  colnames(probetypes_summary) <- c("Probe type","Number of probesets","Number of probes","Probe type information")
  probetypes_summary$`Probe type` <- gsub("->","\\$\\\\rightarrow$",probetypes_summary$`Probe type`)
  probetypes_summary$`Probe type` <- gsub("_"," ",probetypes_summary$`Probe type`)

# Find featureset IDs corresponding to the controls and background probes
  probecontrols_core <- probe_annotation_core%>% subset(type!="main") # is same as for probetypes
  unique(probecontrols_core$type)

  probemains_core <- probe_annotation_core%>% subset(type=="main") # is same as for probetypes
  unique(probemains_core$type)

  probebg_core <-  probe_annotation_core%>% subset(type=="control->bgp->antigenomic")

# Summarize control probes by subtype in the affx positive control category
  probetypescontrols_summary <- probetypes %>% subset(type_id=="control->affx->bac_spike"|type_id=="control->affx->polya_spike") %>% group_by(type_id,subtype_id) %>% summarise(n())
  probetypescontrols_summary

  probecontrols_core_summary <- probecontrols_core %>% subset(type=="control->affx->bac_spike"|type=="control->affx->polya_spike") %>% group_by(type,subtype) %>% summarise(n())
  probecontrols_core_summary

  probetypescontrols_summary$proben <- probecontrols_core_summary$`n()`
  colnames(probetypescontrols_summary) <- c("Probe type","Probe subtype","Number of probesets","Number of probes")
  probetypescontrols_summary
  probetypescontrols_summary$`Probe type` <- gsub("->","\\$\\\\rightarrow$",probetypescontrols_summary$`Probe type`)
  probetypescontrols_summary$`Probe type` <- gsub("_"," ",probetypescontrols_summary$`Probe type`)
  probetypescontrols_summary$`Probe subtype` <- gsub("_"," ",probetypescontrols_summary$`Probe subtype`)

# Order affx_polyA substypes
  polyAlevel<- c("AFFX-DapX-3_st","AFFX-DapX-5_st","AFFX-DapX-M_st","AFFX-r2-Bs-dap-3_st","AFFX-r2-Bs-dap-5_st","AFFX-r2-Bs-dap-M_st","AFFX-ThrX-3_st","AFFX-ThrX-5_st","AFFX-ThrX-M_st","AFFX-r2-Bs-thr-3_s_st","AFFX-r2-Bs-thr-5_s_st","AFFX-r2-Bs-thr-M_s_st","AFFX-PheX-5_st","AFFX-PheX-3_st","AFFX-PheX-M_st","AFFX-r2-Bs-phe-3_st","AFFX-r2-Bs-phe-5_st","AFFX-r2-Bs-phe-M_st","AFFX-LysX-3_st","AFFX-LysX-5_st","AFFX-LysX-M_st","AFFX-r2-Bs-lys-3_st","AFFX-r2-Bs-lys-5_st","AFFX-r2-Bs-lys-M_st","AFFX-TrpnX-3_st","AFFX-TrpnX-5_st","AFFX-TrpnX-M_st")
@

<<Probe information at gene/transcript level,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
  gene_annotation <- distinct(probe_annotation_core %>% dplyr::select(-c(fid,x,y,uniqueid,sequence)))
  rownames(gene_annotation) <- gene_annotation$fsetid
  probeset_annotation <- distinct(probe_annotation_probeset %>% dplyr::select(-c(fid,x,y,uniqueid,sequence)))
  rownames(probeset_annotation) <- probeset_annotation$fsetid
@










\chapter{Data transformations}
Intensities are usually log2 transformed and data from the `perfect match' probes is extracted. Note that background probes are also contained within the `perfect match' data matrix. The use of MisMatch (MM) probes is highly controversial and discontinued in the newer microarray designs. As a consequence we did not detect a MM feature set in our data.

<<Perform data transformations,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
# Perfect probe matches of core level genes
  CELdata_pm_core <- oligo::pm(CELdata,target="core")
  dim(CELdata_pm_core)
  identical(CELdata_pm_core, CELdata_expr[pmindex_core,])

  CELdata_pm_probeset <- oligo::pm(CELdata,target="probeset")
  dim(CELdata_pm_probeset)
  identical(CELdata_pm_probeset, CELdata_expr[pmindex_probeset,])
  ## Add probenames as rownames of matrixes derived from the CELdata
  rownames(CELdata_pm_core) <- paste(probenames_core,probe_annotation_core$fid,sep="_")
  rownames(CELdata_pm_probeset) <- paste(probenames_probeset,probe_annotation_probeset$fid,sep="_")
  ## Merge probe information and probe counts
  CELdata_pm_core_annotated <- merge(CELdata_pm_core,probe_annotation_core,by="row.names",all=TRUE,sort=FALSE)[,-1]
  CELdata_pm_probeset_annotated <- merge(CELdata_pm_probeset,probe_annotation_probeset,by="row.names",all=TRUE,sort=FALSE)[,-1]

# Log2 transformation of the perfect match probes
  CELdata_pm_core_log2 <- log2(oligo::pm(CELdata,target="core"))
  CELdata_pm_probeset_log2 <- log2(oligo::pm(CELdata,target="probeset"))
  ## Add probenames as rownames of log2 transformed matrixes derived from the CELdata
  rownames(CELdata_pm_core_log2) <- paste(probenames_core,probe_annotation_core$fid,sep="_")
  rownames(CELdata_pm_probeset_log2) <- paste(probenames_probeset,probe_annotation_probeset$fid,sep="_")
  ## Merge probe information and probe counts
  CELdata_pm_core_log2_annotated <- merge(CELdata_pm_core_log2,probe_annotation_core,by="row.names",all=TRUE,sort=FALSE)[,-1]
  CELdata_pm_probeset_log2_annotated <- merge(CELdata_pm_probeset_log2,probe_annotation_probeset,by="row.names",all=TRUE,sort=FALSE)[,-1]

  CELdata_pm_core_log2_df <- data.frame(CELdata_pm_core_log2)

# Melt the dataframes
  CELdata_pm_core_log2_melt <- reshape2::melt(CELdata_pm_core_log2)
  CELdata_pm_core_log2_melt$Var2 <- factor(CELdata_pm_core_log2_melt$Var2,levels=samplevel)

  CELdata_pm_core_log2_annotated_melt <- reshape2::melt(CELdata_pm_core_log2_annotated,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  CELdata_pm_core_log2_annotated_melt$variable <- factor(CELdata_pm_core_log2_annotated_melt$variable,samplevel)

# Background probes
  CELdata_bg_core_log2 <- CELdata_pm_core_log2[rownames(CELdata_pm_core_log2)%in%probebg_core$uniqueid,]
  CELdata_bg_core_log2_melt <- CELdata_pm_core_log2_melt[CELdata_pm_core_log2_melt$Var1%in%probebg_core$uniqueid,]

# Select data corresponding to the affx_bac controls
  CELdata_control_affx_bac_log2 <- CELdata_pm_core_log2_annotated %>% subset(type=="control->affx->bac_spike")
  CELdata_control_affx_bac_log2_melt <- reshape2::melt(CELdata_control_affx_bac_log2,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  CELdata_control_affx_bac_log2_melt$variable <- factor(CELdata_control_affx_bac_log2_melt$variable,samplevel)

# Select data corresponding to the affx_polyA controls
  CELdata_control_affx_polyA_log2 <- CELdata_pm_core_log2_annotated %>% subset(type=="control->affx->polya_spike")
  CELdata_control_affx_polyA_log2_melt <- reshape2::melt(CELdata_control_affx_polyA_log2,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  CELdata_control_affx_polyA_log2_melt$variable <- factor(CELdata_control_affx_polyA_log2_melt$variable,samplevel)

# Select data corresponding to the endogenous positive controls
  CELdata_control_normgene_exon_log2 <- CELdata_pm_core_log2_annotated %>% subset(type=="normgene->exon")
  CELdata_control_normgene_exon_log2_melt <- reshape2::melt(CELdata_control_normgene_exon_log2,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  CELdata_control_normgene_exon_log2_melt$variable <- factor(CELdata_control_normgene_exon_log2_melt$variable,samplevel)

# Find featureset IDs corresponding to the housekeeping genes
  housekeeping_geneIDs <- getBM(attributes=c("affy_hugene_2_0_st_v1","ensembl_gene_id","entrezgene_id","external_gene_name"), filters="ensembl_gene_id",values=c("ENSG00000075624","ENSG00000111640","ENSG00000256269"), mart=ensembl)
  housekeeping_geneIDs
  housekeeping_geneIDs <- c(na.omit(housekeeping_geneIDs[,1]))
  housekeeping_geneIDs
  ## Select data corresponding to the housekeeping genes
  CELdata_housekeeping_log2 <- CELdata_pm_core_log2_annotated[which(CELdata_pm_core_log2_annotated$man_fsetid%in%housekeeping_geneIDs),]
  CELdata_housekeeping_log2_melt <- reshape2::melt(CELdata_housekeeping_log2,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  CELdata_housekeeping_log2_melt$variable <- factor(CELdata_housekeeping_log2_melt$variable,samplevel)
  CELdata_housekeeping_log2_melt$genename <- mapvalues(CELdata_housekeeping_log2_melt$man_fsetid,from=unique(as.character(CELdata_housekeeping_log2_melt$man_fsetid)),to=c("ACTB:ENSG00000075624","GAPHD:ENSG00000111640","HMBS:ENSG00000256269"))

# ROC control
  ROCcontrol <- CELdata_pm_core_log2_annotated
  ROCcontrol <- ROCcontrol %>% subset(posneg=="pos_control"|posneg=="neg_control")
  ROCcontrol_melt <- reshape2::melt(ROCcontrol,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  ROCcontrol_melt$variable <- factor(ROCcontrol_melt$variable,samplevel)

# Remove the Hela cell control sample
  CELdata_nocontrol <-  c("Blank1","Blank2","Blank3","SHIME1","SHIME2","SHIME3","SHIME_LGG1","SHIME_LGG2","SHIME_LGG3")
  CELdata_nocontrol <- CELdata[,CELdata_nocontrol]

  samplevel_nocontrol <- factor(samplevel[-10],levels=samplevel[-10])
  sampleplotname_nocontrol<- c("Blank1","Blank2","Blank3","SHIME1","SHIME2","SHIME3","SHIME \n LGG1","SHIME \n LGG2","SHIME \n LGG3")

  CELsampledata_nocontrol <- CELdata_nocontrol@phenoData
  CELsampledata_nocontrol
@

<<Perform data transformations in example data,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
# Perfect probe matches of core level genes
  EXCELdata_pm_core <- oligo::pm(EXCELdata,target="core")
  dim(EXCELdata_pm_core)

  EXCELdata_pm_probeset <- oligo::pm(EXCELdata,target="probeset")
  dim(EXCELdata_pm_probeset)
  ## Add probenames as rownames of matrixes derived from the example CELdata
  rownames(EXCELdata_pm_core) <- paste(probenames_core,probe_annotation_core$fid,sep="_")
  rownames(EXCELdata_pm_probeset) <- paste(probenames_probeset,probe_annotation_probeset$fid,sep="_")
  ## Merge probe information and probe counts
  EXCELdata_pm_core_annotated <- merge(EXCELdata_pm_core,probe_annotation_core,by="row.names",all=TRUE,sort=FALSE)[,-1]
  EXCELdata_pm_probeset_annotated <- merge(EXCELdata_pm_probeset,probe_annotation_probeset,by="row.names",all=TRUE,sort=FALSE)[,-1]

# Log2 transformation of the perfect match probes
  EXCELdata_pm_core_log2 <- log2(oligo::pm(EXCELdata,target="core"))
  EXCELdata_pm_probeset_log2 <- log2(oligo::pm(EXCELdata,target="probeset"))
  ## Add probenames as rownames of log2 transformed matrixes derived from the Eexample CELdata
  rownames(EXCELdata_pm_core_log2) <- paste(probenames_core,probe_annotation_core$fid,sep="_")
  rownames(EXCELdata_pm_probeset_log2) <- paste(probenames_probeset,probe_annotation_probeset$fid,sep="_")
  ## Merge probe information and probe counts
  EXCELdata_pm_core_log2_annotated <- merge(EXCELdata_pm_core_log2,probe_annotation_core,by="row.names",all=TRUE,sort=FALSE)[,-1]
  EXCELdata_pm_probeset_log2_annotated <- merge(EXCELdata_pm_probeset_log2,probe_annotation_probeset,by="row.names",all=TRUE,sort=FALSE)[,-1]

  EXCELdata_pm_core_log2_df <- data.frame(EXCELdata_pm_core_log2)

# Melt the dataframes
  EXCELdata_pm_core_log2_melt <- reshape2::melt(EXCELdata_pm_core_log2)
  EXCELdata_pm_core_log2_annotated_melt <- reshape2::melt(EXCELdata_pm_core_log2_annotated,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  EXCELdata_pm_core_log2_annotated_melt$variable <- factor(EXCELdata_pm_core_log2_annotated_melt$variable,exsamplevel)

# Background probes
  EXCELdata_bg_core_log2 <- EXCELdata_pm_core_log2[rownames(CELdata_pm_core_log2)%in%probebg_core$uniqueid,]
  EXCELdata_bg_core_log2_melt <- CELdata_pm_core_log2_melt[EXCELdata_pm_core_log2_melt$Var1%in%probebg_core$uniqueid,]

# Select data corresponding to the affx_bac controls
  EXCELdata_control_affx_bac_log2 <- EXCELdata_pm_core_log2_annotated %>% subset(type=="control->affx->bac_spike")
  EXCELdata_control_affx_bac_log2_melt <- reshape2::melt(EXCELdata_control_affx_bac_log2,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  EXCELdata_control_affx_bac_log2_melt$variable <- factor(EXCELdata_control_affx_bac_log2_melt$variable,exsamplevel)

# Select data corresponding to the affx_polyA controls
  EXCELdata_control_affx_polyA_log2 <- EXCELdata_pm_core_log2_annotated  %>% subset(type=="control->affx->polya_spike")
  EXCELdata_control_affx_polyA_log2_melt <- reshape2::melt(EXCELdata_control_affx_polyA_log2,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  EXCELdata_control_affx_polyA_log2_melt$variable <- factor(EXCELdata_control_affx_polyA_log2_melt$variable,exsamplevel)

# Select data corresponding to the endogenous positive controls
  EXCELdata_control_normgene_exon_log2 <- EXCELdata_pm_core_log2_annotated %>% subset(type=="normgene->exon")
  EXCELdata_control_normgene_exon_log2_melt <- reshape2::melt(EXCELdata_control_normgene_exon_log2,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  EXCELdata_control_normgene_exon_log2_melt$variable <- factor(EXCELdata_control_normgene_exon_log2_melt$variable,samplevel)

# Find featureset IDs corresponding to the housekeeping genes
  housekeeping_geneIDs <- getBM(attributes=c("affy_hugene_2_0_st_v1","ensembl_gene_id","entrezgene_id","external_gene_name"), filters="ensembl_gene_id",values=c("ENSG00000075624","ENSG00000111640","ENSG00000256269"), mart=ensembl)
  housekeeping_geneIDs
  housekeeping_geneIDs <- c(na.omit(housekeeping_geneIDs[,1]))
  housekeeping_geneIDs
  ## Select data corresponding to the housekeeping genes
  EXCELdata_housekeeping_log2 <- EXCELdata_pm_core_log2_annotated[which(EXCELdata_pm_core_log2_annotated$man_fsetid%in%housekeeping_geneIDs),]
  EXCELdata_housekeeping_log2_melt <- reshape2::melt(EXCELdata_housekeeping_log2,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  EXCELdata_housekeeping_log2_melt$variable <- factor(EXCELdata_housekeeping_log2_melt$variable,exsamplevel)
  EXCELdata_housekeeping_log2_melt$genename <- mapvalues(EXCELdata_housekeeping_log2_melt$man_fsetid,from=unique(as.character(EXCELdata_housekeeping_log2_melt$man_fsetid)),to=c("ACTB:ENSG00000075624","GAPHD:ENSG00000111640","HMBS:ENSG00000256269"))

# ROC control
  EXROCcontrol <- EXCELdata_pm_core_log2_annotated
  EXROCcontrol <- EXROCcontrol %>% subset(posneg=="pos_control"|posneg=="neg_control")
  EXROCcontrol_melt <- reshape2::melt(EXROCcontrol,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  EXROCcontrol_melt$variable <- factor(EXROCcontrol_melt$variable,exsamplevel)
@

<<Quality Control - bac and polyA standards,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.width=10,fig.height=8,fig.show='hide'>>=
stdcurvebac <- data.frame(conc = c(1.5,5,25,100), bac= c("BioB","BioC","BioD","Cre")) # pm
stdcurvebac <- data.frame(conc = c(1.5,1.5,25,5,5,100,25,1.5,100), bac= unique(CELdata_control_affx_bac_log2_melt %>% subset(grepl("^AFFX",subtype)) %>% dplyr::select(subtype)))

stdcurvepolyA <- data.frame(conc = c(1/100000,1/50000,1/25000,1/6667,0), polyA= c("Lys","Phe","Thr","Dap","Trpn")) # relative ratio
stdcurvepolyA <- data.frame(conc = c(rep(1/6667,6),rep(1/25000,6),rep(1/50000,6),rep(1/100000,6),rep(0,3)), subtype=polyAlevel)
@

<<RMA,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi>>=
  CELdata_RMA_core <- xfun::cache_rds({
  CELdata_RMA <- oligo::rma(CELdata_nocontrol,target="core",background = TRUE,normalize=TRUE)
  CELdata_RMA
  },file="RDS_RMA")

  class(CELdata_RMA_core)
  show(CELdata_RMA_core)
  CELdata_RMA_core_expr <- exprs(CELdata_RMA_core)

  CELdata_RMA_core_annotated <- merge(CELdata_RMA_core_expr,gene_annotation,by="row.names",all=TRUE,sort=FALSE)[,-1]
  CELdata_RMA_core_annotated_melt <- reshape2::melt(CELdata_RMA_core_annotated,id.vars=c("man_fsetid","fsetid","chrom","type","subtype","posneg"))
  CELdata_RMA_core_annotated_melt$bg <- "bg"
  CELdata_RMA_core_annotated_melt[CELdata_RMA_core_annotated_melt$type!="control->bgp->antigenomic",]$bg <- "nobg"
  CELdata_RMA_core_annotated_melt$bg <- factor(CELdata_RMA_core_annotated_melt$bg,levels=c("bg","nobg"))

# Background probes
  CELdata_RMA_bg_core <- CELdata_RMA_core[rownames(CELdata_RMA_core)%in%probebg_core$fsetid,]
  CELdata_RMA_bg_core_expr <- exprs(CELdata_RMA_bg_core)
  CELdata_RMA_core_annotated_melt_bg <- CELdata_RMA_core_annotated_melt[CELdata_RMA_core_annotated_melt$fsetid%in%probebg_core$fsetid,]
  CELdata_RMA_core_annotated_bg <- CELdata_RMA_core_annotated[CELdata_RMA_core_annotated$fsetid%in%probebg_core$fsetid,]

# Select data corresponding to the bac controls
  CELdata_RMA_core_annotated_affx_bac <- CELdata_RMA_core_annotated  %>% subset(type=="control->affx->bac_spike")
  CELdata_RMA_core_annotated_affx_bac_melt <- reshape2::melt(CELdata_RMA_core_annotated_affx_bac ,id.vars=c("man_fsetid","fsetid","chrom","type","subtype","posneg"))
  CELdata_RMA_core_annotated_affx_bac_melt$variable <- factor(CELdata_RMA_core_annotated_affx_bac_melt$variable,samplevel_nocontrol)
  CELdata_RMA_core_affx_bac <- CELdata_RMA_core_annotated_affx_bac  %>% dplyr::select(-c("man_fsetid","fsetid","chrom","type","subtype","posneg"))

# Select data corresponding to the affx_polyA controls
  CELdata_RMA_core_annotated_polyA <-  CELdata_RMA_core_annotated %>% subset(type=="control->affx->polya_spike")
  CELdata_RMA_core_annotated_polyA_melt <- reshape2::melt(CELdata_RMA_core_annotated_polyA,id.vars=c("man_fsetid","fsetid","chrom","type","subtype","posneg"))
  CELdata_RMA_core_annotated_polyA_melt$variable <- factor(CELdata_RMA_core_annotated_polyA_melt$variable,samplevel_nocontrol)
  CELdata_RMA_core_affx_polyA <- CELdata_RMA_core_annotated_polyA  %>% dplyr::select(-c("man_fsetid","fsetid","chrom","type","subtype","posneg"))

# Find featureset IDs corresponding to the housekeeping genes
  housekeeping_geneIDs <- getBM(attributes=c("affy_hugene_2_0_st_v1","ensembl_gene_id","entrezgene_id","external_gene_name"), filters="ensembl_gene_id",values=c("ENSG00000075624","ENSG00000111640","ENSG00000256269"), mart=ensembl)
  housekeeping_geneIDs
  housekeeping_geneIDs <- c(na.omit(housekeeping_geneIDs[,1]))
  housekeeping_geneIDs
  ## Select data corresponding to the housekeeping genes
  CELdata_RMA_housekeeping <- CELdata_RMA_core_annotated[which(CELdata_RMA_core_annotated$man_fsetid%in%housekeeping_geneIDs),]
  CELdata_RMA_housekeeping_melt <- reshape2::melt(CELdata_RMA_housekeeping,id.vars=c("man_fsetid","fsetid","chrom","type","subtype","posneg"))
  CELdata_RMA_housekeeping_melt$variable <- factor(CELdata_RMA_housekeeping_melt$variable,samplevel_nocontrol)
  CELdata_RMA_housekeeping_melt$genename <- mapvalues(CELdata_RMA_housekeeping_melt$man_fsetid,from=unique(as.character(CELdata_RMA_housekeeping_melt$man_fsetid)),to=c("ACTB:ENSG00000075624","GAPHD:ENSG00000111640","HMBS:ENSG00000256269"))
  CELdata_RMA_housekeeping_numeric <- CELdata_RMA_housekeeping  %>% dplyr::select(-c("man_fsetid","fsetid","chrom","type","subtype","posneg"))

# ROC control
  ROCcontrol_RMA <- CELdata_RMA_core_annotated
  ROCcontrol_RMA <- ROCcontrol_RMA %>% subset(posneg=="pos_control"|posneg=="neg_control")
  ROCcontrol_RMA_melt <- reshape2::melt(ROCcontrol_RMA,id.vars=c("man_fsetid","fsetid","chrom","type","subtype","posneg"))
  ROCcontrol_RMA_melt$variable <- factor(ROCcontrol_RMA_melt$variable,samplevel_nocontrol)
@

<<RMA annotate Eset,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
  ## add AffyGenePDInfo annotation
  CELdata_RMA_core_annotated_Eset_pd <- affycoretools::annotateEset(CELdata_RMA_core,pd.hugene.2.1.st)
  # oligo::getNetAffx(CELdata_RMA_core, type = "transcript")

  ## add transcript cluster annotation
  library("hugene20sttranscriptcluster.db")
  #head(ls("package:hugene20sttranscriptcluster.db"))
  #columns(hugene20sttranscriptcluster.db)

  CELdata_RMA_core_annotated_Eset_db <- affycoretools::annotateEset(CELdata_RMA_core,hugene20sttranscriptcluster.db,columns = c("PROBEID","ENSEMBL","ENTREZID","REFSEQ","PATH","SYMBOL","GENENAME"))
@

While no mismatch probes were present, the `perfect match' dataframe is still reduced (\Sexpr{nrow(CELdata_pm_core)}) compared to the original dataset (\Sexpr{nrow(CELdata_expr)}). This is due to the presence of low and high magnitude probes having no biological significance. These probes on the edge of the array are intended to provide a reference pattern of roughly alternating bright and very bright signals that enable the subsequent analysis of the scanned GeneChip to correctly allocate signals to probes.

The `perfect match' data can be annotated at probeset level (target = probeset) or at transcript/gene level (target=core) after summarization (discussed below). %and summarization of the data according to both annotations will be discussed below.

After summarization, the ChipDb package (`hugene20sttranscriptcluster.db') can be used to expand the annotation of the microarray features. The ChipDb package differs from the above described pdInfo package (`pd.hugene.2.0.st') in that it contains only annotations that could be mapped to NCBI Gene IDs, while the former contains the relatively unprocessed annotation data from Affymetrix.

<< PROBEID mapping after RMA,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
  # PROBEID mapping
  mapping_complete <- select(hugene20sttranscriptcluster.db,gene_annotation$man_fsetid, c("PROBEID","ENSEMBL","ENTREZID","REFSEQ","PATH","SYMBOL","GENENAME"))
  mapping_Entrez <- select(hugene20sttranscriptcluster.db,gene_annotation$man_fsetid,c("PROBEID","ENTREZID"))
@

%In other words, Affymetrix uses a whole bunch of input to decide what is and isn't a gene, and then bases their probes on the set of 'genes' that they think exist. But the ChipDb packages use NCBI Gene IDs as the central ID, so if Affymetrix identifies a gene based on some other annotation service, and it's not included in NCBI, then for the ChipDb package, that annotation is dropped because there isn't a Gene ID.










\chapter{Quality Control}
Sources of variability and anomalies within and between arrays will be identified by looking at the distribution of log2 probe intensities through diagnostic plots (array images, box plots, density plots, intensity-sequence relationships, ROC curves, MA plots, model fit residual/weight plots), probe metrics (RLE, NUSE, DABG) and Principal Component Analysis \cite{Lippa2010}. Many of the quality assessment measures are highly correlated and perform well in identifying gross outliers that should be excluded from downstream analyses. Negative and positive control probes are included in the microarray designs. They can be used in conjunction with positive spike-ins (called external/exogenous controls) and a separate microarray loaded with a Hela cell RNA control sample to trace problems to specific stages of the microarray experiment. Example datasets from Affymetrix are available as a reference and were used to benchmark the analysis pipeline.

\section{Mircoarray Pictures of log2 probe intensities}
Log2-scaled pseudo-images were used to assess the spatial distribution of the individual probe intensities on the chips (Package Oligo version \Sexpr{packageVersion("oligo")}). These microarray pictures can unravel large inconsistencies on individual arrays and between replicated arrays.

A quick glance at the microarray pictures reveals different intensities across replicates (Figure \ref{QC:fig1}). The blank3, SHIME2 and SHIME\_LGG1 replicate appear dimmer compared to the other arrays. Some markings (darker blue areas with less probe binding/expression) in the corners and one spot in the middle of all arrays stand out. Similar markings were present in the Hela cell control microarray, as well as the example microarray data provided by Affymetrix, indicating that these are biologically meaningful features (e.g. negative control probes) and not technical failures e.g. related to imaging. Finally, randomly distributed highly intense white patches are evident in some but not all of the blank (2,3) and SHIME\_LGG (2) samples. The biological meaning of these observations is questionable since the patches are not replicated which is suggestive of technical artifacts. Similar large, spatially contiguous clusters of highly intense signals or so-called blob-like defects (mostly oval shaped/round/arcs) have been described to occur in 10-20\% of Affymetrix ST microarrays and are likely caused by bubbles formed during array manufacturing \cite{Song2007,Moffitt2011,Upton2009}. Such blobs render the transcriptional information in the affected area useless and violate the distributional assumptions made by normalization methods (e.g. quantile normalization assumes that distributions of signals in all microarrays are similar). Moreover normalizing the data in this case will contaminate the signal in all of the arrays leading to subsequent spurious findings \cite{Song2007}. Rather than repeating assays, which is both costly and time-consuming, we implemented outlier detection prior to differential expression analysis. A couple of dedicated specialized tools have been developed to identify and remove blob-like artifacts (Harshlight, MBR, caCORRECT) \cite{Song2007,Moffitt2011}. While those tools were very important with old array designs where all probes contributing to a single gene expression value were arranged in contiguous regions, the newer chip layouts with randomly distributed probes do not require a blob-removal pre-processing step. The standard techniques such as RMA can adequately detect single outlier probes within a probeset through model-fitting approaches without information about spatial location. The performance of RMA with respect to artifact removal was evaluated below.

Note that even in the example data provided by Affymetrix, artifacts were apparent (although rare) and the intensities largely differed between replicate arrays (Figure \ref{exQC:fig1}-\ref{exQC:fig1b}).

<<Quality Control - Microarray Pictures,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
xfun::cache_rds({
  # Explore data and set colour scale for image + create color scale bar
  minint <- min(CELdata_pm_core_log2)
  maxint <- max(CELdata_pm_core_log2)
  col <- colorRampPalette(c('blue','white',"red"),interpolate="linear")
  colorlegend <- ggplotify::as.ggplot(ggcolor.bar(col(100),minint,maxint,"Log2 intensities",c(0,2.5,5,7.5,10,12.5),c(0,2.5,5,7.5,10,12.5))) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"QC/MicroarrayPictures/MicroarrayPictures_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend
  dev.off()

  colorlegend <- image_read(paste0(path,"QC/MicroarrayPictures/MicroarrayPictures_colorlegend.tiff"))
  colorlegend <- image_trim(colorlegend)
  colorlegend <- ggdraw() +  draw_image(colorlegend)

# Microarray Pictures
  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name = paste0(path,"QC/MicroarrayPictures/MicroarrayPicture",namei,".tiff")
  tiff(name,width=8*dpi,height=8*dpi,res=dpi,compression="lzw")
  oligo::image(CELdata[,i],main=rownames(CELsampledata@data)[i],transfo=log2, col = col(100))
  dev.off()
  ploti <- image_read(paste0(path,"QC/MicroarrayPictures/MicroarrayPicture",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("MicroarrayPicture",namei),ploti)
  }

  # pdf(paste0(path,"QC/MicroarrayPictures/MicroarrayPictures_all.pdf"))
  # par(mfrow = c(3,3))
  # for (i in 1:9){oligo::image(CELdata[,i],main=rownames(CELsampledata@data)[i],transfo=log2)}
  # dev.off()

  # Blank <- c(MicroarrayPictureBlank1,MicroarrayPictureBlank2,MicroarrayPictureBlank3)
  # Blank <- image_append(Blank)http://bw25c802.ugent.be:8787/graphics/1952d1f2-af52-488f-a4ff-f92cbf1c723a.png
  # Blank  <-  ggdraw() +  draw_image(Blank)

 Microarray_ALL <- plot_grid(MicroarrayPictureBlank1,MicroarrayPictureBlank2,MicroarrayPictureBlank3,MicroarrayPictureSHIME1,MicroarrayPictureSHIME2,MicroarrayPictureSHIME3,MicroarrayPictureSHIME_LGG1,MicroarrayPictureSHIME_LGG2,MicroarrayPictureSHIME_LGG3,MicroarrayPictureHelaControl,colorlegend,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.25,0.25,0.25,0.25))

 tiff(paste0(path,"QC/MicroarrayPictures/MicroarrayPictures_all.tiff"),width=6*dpi,height=8*dpi,res=dpi,compression="lzw")
 Microarray_ALL
 dev.off()

},file="RDS_MicroarrayPicturesCELdata")
@

<<Quality Control - Microarray Pictures plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{QC:fig1} Pseudo-images of the log2 scaled probe intensities. Intensities differ across replicates and artifacts are present on a few chips. Normalization and outlier detection will be applied to deal with these issues."),fig.pos="H",fig.scap=c("Pseudo-images of the log2 scaled probe intensities.")>>=
 Microarray_ALL <- image_read(paste0(path,"QC/MicroarrayPictures/MicroarrayPictures_all.tiff"))
 Microarray_ALL <- ggdraw() +  draw_image(Microarray_ALL)
 Microarray_ALL
@

<<Quality Control - Microarray Pictures of example dataset,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
xfun::cache_rds({
# Microarray Pictures
  for (i in 1:24){
  namei <- rownames(EXCELsampledata@data)[i]
  name = paste0(path,"exampleQC/MicroarrayPictures/MicroarrayPicture",namei,".tiff")
  tiff(name)
  oligo::image(EXCELdata[,i],main=rownames(EXCELsampledata@data)[i],transfo=log2, col = col(100))
  dev.off()
  assign(paste0("MicroarrayPicture",namei),image_read(paste0(path,"exampleQC/MicroarrayPictures/MicroarrayPicture",namei,".tiff")))
  }

# Tissue arrays
  ## Liver images
  Liver <- c(`MicroarrayPictureLiver1`,`MicroarrayPictureLiver2`,`MicroarrayPictureLiver3`,`MicroarrayPictureLiver4`)
  Liver <- image_append(Liver)
  Liver  <-  ggdraw() +  draw_image(Liver)

  ## Muscle images
  Muscle <- c(`MicroarrayPictureMuscle1`,`MicroarrayPictureMuscle2`,`MicroarrayPictureMuscle3`,`MicroarrayPictureMuscle4`)
  Muscle <- image_append(Muscle)
  Muscle  <-  ggdraw() +  draw_image(Muscle)

  ## Spleen images
  Spleen <- c(`MicroarrayPictureSpleen1`,`MicroarrayPictureSpleen2`,`MicroarrayPictureSpleen3`,`MicroarrayPictureSpleen4`)
  Spleen <- image_append(Spleen)
  Spleen  <-  ggdraw() +  draw_image(Spleen)

  ## Testes images
  Testes <- c(`MicroarrayPictureTestes1`,`MicroarrayPictureTestes2`,`MicroarrayPictureTestes3`,`MicroarrayPictureTestes4`)
  Testes <- image_append(Testes)
  Testes  <-  ggdraw() +  draw_image(Testes)

  # Tissue pictures
  Microarray_tissues <- ggdraw() +  draw_plot(Testes,0,0,1,0.25) + draw_plot(Spleen,0,0.25,1,0.25) + draw_plot(Muscle,0,0.5,1,0.25) + draw_plot(Liver,0,0.75,1,0.25)
  Microarray_tissues <- plot_grid(Microarray_tissues,colorlegend,rel_heights = c(0.95,0.05),nrow=2)

  tiff(paste0(path,"exampleQC/MicroarrayPictures/MicroarrayPictures_tissues.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_tissues
  dev.off()

# MAQC arrays: Microarray Quality Control
  ## MAQCA images
  MAQCA <- c(`MicroarrayPictureMAQCA1`,`MicroarrayPictureMAQCA2`,`MicroarrayPictureMAQCA3`,`MicroarrayPictureMAQCA4`)
  MAQCA <- image_append(MAQCA)
  MAQCA  <-  ggdraw() +  draw_image(MAQCA)

  ## MAQCA images
  MAQCB <- c(`MicroarrayPictureMAQCB1`,`MicroarrayPictureMAQCB2`,`MicroarrayPictureMAQCB3`,`MicroarrayPictureMAQCB4`)
  MAQCB <- image_append(MAQCB)
  MAQCB  <-  ggdraw() +  draw_image(MAQCB)

# MAQC pictures
  Microarray_MAQ <- ggdraw() +  draw_plot(MAQCB,0,0,1,0.5) + draw_plot(MAQCA,0,0.5,1,0.5)
  Microarray_MAQ <- plot_grid(Microarray_MAQ,colorlegend,rel_heights = c(0.95,0.05),nrow=2)

  tiff(paste0(path,"exampleQC/MicroarrayPictures/MicroarrayPictures_MAQ.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_MAQ
  dev.off()

},file="RDS_MicroarrayPicturesexampleCELdata")
@

<<Quality Control - Microarray Pictures of example dataset plot tissue,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{exQC:fig1} Pseudo-images of the log2 scaled probe intensities from Affymetrix tissue example data. Intensities differ across replicates and artifacts are observed on a few chips."),fig.pos="H",fig.scap=c("Pseudo-images of the log2 scaled probe intensities from Affymetrix tissue example data.")>>=
  Microarray_tissues <- image_read(paste0(path,"exampleQC/MicroarrayPictures/MicroarrayPictures_tissues.tiff"))
  Microarray_tissues <- ggdraw() +  draw_image(Microarray_tissues)
  Microarray_tissues
@

<<Quality Control - Microarray Pictures of example dataset plot MAQC,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="500pt",out.height="550pt",fig.cap=c("\\label{exQC:fig1b} Pseudo-images of the log2 scaled probe intensities from Affymetrix MAQC example data. Intensities differ across replicates and artifacts are observed on a few chips."),fig.pos="H",fig.scap=c("Pseudo-images of the log2 scaled probe intensities from Affymetrix MAQC example data.")>>=
  Microarray_MAQ <- image_read(paste0(path,"exampleQC/MicroarrayPictures/MicroarrayPictures_MAQ.tiff"))
  Microarray_MAQ <- ggdraw() +  draw_image(Microarray_MAQ)
  Microarray_MAQ
@

\clearpage

\section{Distribution of log2 probe intensities}
\subsection{Distribution of log2 `perfect match' probe intensities}
The distribution of log2 intensities for all `perfect match' probes annotated but not summarized at the transcript level (target = core) was compared between different arrays. While no outlier arrays are present, differences in shape and center of the distributions of the `perfect match' intensities were observed (Figure \ref{QC:fig2}). This can also be inferred from a box plot visualization, which displays differences in range and median intensities indicating that normalization of the data is required (Figure \ref{QC:fig3}, see \ref{normalization}). The lower intensities in the Blank3 and SHIME\_LGG1 control are in line with the dim appearance of those arrays (Figure \ref{QC:fig1},\ref{QC:fig3}). Additionally, the SHIME1 and Hela control probe log2 intensity distributions are at the lower end of the spectrum. This could point at lower cDNA concentrations loaded onto these microarrays, however total input RNA and the cDNA yield were quantified and standardized. Moreover, RNA degradation can be ruled out as RNA integrity and purity were verified based on the A260/280 ratio determined by UV Vis spectroscopy. Alternatively, a less efficient labeling, hybridization or more thorough washing could lead to variability in signal intensities. Control probes will be used to address these possibilities.

<<Quality Control - Histograms of log2 intensity,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="300pt",out.height="300pt",fig.cap=c("\\label{QC:fig2} Density plot of the log2 intensities of all `perfect match' probes."),fig.pos="H">>=
log2hist <- xfun::cache_rds({
  # Perfect matches
  ## Histogram of log2 intensities
  set.seed(123)
  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name = paste0(path,"QC/Distribution/histogram_pm",namei,".tiff")
  tiff(name)
  oligo::hist(CELdata[,i],which='pm',transfo=log2, nsample=10000,target="core",ylab='Density',xlab='Log2 probe intensity',main=rownames(CELsampledata@data)[i])
  dev.off()}

  log2hist <- ggplot(CELdata_pm_core_log2_melt,aes(value, color = Var2))
  log2hist <- papertheme(log2hist,sizeselect = 12) + geom_density(show.legend = FALSE) + guides(color=guide_legend(ncol=4,nrow=3)) + xlab("Log2 probe intensity") +ylab("Density") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(color = "") + scale_color_manual(values=samplecolors) + stat_density(geom="line",position="identity", size = 1)

  tiff(paste0(path,"QC/Distribution/histogram_pm.tiff"),width=6*dpitiff,height=6*dpitiff,res=dpitiff,compression="lzw")
  log2hist
  dev.off()

  log2hist

},file="RDS_histogram_pm")

 ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/histogram_pm.tiff")))
@

\vspace{\fill}

\begin{landscape}
<<Quality Control - Boxplots of log2 intensity,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{QC:fig3} Box plots of the log2 intensities of all `perfect match' probes."),fig.pos="H">>=
log2box <- xfun::cache_rds({
# Perfect matches
  ## Boxplot of log2 intensities
  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name = paste0(path,"QC/Distribution/boxplot_pm",namei,".tiff")
  tiff(name)
  oligo::boxplot(CELdata[,i], which="pm", transfo=log2, nsample=10000,target="core",ylab='Log2 probe intensity',main=rownames(CELsampledata@data)[i])
  dev.off()}

  log2box <- ggplot(CELdata_pm_core_log2_melt, aes(Var2,value,fill = Var2))
  log2box <- papertheme(log2box,sizeselect = 12) + geom_boxplot() + guides(fill=guide_legend(ncol=4,nrow=3)) + xlab("") +ylab("Log2 probe intensity") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=samplecolors) + theme(legend.position="none") + scale_x_discrete(labels=sampleplotname)

  tiff(paste0(path,"QC/Distribution/boxplot_pm.tiff"),width=8*dpitiff,height=4*dpitiff,res=dpitiff,compression="lzw")
  log2box
  dev.off()

  log2box

},file="RDS_boxplot_pm")

  ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/boxplot_pm.tiff")))
@
\end{landscape}

\clearpage

\subsection{Distribution of log2 background probe intensities}
Histograms and boxplots can be plotted for the background probes separately (Figure \ref{QC:fig2bg},\ref{QC:fig3bg}). The background level is rather similar across all chips, suggesting that there were no major experimental anomalies. In line with the overall probe intensities, SHIME1 and the Hela cell control display lower background intensities. Discrepancies in background intensity may be due to differences in cDNA concentrations/quality, labeling, hybridization or washing.
% Aberrantly high background levels for a particular array may indicate a problem with cRNA concentration, poor washing after hybridisation, or other experimental anomalies.

<<Quality Control - Histograms of log2 intensity background probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="300pt",out.height="300pt",fig.cap=c("\\label{QC:fig2bg} Density plot of the background probe log2 intensities"),fig.pos="H">>=
log2hist <- xfun::cache_rds({
  ## Histogram of log2 intensities
  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name = paste0(path,"QC/Distribution/histogram_bg",namei,".tiff")
  tiff(name)
  oligo::hist(CELdata[,i],transfo=log2,which='bg',target="core",ylab='Density',xlab='Log2 probe intensity',main=rownames(CELsampledata@data)[i])
  dev.off()}

  log2hist <- ggplot(CELdata_bg_core_log2_melt,aes(value, color = Var2))
  log2hist <- papertheme(log2hist,sizeselect = 12) + geom_density(show.legend = FALSE) + guides(color=guide_legend(ncol=4,nrow=3)) + xlab("Log2 probe intensity") +ylab("Density") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(color = "") + scale_color_manual(values=samplecolors) + stat_density(geom="line",position="identity", size = 1)

  tiff(paste0(path,"QC/Distribution/histogram_bg.tiff"),width=6*dpitiff,height=6*dpitiff,res=dpitiff,compression="lzw")
  log2hist
  dev.off()

  log2hist

},file="RDS_histogram_bg")

  ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/histogram_bg.tiff")))
@

\begin{landscape}
<<Quality Control - Boxplots of log2 intensity background probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{QC:fig3bg} Box plots of the background probe log2 intensities"),fig.pos="H">>=
log2box <- xfun::cache_rds({
  ## Boxplot of log2 intensities
  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name = paste0(path,"QC/Distribution/boxplot_bg",namei,".tiff")
  tiff(name)
  oligo::boxplot(CELdata[,i], which="bg", transfo=log2, nsample=10000,ylab='Log2 probe intensity',main=rownames(CELsampledata@data)[i],target="core")
  dev.off()}

  log2box <- ggplot(CELdata_bg_core_log2_melt, aes(Var2,value,fill = Var2))
  log2box <- papertheme(log2box,sizeselect = 12) + geom_boxplot() + guides(fill=guide_legend(ncol=4,nrow=3)) + xlab("") +ylab("Log2 probe intensity") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=samplecolors) + theme(legend.position="none") + scale_x_discrete(labels=sampleplotname)

  tiff(paste0(path,"QC/Distribution/boxplot_bg.tiff"),width=8*dpitiff,height=4*dpitiff,res=dpitiff,compression="lzw")
  log2box
  dev.off()

  log2box

},file="RDS_boxplot_bg")

  ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/boxplot_bg.tiff")))
@
\end{landscape}

\subsection{Distribution of log2 control probe intensities}
Background probes (control$\rightarrow$bgp$\rightarrow$antigenomic) are only one type of control probesets included in the Affymetrix Human Gene 2.1 ST Array Strip, which additionally contains external positive controls (control$\rightarrow$affx, control$\rightarrow$affx$\rightarrow$bac\_spike, control$\rightarrow$affx$\rightarrow$polya\_spike, control$\rightarrow$affx$\rightarrow$ercc), internal positive controls (normgene$\rightarrow$exon), negative controls (normgene$\rightarrow$intron) and Reporter+Rescue controls.

\begin{landscape}
<<Quality Control - probetype table,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
# Explore the probeset types
kable(probetypes_summary,booktabs = T,escape =F,linesep= "",caption = "\\label{QC:table1} Overview of control probesets on the Affymetrix Human Gene 2.1 ST Array Strip",row.names = FALSE,format="latex") %>% kable_styling(font_size = 8) %>%  row_spec(row = 0,bold = TRUE)
# ,format="html" in kable to see table preview in viewer pane
@
\end{landscape}

<<Quality Control - control probes table - pos control only,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
# Explore the positive control probes
kable(probetypescontrols_summary,booktabs = T,escape =F,linesep= "",caption = "\\label{QC:table2} Number of control probes and  probesets on the Affymetrix Human Gene 2.1 ST Array Strip",row.names = TRUE) %>% kable_styling(font_size = 8) %>%  row_spec(row = 0,bold = TRUE)
# ,format="html" in kable to see table preview in viewer pane
@

The probetypes available on the Affymetrix Human Gene 2.1 ST Array Strip, their purpose and the number of probesets of every type are shown in tables \ref{QC:table1} and \ref{QC:table2}.

An overview of the unnormalized raw log2 intensities indicates that the antigenomic background probes (listed in the .bgp file) that are not matching against the human genome tend to have similar median log2 intensities compared to the main and substantially lower median log2 intensities compared to the positive control probesets (Figure \ref{QC:fig4}-\ref{QC:fig6}).

Similarly, the signals resulting from probesets targeting putative intron regions of a set of putative housekeeping genes are in the same range as the main probe intensities. Intron regions act as a negative control and should have a very low signal \url{https://tools.thermofisher.com/content/sfs/brochures/exon_gene_arrays_qa_whitepaper.pdf}. However, some variation in this negative control may occur. While intronic regions in theory should be spliced out in the mRNA, some of these putative intronic regions may be transcribed and retained. Besides, some of the identified genes corresponding to those intronic regions may not be constitutively expressed (Figure \ref{QC:fig4}-\ref{QC:fig6}).

ERCC RNA Spike-In positive controls defined by the External RNA Controls Consortium were not added during the sample preparation, explaining the low intensity of ERCC probesets (Figure \ref{QC:fig4}-\ref{QC:fig6}). The ERCC RNA Spike-In Control Mixes are pre-formulated sets of 92 polyadenylated transcripts from the ERCC plasmid reference library of NIST-certified DNA plasmids that are designed to produce a set of transcripts (250–2000 nucleotides in length) that mimic natural eukaryotic mRNAs \cite{Lippa2010}. %Probe sets interrogating external RNA controls present in the Ambion® ERCC RNA Spike-In Control Mixes, P/N 4456740 and 445673. The ERCC seeks to employ external spike-in control measurements to assess technical performance with a standard set of controls in a consistent manner using metrics that can be compared across experiments, labs, platforms, and other factors as they arise. The ERCC is developing the standard controls, analysis tools, and protocols for using these controls and tools to enable consistent assessment and monitoring of technical performance \cite{Lippa2010}.

%Finally, the role and definition of rescue and reporter probesets is unclear.
Finally, reporter and rescue probesets targetting mRNA transcripts which either did not align to the genome, or aligned poorly, behave similar to the other negative controls (Figure \ref{QC:fig4}-\ref{QC:fig6}).

The fact that background/control probes can have a higher/similar median intensity compared to main `perfect match' probes is not problematic because `perfect match' probes behave differently from background probes. For example, there may be no real target for many of the main probes in the samples. Thus the median intensity of the `perfect match' probes may indeed be very low (at or near background). In contrast, the background intensity may be skewed towards higher values due to some GC rich probes present as a control for the high GC count probes (see \ref{QC_seqintrel}).
%The bgp probes are also labeled pm:st => also perfect matches

<<Quality Control - control probes vs main probes log2 intensity,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
# RUN first piece of code in R in byobu as it takes a long time!
  controlsplot_strips1 <- xfun::cache_rds({
# All data will be used
# Look at all probeset IDs
  controlsplot <- ggplot(CELdata_pm_core_log2_annotated_melt,aes(x=as.character(uniqueid),y=value)) + geom_line(aes(colour=variable,group=variable)) + labs(x="",y="Log2 intensity")  + facet_wrap(~type,drop=TRUE,scales = "free",nrow=9,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(color = "") + scale_color_manual(values=samplecolors)
  controlsplot <- papertheme(controlsplot)+theme(axis.text.x = element_text(angle = 90)) + guides(color=guide_legend(nrow=3,ncol=4)) + labs(color = "") + theme(axis.text.x = element_blank(),axis.ticks.x=element_blank())

  controlsplot_strips <-  ggplot_gtable(ggplot_build(controlsplot))
  stripr <- which(grepl('strip-t',controlsplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for (i in stripr){
  j <- which(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  controlsplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  controlsplot_strips1 <- controlsplot_strips

  tiff(paste0(path,"QC/Distribution/lineplot_controls.tiff"),width=10*dpitiff,height=14*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(controlsplot_strips)
  dev.off()
  
  png(paste0(path,"QC/Distribution/lineplot_controls.png"),width=10*dpi,height=14*dpi,res=dpi)
  grid.draw(controlsplot_strips)
  dev.off()

  controlsplot_strips1

},file="RDS_control_mainprobes1")


controlsplot_strips2 <- xfun::cache_rds({
# Box plots of the control probe log2 intensities per control type
  controlsplot <- ggplot(CELdata_pm_core_log2_annotated_melt,aes(x=variable,y=value)) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~type,scales = "free_y",nrow=9,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=samplecolors)
  controlsplot <- papertheme(controlsplot)+theme(axis.text.x = element_text(angle = 0),legend.position = "none") + guides(fill=guide_legend(nrow=3,ncol=4)) + scale_x_discrete(labels=sampleplotname)

  controlsplot_strips <-   ggplot_gtable(ggplot_build(controlsplot))
  stripr <- which(grepl('strip-t',controlsplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for (i in stripr){
  j <- which(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  controlsplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  controlsplot_strips2 <- controlsplot_strips

  tiff(paste0(path,"QC/Distribution/boxplots_controls_perprobetype.tiff"),width=12*dpitiff,height=16*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(controlsplot_strips)
  dev.off()
    
  png(paste0(path,"QC/Distribution/boxplots_controls_perprobetype.png"),width=12*dpi,height=16*dpi,res=dpi)
  grid.draw(controlsplot_strips)
  dev.off()

  controlsplot_strips2

},file="RDS_control_mainprobes2")


controlsplot_strips3 <- xfun::cache_rds({
# Box plots of the control probe log2 intensities per sample type
  controlsplot <- ggplot(CELdata_pm_core_log2_annotated_melt,aes(x=type,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=type,group=type)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free_y",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x))  + scale_fill_manual(values=probetypecolors)
  controlsplot <- papertheme(controlsplot)+theme(axis.text.x = element_text(angle = 90)) + guides(color=guide_legend(nrow=3,ncol=4))+ labs(color = "") + theme(legend.position = "none")

  controlsplot_strips <-   ggplot_gtable(ggplot_build(controlsplot))
  stripr <- which(grepl('strip-t',controlsplot_strips$layout$name))
  rev(samplecolors)
  fills <- c("#20b2aa","#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  controlsplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}
  controlsplot_strips3 <- controlsplot_strips

  tiff(paste0(path,"QC/Distribution/boxplots_controls_perarray.tiff"),width=12*dpitiff,height=12*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(controlsplot_strips)
  dev.off()
  
  png(paste0(path,"QC/Distribution/boxplots_controls_perarray.png"),width=12*dpi,height=12*dpi,res=dpi)
  grid.draw(controlsplot_strips)
  dev.off()

  controlsplot_strips3

},file="RDS_control_mainprobes3")
@

<<Quality Control - control probes vs main probes log2 intensity plot,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{QC:fig4} Raw log2 intensities of all probes within the probesets corresponding to the spike-in positive controls (control$\\rightarrow$affx, control$\\rightarrow$affx$\\rightarrow$bac\\_spike, control$\\rightarrow$affx$\\rightarrow$polya\\_spike) and negative controls (control$\\rightarrow$affx$\\rightarrow$ercc, control$\\rightarrow$bgp$\\rightarrow$antigenomic, normgene$\\rightarrow$intron).","\\label{QC:fig5} Box plots of the raw log2 intensities of all control probes within the probesets corresponding to the spike-in positive controls (control$\\rightarrow$affx, control$\\rightarrow$affx$\\rightarrow$bac\\_spike, control$\\rightarrow$affx$\\rightarrow$polya\\_spike) and negative controls (control$\\rightarrow$affx$\\rightarrow$ercc, control$\\rightarrow$bgp$\\rightarrow$antigenomic,normgene$\\rightarrow$intron) faceted by the controls.","\\label{QC:fig6} Box plots of the raw log2 intensities of all control probes within the probesets corresponding to the spike-in positive controls (control$\\rightarrow$affx, control$\\rightarrow$affx$\\rightarrow$bac\\_spike, control$\\rightarrow$affx$\\rightarrow$polya\\_spike) and negative controls (control$\\rightarrow$affx$\\rightarrow$ercc, control$\\rightarrow$bgp$\\rightarrow$antigenomic,  normgene$\\rightarrow$intron) faceted by the samples."),fig.scap=c("Raw log2 intensities of all probes within the probesets corresponding to the spike-in positive and negative controls.","Box plots of the raw log2 intensities of all control probes within the probesets corresponding to the spike-in positive and negative controls faceted by the controls.","Box plots of the raw log2 intensities of all control probes within the probesets corresponding to the spike-in positive and negative controls faceted by the samples."),fig.pos="H">>=
  #grid::grid.draw(controlsplot_strips1)
  #grid.newpage(recording = FALSE)
  # grid::grid.draw(controlsplot_strips2)
  # grid.newpage(recording = FALSE)
  # grid::grid.draw(controlsplot_strips3)
  # grid.newpage(recording = FALSE)
  knitr::include_graphics(paste0(path,"QC/Distribution/lineplot_controls.png"))
  knitr::include_graphics(paste0(path,"QC/Distribution/boxplots_controls_perprobetype.png"))
  knitr::include_graphics(paste0(path,"QC/Distribution/boxplots_controls_perarray.png"))
@

<<Quality Control - control probes vs main probes log2 intensity of the example dataset,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show='hide'>>=
# RUN first piece of code in R in byobu as it takes a long time!
  controlsplot_strips1 <- xfun::cache_rds({
# Box plots of the control probe log2 intensities per control type
  controlsplot <- ggplot(EXCELdata_pm_core_log2_annotated_melt,aes(x=variable,y=value)) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~type,scales = "free_y",nrow=9,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=exsamplecolors)
  controlsplot <- papertheme(controlsplot)+theme(axis.text.x = element_text(angle = 90),legend.position = "none") + guides(fill=guide_legend(nrow=3,ncol=4))

  controlsplot_strips <-   ggplot_gtable(ggplot_build(controlsplot))
  stripr <- which(grepl('strip-t',controlsplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  controlsplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}
  controlsplot_strips1 <- controlsplot_strips

  tiff(paste0(path,"exampleQC/Distribution/boxplots_controls_perprobetype.tiff"),width=12*dpitiff,height=14*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(controlsplot_strips)
  dev.off()
  
  png(paste0(path,"exampleQC/Distribution/boxplots_controls_perprobetype.png"),width=12*dpitiff,height=14*dpitiff,res=dpitiff)
  grid.draw(controlsplot_strips)
  dev.off()

  controlsplot_strips1

},file="RDS_control_mainprobes_exampledata1")


controlsplot_strips2 <- xfun::cache_rds({
# Box plots of the control probe log2 intensities per sample type
  controlsplot <- ggplot(EXCELdata_pm_core_log2_annotated_melt,aes(x=type,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=type,group=type)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free_y",nrow=6,ncol=4) + scale_y_continuous(labels=function(x) sprintf("%.2f", x))  + scale_fill_manual(values=probetypecolors)
  controlsplot <- papertheme(controlsplot) + guides(fill=guide_legend(nrow=6,ncol=4)) + theme(axis.text.x = element_text(angle = 90)) + labs(color = "") + theme(legend.position = "none")

  controlsplot_strips <-   ggplot_gtable(ggplot_build(controlsplot))
  stripr <- which(grepl('strip-t',controlsplot_strips$layout$name))
  fills <-  rev(exsamplecolors)
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  controlsplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}
  controlsplot_strips2 <- controlsplot_strips

  tiff(paste0(path,"exampleQC/Distribution/boxplots_controls_perarray.tiff"),width=16*dpitiff,height=16*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(controlsplot_strips)
  dev.off()
  
  png(paste0(path,"exampleQC/Distribution/boxplots_controls_perarray.png"),width=16*dpitiff,height=16*dpitiff,res=dpitiff)
  grid.draw(controlsplot_strips)
  dev.off()

  controlsplot_strips2

},file="RDS_control_mainprobes_exampledata2")
@

<<Quality Control - control probes vs main probes log2 intensity of the example dataset plot,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{exQC:fig6} Box plots of the raw log2 intensities of all control probes within the probesets corresponding to the spike-in positive controls (control$\\rightarrow$affx, control$\\rightarrow$affx$\\rightarrow$bac\\_spike, control$\\rightarrow$affx$\\rightarrow$polya\\_spike) and negative controls (control$\\rightarrow$affx$\\rightarrow$ercc, control$\\rightarrow$bgp$\\rightarrow$antigenomic, normgene$\\rightarrow$intron) faceted by the controls in the example data.","\\label{exQC:fig6b} Box plots of the raw log2 intensities of all control probes within the probesets corresponding to the spike-in positive controls (control$\\rightarrow$affx, control$\\rightarrow$affx$\\rightarrow$bac\\_spike, control$\\rightarrow$affx$\\rightarrow$polya\\_spike) and negative controls (control$\\rightarrow$affx$\\rightarrow$ercc, control$\\rightarrow$bgp$\\rightarrow$antigenomic, normgene$\\rightarrow$intron) faceted by the example samples."),fig.pos="H",fig.scap=c("Box plots of the raw log2 intensities of all control probes within the probesets corresponding to the spike-in positive and negative controls faceted by the controls in the example data.","Box plots of the raw log2 intensities of all control probes within the probesets corresponding to the spike-in positive and negative controls faceted by the example samples."),fig.pos="H">>=
  # grid::grid.draw(controlsplot_strips1)
  # grid.newpage(recording = FALSE)
  # grid::grid.draw(controlsplot_strips2)
  knitr::include_graphics(paste0(path,"exampleQC/Distribution/boxplots_controls_perarray.tiff"))
  knitr::include_graphics(paste0(path,"exampleQC/Distribution/boxplots_controls_perarray.png"))
@

\subsubsection{Distribution of log2 bac and polyA spike probe intensities}
Each eukaryotic GeneChip array also contains probesets for several \emph{E. coli} (BioB, BioC, BioD), bacteriophage P1(Cre) and modified \emph{B. subtilis} genes (trpn, lys, phe, thr, and dap) that are absent in eukaryotic samples. These bac\_spike (18 probesets) and polya\_spike (39 probesets) probesets act as external positive controls through the addition of complementary targets: the affymetrix bacterial and polyA spike-in controls.
%spike-in controls relies on the assumption that the controls act as meaningful proxies for the endogenous genes and that their behavior is representative of these genes of interest.
The pre-labeled bacterial/phage spike-in controls (BioB, BioC, BioD, and Cre) are added during the hybridization step in increasing concentrations of 1.5, 5, 25, and 100 pM respectively. They act as an internal hybridization control to confirm the low-end assay sensitivity and evaluate the dose-response across the dilution range. They can be used to identify potential problems with the hybridization, washing, scanning or the chip itself. Issues arising during the target preparation phase can be detected by means of the \emph{in vitro} synthesized polyadenylated RNA spikes (Lys, Phe, Thr, and Dap) that are added to the total RNA prior to the \emph{in vitro} first-Strand cDNA Synthesis step. The polyadenylated transcripts for the \emph{B. subtilis} genes are premixed at staggered concentrations (to obtain final copy number ratio of 1:100000,1:50000,1:25000,1:6667). Note that although Trpn probesets are present, the corresponding polyA transcript was not added and hence this acts as a negative control.

% and is designed specifically to provide exogenous positive controls to monitor the entire target preparation
%he internal probe calls AFFX-r2-Ec-bioB (M', 3' ,5'), bioC (5', 3') and bioD (5', 3') (morespikes and bio.calls slots) are E. coli genes that are used as internal hybridization controls and must always be present (P)4. Furthermore, the overall signal AFFX-r2-Ec-bioB (All), AFFX-r2-Ec-bioC (All) and AFFX-r2-Ec-bioD (All) for these spikes are present in increasing concentration (1.5 pM, 5 pM and 25 pM for bioB, bioC and bioD respectively).
% % Make a curve with ratio of known spike-in concentrations and correlate with measured intensities post normalization

The replicate arrays show high reproducibility for the bacterial spike-in controls indicating that the hybridization, fluidics methods as well as the chips and scanning and griding procedure were fine. This is confirmed by the bacterial spikes displaying the expected rank order (BioB$<$BioC$<$BioD$<$Cre) and an approximate linear relationship between the log2 intensities and bac spike concentrations (Figure \ref{QC:fig7},\ref{QC:fig8}).
A larger between-array variability was observed in the polyA spike. This is in line with the expectations since the hybridization controls are added in the last experimental stage, whereas the polyA spikes are subjected to additional sources of variation in the sample amplification and labeling steps \cite{Lippa2010}. Remarkably, the spike intensities peaked in the Hela cell control array, which exhibited smaller median `perfect match' and background probe intensities compared to the samples. This could be due to differences in the quality and ratio of total RNA vs polyA spikes. Interestingly, the blank3 and SHIME\_LGG1 sample generated lower polyA spike signals, which is in correspondence with the lower overall intensities, suggesting a lower efficiency during the target preparation (Figure \ref{QC:fig9}). Despite this variability, the polyA spikes display the expected rank order (trpn$<$lys$<$phe$<$thr$<$dap) indicating no major aberrancies during the preparation of the sample RNA and spikes (Figure \ref{QC:fig9},\ref{QC:fig10}). The poor fit of a linear regression model (min $r^{2}$ value of 0.15) suggests that background correction is required to improve the linear signal intensity-RNA concentration relationship. While our data behaves similar to the example data with respect to the bacterial spike-in controls, the example data contains abnormal high lys signals (Figures \ref{exQC:fig7}-\ref{exQC:fig10}). This might relate to changes in the experimental workflow since the acquisition of the example data. Indeed earlier resources report a different spike-in order (lys$>$phe$>$dap$>$thr) \cite{Lippa2010}. %is effectief het geval, verstoort ook de lineaire regressie

As can be observed from the large interquartile ranges (Figure \ref{QC:fig6}), metrics in these categories of exogenous positive controls have more variability than other categories due to the limited number of spikes and probesets. Thus they should only be used to troubleshoot specific problems whereas the Hela cell control and replicates of the other arrays were used to assess overall quality.

\vspace{\fill}

%The ploy-A controls AFFX-r2-Bs-Dap, AFFX-r2-Bs-Thr, AFFX-r2-Bs-Phe and AFFX-r2-Bs-Lys (morespikes slot) are modified B. subtilis genes and should be called present at a decreasing intensity, to verify that there was no bias during the retro-transcription between highly expressed genes and low expressed genes. Note that the linearity for lys, phe and thr (dap is present at a much higher concentration) is affected by a double amplification.

%AFFX-BioB-3_at and AFFX-r2-Ec-bioB-3_at. These two probe sets target the same gene, but the individual probes are slightly shifted. The r2 probe sets include less probes (11 for each control spike) than the older non-r2 sets (20 probes per set).

<<Quality Control - bac affx type control probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
affx_bacplot_strips1 <- xfun::cache_rds({
# Look at intensities of affx_bac per array
  affx_bacplot  <- ggplot(CELdata_control_affx_bac_log2_melt,aes(x=variable,y=value)) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~type,scales = "free_y",nrow=8,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=samplecolors) + scale_x_discrete(labels=sampleplotname)
  affx_bacplot  <- papertheme(affx_bacplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 0),legend.position = "none") + guides(fill=guide_legend(nrow=3,ncol=4))

  affx_bacplot_strips <-ggplot_gtable(ggplot_build(affx_bacplot ))
  stripr <- which(grepl('strip-t',affx_bacplot_strips$layout$name))
  fills <- "#00688b66"
  k <- 1
  for (i in stripr){
  j <- which(grepl('rect', affx_bacplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  affx_bacplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  affx_bacplot_strips1 <- affx_bacplot_strips

  tiff(paste0(path,"QC/Distribution/boxplot_affx_bacgenes_perarray.tiff"),width=8*dpitiff,height=4*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(affx_bacplot_strips)
  dev.off()
  
  png(paste0(path,"QC/Distribution/boxplot_affx_bacgenes_perarray.png"),width=8*dpitiff,height=4*dpitiff,res=dpitiff)
  grid.draw(affx_bacplot_strips)
  dev.off()

  affx_bacplot_strips1

},file="RDS_control_baxprobes1")


affx_bacplot_strips2 <- xfun::cache_rds({
# Look at intensities of affx_bac individual probes
  # affx_bacplot <- ggplot(CELdata_control_affx_bac_log2_melt %>% subset(grepl("^AFFX",subtype)),aes(x=as.character(sequence),y=as.numeric(as.character(value)))) + geom_line(aes(colour=subtype,group=subtype)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_color_manual(values=affx_bac_colors)
  # affx_bacplot <- papertheme(affx_bacplot)+theme(axis.text.x = element_text(angle = 90)) + guides(color=guide_legend(nrow=3,ncol=4))  + labs(color = "") + theme(axis.text.x = element_blank())
  # affx_bacplot
  CELdata_control_affx_bac_log2_melt_regression <- data.frame(CELdata_control_affx_bac_log2_melt %>% subset(grepl("^AFFX",subtype)))
  CELdata_control_affx_bac_log2_melt_regression$concentration <- as.numeric(mapvalues(CELdata_control_affx_bac_log2_melt_regression$subtype,from=stdcurvebac$subtype,to=stdcurvebac$conc))
  CELdata_control_affx_bac_log2_melt_regression$variable <- factor(CELdata_control_affx_bac_log2_melt_regression$variable,levels=samplevel)
  equations <- lm_eqn(CELdata_control_affx_bac_log2_melt_regression,"value","concentration","variable")
  equations$variable<- factor(equations$variable,levels=samplevel)
  #equations$x <- "AFFX-r2-Ec-bioD-3_at"
  equations$x <- 50
  equations$y <- 14

  # affx_bacplot <- ggplot(CELdata_control_affx_bac_log2_melt %>% subset(grepl("^AFFX",subtype)),aes(x=subtype,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=subtype,group=subtype)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=affx_bac_colors)
  # affx_bacplot <- papertheme(affx_bacplot,sizeselect = 8)+theme(axis.text.x = element_text(angle = 90)) + guides(fill=guide_legend(nrow=3,ncol=4))  + labs(fill = "") + theme(axis.text.x = element_blank())
  # affx_bacplot <- affx_bacplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b66",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b66",parse=T) + ylim(0,15)

  affx_bacplot <- ggplot(CELdata_control_affx_bac_log2_melt_regression,aes(x=concentration,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=subtype,color=subtype,group=subtype),outlier.size = 0.1,position = position_dodge(3)) + labs(x="Bac spike concentration (pM)",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=affx_bac_colors) + scale_color_manual(values=affx_bac_colors)
  affx_bacplot <- papertheme(affx_bacplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 90)) + guides(fill=guide_legend(nrow=3,ncol=4),color=guide_legend(nrow=3,ncol=4))  + labs(fill = "",color="") + theme(axis.text.x = element_blank())
  affx_bacplot <- affx_bacplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b66",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b66",parse=T) + ylim(0,15)

  affx_bacplot_strips <-   ggplot_gtable(ggplot_build(affx_bacplot))
  stripr <- which(grepl('strip-t',affx_bacplot_strips$layout$name))
  rev(samplecolors)
  fills <- c("#20b2aa","#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', affx_bacplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', affx_bacplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  affx_bacplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  }
  affx_bacplot_strips2 <- affx_bacplot_strips

  tiff(paste0(path,"QC/Distribution/boxplot_affx_bacgenes_persubtype.tiff"),width=11*dpitiff,height=13*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(affx_bacplot_strips)
  dev.off()
  
  png(paste0(path,"QC/Distribution/boxplot_affx_bacgenes_persubtype.png"),width=11*dpitiff,height=13*dpitiff,res=dpitiff)
  grid.draw(affx_bacplot_strips)
  dev.off()

  affx_bacplot_strips2
},file="RDS_control_baxprobes2")


  #grid.draw(affx_bacplot_strips1)
  #grid.newpage(recording="FALSE")
  #grid.draw(affx_bacplot_strips2)
@

\begin{landscape}
<<Quality Control - bac affx type control probes plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{QC:fig7} Raw log2 intensities of all probes within the probesets corresponding to the bacterial Affymetrix spike-in faceted by the samples. "),fig.pos="H">>=
  #grid.draw(affx_bacplot_strips1)
  #grid.newpage(recording="FALSE")
  ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/boxplot_affx_bacgenes_perarray.tiff")))
@
\end{landscape}

<<Quality Control - bac affx type control probes plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="550pt",out.height="650pt",fig.cap=c("\\label{QC:fig8} Raw log2 intensities of the BioB, BioC, BioD and Cre bacterial Affymetrix spike-in probes  faceted by the samples."),fig.pos="H">>=
  #grid.draw(affx_bacplot_strips2)
  ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/boxplot_affx_bacgenes_persubtype.tiff")))
@

<<Quality Control - polyA affx type control probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
affx_polyAplot_strips1 <- xfun::cache_rds({
# Look at intensities of affx_polyA per array
  affx_polyAplot  <- ggplot(CELdata_control_affx_polyA_log2_melt,aes(x=variable,y=value)) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~type,scales = "free_y",nrow=8,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=samplecolors) + scale_x_discrete(labels=sampleplotname)
  affx_polyAplot  <- papertheme(affx_polyAplot,sizeselect=12)+theme(axis.text.x = element_text(angle = 0),legend.position = "none") + guides(fill=guide_legend(nrow=3,ncol=4))

  affx_polyAplot_strips <-   ggplot_gtable(ggplot_build(affx_polyAplot))
  stripr <- which(grepl('strip-t',affx_polyAplot_strips$layout$name))
  fills <- "#00688b33"
  k <- 1
  for (i in stripr){
  j <- which(grepl('rect', affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  affx_polyAplot_strips1 <- affx_polyAplot_strips

  tiff(paste0(path,"QC/Distribution/boxplot_affx_polyAgenes_perarray.tiff"),width=8*dpitiff,height=4*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(affx_polyAplot_strips)
  dev.off()

  affx_polyAplot_strips1

},file="RDS_control_polyaprobes1")


affx_polyAplot_strips2 <- xfun::cache_rds({
# Look at intensities of affx_polyA individual probes
  # affx_polyAplot <- ggplot(CELdata_control_affx_polyA_log2_melt %>% subset(grepl("^AFFX",subtype)),aes(x=as.character(sequence),y=as.numeric(as.character(value)))) + geom_line(aes(colour=subtype,group=subtype)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_color_manual(values=affx_polyA_colors)
  # affx_polyAplot <- papertheme(affx_polyAplot)+theme(axis.text.x = element_text(angle = 90)) + guides(color=guide_legend(nrow=6,ncol=5))  + labs(color = "") + theme(axis.text.x = element_blank())
  # affx_polyAplot
  CELdata_control_affx_polyA_log2_melt_regression <- data.frame(CELdata_control_affx_polyA_log2_melt %>% subset(grepl("^AFFX",subtype)))
  CELdata_control_affx_polyA_log2_melt_regression$concentration <- as.numeric(mapvalues(CELdata_control_affx_polyA_log2_melt_regression$subtype,from=stdcurvepolyA$subtype,to=stdcurvepolyA$conc))
  CELdata_control_affx_polyA_log2_melt_regression$subtype <- factor( CELdata_control_affx_polyA_log2_melt_regression$subtype,levels=rev(polyAlevel))
  equations <- lm_eqn(CELdata_control_affx_polyA_log2_melt_regression,"value","subtype","variable")
  #equations$x <- "AFFX-PheX-3_st"
  equations$x <- 1/12500
  equations$y <- 14
  equations$variable <- factor(equations$variable,levels=samplevel)
#
#   CELdata_control_affx_polyA_log2_melt_AFFXonly <- CELdata_control_affx_polyA_log2_melt %>% subset(grepl("^AFFX",subtype))
#   CELdata_control_affx_polyA_log2_melt_AFFXonly$subtype <- factor(CELdata_control_affx_polyA_log2_melt_AFFXonly$subtype,levels=rev(polyAlevel))
#
#   affx_polyAplot <- ggplot(CELdata_control_affx_polyA_log2_melt_AFFXonly,aes(x=subtype,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=subtype,group=subtype)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=rev(affx_polyA_colors))
#   affx_polyAplot <- papertheme(affx_polyAplot,sizeselect=8)+theme(axis.text.x = element_text(angle = 90)) + guides(fill=guide_legend(nrow=6,ncol=5,reverse=TRUE)) + labs(fill = "") + theme(axis.text.x = element_blank())
#   affx_polyAplot <- affx_polyAplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b33",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b33",parse=T) + ylim(0,15)

  affx_polyAplot <- ggplot(CELdata_control_affx_polyA_log2_melt_regression,aes(x=concentration,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=subtype,color=subtype,group=subtype),outlier.size = 0.1,position=position_dodge(0.000012)) + labs(x="PolyA spike relative ratio",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=rev(affx_polyA_colors)) + scale_color_manual(values=rev(affx_polyA_colors))
  affx_polyAplot <- papertheme(affx_polyAplot,sizeselect=12)+theme(axis.text.x = element_text(angle = 90)) + guides(fill=guide_legend(nrow=6,ncol=5,reverse=TRUE),color=guide_legend(nrow=6,ncol=5,reverse=TRUE)) + labs(fill = "",color="") + theme(axis.text.x = element_blank())
  affx_polyAplot <- affx_polyAplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b66",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b66",parse=T) + ylim(0,15)

  affx_polyAplot_strips <-   ggplot_gtable(ggplot_build(affx_polyAplot))
  stripr <- which(grepl('strip-t',affx_polyAplot_strips$layout$name))
  rev(samplecolors)
  fills <- c("#20b2aa","#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}
  affx_polyAplot_strips2 <- affx_polyAplot_strips

  tiff(paste0(path,"QC/Distribution/boxplot_affx_polyAgenes_persubtype.tiff"),width=10*dpitiff,height=12*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(affx_polyAplot_strips)
  dev.off()

  affx_polyAplot_strips2

},file="RDS_control_polyaprobes")

  # grid.draw(affx_polyAplot_strips1)
  # grid.newpage(recording="FALSE")
  # grid.draw(affx_polyAplot_strips2)
  # ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/boxplot_affx_polyAgenes_perarray.tiff")))
  # ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/boxplot_affx_polyAgenes_persubtype.tiff")))
@

\begin{landscape}
<<Quality Control - polyA affx type control probes plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{QC:fig9} Raw log2 intensities of all probes within the probesets corresponding to the polyA Affymetrix spike-in faceted by the samples. "),fig.pos="H">>=
  ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/boxplot_affx_polyAgenes_perarray.tiff")))
@
\end{landscape}

<<Quality Control - polyA affx type control probes plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="550pt",out.height="650pt",fig.cap=c("\\label{QC:fig10} Raw log2 intensities of all probes within the probesets corresponding to the polyA Affymetrix spike-in faceted by the samples."),fig.pos="H">>=
  ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/boxplot_affx_polyAgenes_persubtype.tiff")))
@

<<Quality Control - bac affx type control probes of example dataset,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
affx_bacplot_strips1 <- xfun::cache_rds({
# Look at intensities of affx_bac per array
  affx_bacplot  <- ggplot(EXCELdata_control_affx_bac_log2_melt,aes(x=variable,y=value)) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~type,scales = "free_y",nrow=8,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "")
  affx_bacplot  <- papertheme(affx_bacplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 90),legend.position = "none") + guides(fill=guide_legend(nrow=3,ncol=4))  + scale_fill_manual(values=exsamplecolors)

  affx_bacplot_strips <-   ggplot_gtable(ggplot_build(affx_bacplot ))
  stripr <- which(grepl('strip-t',affx_bacplot_strips$layout$name))
  fills <- "#00688b66"
  k <- 1
  for (i in stripr){
  j <- which(grepl('rect', affx_bacplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  affx_bacplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  affx_bacplot_strips1 <- affx_bacplot_strips

  tiff(paste0(path,"exampleQC/Distribution/boxplot_affx_bacgenes_perarray.tiff"),width=8*dpitiff,height=4*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(affx_bacplot_strips)
  dev.off()

  affx_bacplot_strips1

},file="RDS_control_bacprobesexample1")


affx_bacplot_strips2<- xfun::cache_rds({
# Look at intensities of affx_bac individual probes
  EXCELdata_control_affx_bac_log2_melt_regression <- data.frame(EXCELdata_control_affx_bac_log2_melt %>% subset(grepl("^AFFX",subtype)))
  EXCELdata_control_affx_bac_log2_melt_regression$concentration <- as.numeric(mapvalues(EXCELdata_control_affx_bac_log2_melt_regression$subtype,from=stdcurvebac$subtype,to=stdcurvebac$conc))
  EXCELdata_control_affx_bac_log2_melt_regression$variable <- factor(EXCELdata_control_affx_bac_log2_melt_regression$variable,levels=exsamplevel)
  equations <- lm_eqn(EXCELdata_control_affx_bac_log2_melt_regression,"value","concentration","variable")
  equations$variable<- factor(equations$variable,levels=exsamplevel)
  #equations$x <- "AFFX-r2-Ec-bioD-3_at"
  equations$x <- 50
  equations$y <- 14


  # affx_bacplot <- ggplot(EXCELdata_control_affx_bac_log2_melt %>% subset(grepl("^AFFX",subtype)),aes(x=subtype,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=subtype,group=subtype)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=4) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=affx_bac_colors)
  # affx_bacplot <- papertheme(affx_bacplot,sizeselect = 8)+theme(axis.text.x = element_text(angle = 90)) + guides(fill=guide_legend(nrow=3,ncol=4))  + labs(fill = "") + theme(axis.text.x = element_blank())
  # affx_bacplot <- affx_bacplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b66",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b66",parse=T) + ylim(0,15)

   affx_bacplot <- ggplot(EXCELdata_control_affx_bac_log2_melt_regression,aes(x=concentration,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=subtype,color=subtype,group=subtype),outlier.size = 0.1,position = position_dodge(3)) + labs(x="Bac spike concentration (pM)",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=4) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=affx_bac_colors) + scale_color_manual(values=affx_bac_colors)
  affx_bacplot <- papertheme(affx_bacplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 90)) + guides(fill=guide_legend(nrow=3,ncol=4),color=guide_legend(nrow=3,ncol=4))  + labs(fill = "",color="") + theme(axis.text.x = element_blank())
  affx_bacplot <- affx_bacplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b66",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b66",parse=T) + ylim(0,15)

  affx_bacplot_strips <-   ggplot_gtable(ggplot_build(affx_bacplot))
  stripr <- which(grepl('strip-t',affx_bacplot_strips$layout$name))
  fills <-  rev(exsamplecolors)
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', affx_bacplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', affx_bacplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  affx_bacplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  }
  affx_bacplot_strips2 <- affx_bacplot_strips

  tiff(paste0(path,"exampleQC/Distribution/boxplot_affx_bacgenes_persubtype.tiff"),width=14*dpitiff,height=12*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(affx_bacplot_strips2)
  dev.off()

  affx_bacplot_strips2

},file="RDS_control_bacprobesexample2")

#   grid.draw(affx_bacplot_strips1)
#   grid.newpage(recording="FALSE")
#   grid.draw(affx_bacplot_strips2)
@

\begin{landscape}
<<Quality Control - bac affx type control probes of example dataset plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{exQC:fig7} Raw log2 intensities of all probes within the probesets corresponding to the bacterial Affymetrix spike-in faceted by the samples in the example data. "),fig.pos="H">>=
 ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/Distribution/boxplot_affx_bacgenes_perarray.tiff")))
@
\end{landscape}

<<Quality Control - bac affx type control probes of example dataset plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{exQC:fig8} Raw log2 intensities of the BioB, BioC, BioD and Cre bacterial Affymetrix spike-in probes  faceted by the samples in the example data."),fig.pos="H">>=
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/Distribution/boxplot_affx_bacgenes_persubtype.tiff")))
@

<<Quality Control - polyA affx type control probes of example dataset,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
affx_polyAplot_strips1 <- xfun::cache_rds({
# Look at intensities of affx_polyA per array
  affx_polyAplot  <- ggplot(EXCELdata_control_affx_polyA_log2_melt,aes(x=variable,y=value)) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~type,scales = "free_y",nrow=8,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "")
  affx_polyAplot  <- papertheme(affx_polyAplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 90),legend.position = "none") + guides(fill=guide_legend(nrow=3,ncol=4)) + scale_fill_manual(values=exsamplecolors)

  affx_polyAplot_strips <-   ggplot_gtable(ggplot_build(affx_polyAplot))
  stripr <- which(grepl('strip-t',affx_polyAplot_strips$layout$name))
  fills <- "#00688b33"
  k <- 1
  for (i in stripr){
  j <- which(grepl('rect', affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  affx_polyAplot_strips1 <- affx_polyAplot_strips

  tiff(paste0(path,"exampleQC/Distribution/boxplot_affx_polyAgenes_perarray.tiff"),width=8*dpitiff,height=4*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(affx_polyAplot_strips)
  dev.off()

  affx_polyAplot_strips1

},file="RDS_control_polyaprobe_exampledata1")


affx_polyAplot_strips2 <- xfun::cache_rds({
# Look at intensities of affx_polyA individual probes
  EXCELdata_control_affx_polyA_log2_melt_regression <- data.frame(EXCELdata_control_affx_polyA_log2_melt %>% subset(grepl("^AFFX",subtype)))
  EXCELdata_control_affx_polyA_log2_melt_regression$concentration <- as.numeric(mapvalues(EXCELdata_control_affx_polyA_log2_melt_regression$subtype,from=stdcurvepolyA$subtype,to=stdcurvepolyA$conc))
  EXCELdata_control_affx_polyA_log2_melt_regression$subtype <- factor( EXCELdata_control_affx_polyA_log2_melt_regression$subtype,levels=rev(polyAlevel))
  equations <- lm_eqn(EXCELdata_control_affx_polyA_log2_melt_regression,"value","subtype","variable")
  #equations$x <- "AFFX-PheX-3_st"
  equations$x <- 1/11900
  equations$y <- 14
  equations$variable <- factor(equations$variable,levels=exsamplevel)

  # affx_polyAplot <- ggplot(EXCELdata_control_affx_polyA_log2_melt_AFFXonly,aes(x=subtype,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=subtype,group=subtype)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=4) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=rev(affx_polyA_colors))
  # affx_polyAplot <- papertheme(affx_polyAplot,sizeselect = 8)+theme(axis.text.x = element_text(angle = 90)) + guides(fill=guide_legend(nrow=6,ncol=5,reverse=TRUE)) + labs(fill = "") + theme(axis.text.x = element_blank())
  # affx_polyAplot <- affx_polyAplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b33",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b33",parse=T) + ylim(0,15)

  affx_polyAplot <- ggplot(EXCELdata_control_affx_polyA_log2_melt_regression,aes(x=concentration,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=subtype,color=subtype,group=subtype),outlier.size = 0.1,position=position_dodge(0.000012)) + labs(x="PolyA spike relative ratio",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=4) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=rev(affx_polyA_colors)) + scale_color_manual(values=rev(affx_polyA_colors))
  affx_polyAplot <- papertheme(affx_polyAplot,sizeselect=12)+theme(axis.text.x = element_text(angle = 90)) + guides(fill=guide_legend(nrow=6,ncol=5,reverse=TRUE),color=guide_legend(nrow=6,ncol=5,reverse=TRUE)) + labs(fill = "",color="") + theme(axis.text.x = element_blank())
  affx_polyAplot <- affx_polyAplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b66",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b66",parse=T) + ylim(0,15)

  affx_polyAplot_strips <-   ggplot_gtable(ggplot_build(affx_polyAplot))
  stripr <- which(grepl('strip-t',affx_polyAplot_strips$layout$name))
  fills <-  rev(exsamplecolors)
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  }
  affx_polyAplot_strips2 <- affx_polyAplot_strips

  tiff(paste0(path,"exampleQC/Distribution/boxplot_affx_polyAgenes_persubtype.tiff"),width=14*dpitiff,height=12*dpitiff,res=dpitiff,compression="lzw")
   grid.draw(affx_polyAplot_strips2)
  dev.off()

  affx_polyAplot_strips2

},file="RDS_control_polyaprobe_exampledata2")

#   grid.draw(affx_polyAplot_strips1)
#   grid.newpage(recording="FALSE")
#   grid.draw(affx_polyAplot_strips2)
@

\begin{landscape}
<<Quality Control - polyA affx type control probes of example dataset plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{exQC:fig9} Raw log2 intensities of all probes within the probesets corresponding to the polyA Affymetrix spike-in faceted by the samples in the example data. "),fig.pos="H">>=
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/Distribution/boxplot_affx_polyAgenes_perarray.tiff")))
@
\end{landscape}

<<Quality Control - polyA affx type control probes of example dataset plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{exQC:fig10} Raw log2 intensities of all probes within the probesets corresponding to the polyA Affymetrix spike-in faceted by the samples in the example data."),fig.pos="H">>=
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/Distribution/boxplot_affx_polyAgenes_persubtype.tiff")))
@


\clearpage

To conclude, a between-array comparison of all probe types reveals a similar pattern for all microarrays in this study. Moreover, the example microarrays portray similar trends with respect to the controls and main probes, indicating that our data is of good quality (Figure \ref{exQC:fig6} and \ref{exQC:fig6b}). Moreover, the positive and negative controls also display similar signal patterns across all arrays, with exception of the polyA spikes, which follow the expected dose-response trajectory in our samples and not the example data (Figure \ref{QC:fig5}). This is likely due to recently implemented modifications to the experimental workflow.

\subsubsection{Distribution of log2 housekeeping probe intensities}
Besides the exogenous control probesets, it can be interesting to look at some housekeeping genes with expected constant expression levels. Some endogenous controls (exon regions of constitutively expressed genes) are included in the chip design. These 'normgene exons' behave similarly for all arrays and confirm the lower intensity values for the blank3,SHIME\_LGG1 and Hela cell control (Figure \ref{QC:fig6}). Additionally, the raw log2 intensities of probesets corresponding to some specific housekeeping genes (ACTB, GAPHD and HMBS) were explored. Median intensities slightly differed between arrays for all three genes and the blank3, SHIMELGG1 and Hela control array produced the smallest signals (in line with the overall trend). The variability in log2 intensities was similar for ACTB and GAPHD, but for HMBS the interquartile range was notably larger for the samples compared to the Hela cell control  (Figure \ref{QC:fig11}). Despite the differences in signal magnitudes, all arrays hybridizing with the triple coculture cell samples displayed very similar patterns of individual probe intensities for all three genes across the different conditions (blank, SHIME, SHIME + LGG). Deviations were most pronounced for HMBS and particularly the Hela cell control exhibited slightly deviating patterns. While the between array differences were negligible, large differences were noted between probes in the same probeset targeting one and the same gene, which is also reflected in the considerable interquartile ranges (Figure \ref{QC:fig12}). Large interquartile ranges and between-array differences were also observed in the example datasets (Figure \ref{exQC:fig11}-\ref{exQC:fig12}).

To conclude, the spike-in controls suggest that hybridization, scanning and target preparation were adequate. The fact that the sample arrays produce a similar (or even more intense) overall signal compared to the Hela cell positive control and example data demonstrates that the quality and nature of the original RNA samples was satisfactory. Differences in intensity between arrays and probes will be corrected through a normalization and summarization approach (see \ref{prepros}).

\vspace{\fill}

<<Quality Control - housekeeping gene probes log2 intensity,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
housekeepingplot_strips1 <- xfun::cache_rds({
# Look at a specific probeset ID (corresponding to a gene of interest): boxplot
  housekeepingplot <- ggplot(CELdata_housekeeping_log2_melt,aes(x=variable,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~genename,scales = "free_y",nrow=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=samplecolors) + scale_x_discrete(labels=sampleplotname)
  housekeepingplot <- papertheme(housekeepingplot,sizeselect=12)+theme(axis.text.x = element_text(angle = 0),legend.position = "none") + guides(fill=guide_legend(nrow=3,ncol=4))  + labs(fill = "")

  housekeepingplot_strips <-   ggplot_gtable(ggplot_build(housekeepingplot))
  stripr <- which(grepl('strip-t',housekeepingplot_strips$layout$name))
  rev(samplecolors)
  fills <- housekeepingcolors
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', housekeepingplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', housekeepingplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  housekeepingplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  }
  housekeepingplot_strips1 <- housekeepingplot_strips

  tiff(paste0(path,"QC/Distribution/boxplot_housekeepinggenesperarray.tiff"),width=8*dpitiff,height=10*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(housekeepingplot_strips)
  dev.off()

  housekeepingplot_strips1

},file="RDS_housekeeping1")

housekeepingplot_strips2 <- xfun::cache_rds({
# Look at a specific probeset ID (corresponding to a gene of interest): individual probe pattern
  housekeepingplot <- ggplot(CELdata_housekeeping_log2_melt,aes(x=as.character(sequence),y=as.numeric(as.character(value)))) + geom_line(aes(colour=variable,group=variable)) + labs(x="Probe Number",y="Log2 probe intensity")  + facet_wrap(~genename,drop=TRUE,scales = "free_y",nrow=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_color_manual(values=samplecolors)
  housekeepingplot <- papertheme(housekeepingplot,sizeselect = 12) + theme(axis.text.x = element_text(angle = 90)) + guides(color=guide_legend(nrow=3,ncol=4)) + coord_flip() + labs(color = "")

  housekeepingplot_strips <-   ggplot_gtable(ggplot_build(housekeepingplot))
  stripr <- which(grepl('strip-t',housekeepingplot_strips$layout$name))
  rev(samplecolors)
  fills <- housekeepingcolors
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', housekeepingplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', housekeepingplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  housekeepingplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
  }
  housekeepingplot_strips2 <- housekeepingplot_strips

  tiff(paste0(path,"QC/Distribution/boxplot_housekeepinggenesindivprobe.tiff"),width=10*dpitiff,height=14*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(housekeepingplot_strips)
  dev.off()

  housekeepingplot_strips2

},file="RDS_housekeeping2")
@

<<Quality Control - housekeeping gene probes log2 intensity plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{QC:fig11} Box plots of the raw log2 intensities of all probes within the probesets corresponding to the housekeeping genes ACTB, GAPHD and HMBS."),fig.pos="H">>=
  ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/boxplot_housekeepinggenesperarray.tiff")))
@

<<Quality Control - housekeeping gene probes log2 intensity plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{QC:fig12} Raw log2 intensities of all probes within the probesets corresponding to the housekeeping genes ACTB, GAPHD and HMBS."),fig.pos="H">>=
  #grid.draw(housekeepingplot_strips2)
  ggdraw() +  draw_image(image_read(paste0(path,"QC/Distribution/boxplot_housekeepinggenesindivprobe.tiff")))
@

<<Quality Control - housekeeping gene probes log2 intensity example data,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
housekeepingplot_strips1 <- xfun::cache_rds({
# Look at a specific probeset ID (corresponding to a gene of interest): boxplot
  housekeepingplot <- ggplot(EXCELdata_housekeeping_log2_melt,aes(x=variable,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~genename,scales = "free_y",nrow=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x))
  housekeepingplot <- papertheme(housekeepingplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 90),legend.position = "none") + guides(fill=guide_legend(nrow=4,ncol=6))  + labs(fill = "") + scale_fill_manual(values=exsamplecolors)

  housekeepingplot_strips <-   ggplot_gtable(ggplot_build(housekeepingplot))
  stripr <- which(grepl('strip-t',housekeepingplot_strips$layout$name))
  rev(samplecolors)
  fills <- housekeepingcolors
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', housekeepingplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', housekeepingplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  housekeepingplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}
  housekeepingplot_strips1 <- housekeepingplot_strips

  tiff(paste0(path,"exampleQC/Distribution/boxplot_housekeepinggenesperarray.tiff"),width=8*dpitiff,height=10*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(housekeepingplot_strips)
  dev.off()

  housekeepingplot_strips1

},file="RDS_housekeepingexample1")


housekeepingplot_strips2 <- xfun::cache_rds({
# Look at a specific probeset ID (corresponding to a gene of interest): individual probe pattern
  housekeepingplot <- ggplot(EXCELdata_housekeeping_log2_melt,aes(x=as.character(sequence),y=as.numeric(as.character(value)))) + geom_line(aes(colour=variable,group=variable)) + labs(x="Probe Number",y="Log2 probe intensity")  + facet_wrap(~genename,drop=TRUE,scales = "free_y",nrow=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x))
  housekeepingplot <- papertheme(housekeepingplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 90)) + guides(color=guide_legend(nrow=4,ncol=6)) + coord_flip() + labs(color = "") + scale_color_manual(values=exsamplecolors)

  housekeepingplot_strips <-   ggplot_gtable(ggplot_build(housekeepingplot))
  stripr <- which(grepl('strip-t',housekeepingplot_strips$layout$name))
  fills <- housekeepingcolors
  k <- 1
  for (i in stripr){
  if(length(grepl('rect', housekeepingplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', housekeepingplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  housekeepingplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}
  housekeepingplot_strips2 <-housekeepingplot_strips

  tiff(paste0(path,"exampleQC/Distribution/boxplot_housekeepinggenesindivprobe.tiff"),width=10*dpitiff,height=16*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(housekeepingplot_strips)
  dev.off()

  housekeepingplot_strips2

},file="RDS_housekeepingexample2")
@

<<Quality Control - housekeeping gene probes log2 intensity example data plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{exQC:fig11} Box plots of the raw log2 intensities of all probes within the probesets corresponding to the housekeeping genes ACTB, GAPHD and HMBS in the example data."),fig.pos="H">>=
  # grid.draw(housekeepingplot_strips1)
  # grid.newpage(recording="FALSE")
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/Distribution/boxplot_housekeepinggenesperarray.tiff")))
@

<<Quality Control - housekeeping gene probes log2 intensity example data plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{exQC:fig12} Raw log2 intensities of all probes within the probesets corresponding to the housekeeping genes ACTB, GAPHD and HMBS in the example data."),fig.pos="H">>=
  #grid.draw(housekeepingplot_strips2)
  ggdraw() +  cowplot::draw_image(image_read(paste0(path,"exampleQC/Distribution/boxplot_housekeepinggenesindivprobe.tiff")))
@

\section{Intensity-Sequence association \label{QC_seqintrel}}
The dependency of the intensity on the probe sequence is well established (Figure \ref{QC:fig13}). Estimated affinity splines coefficients can be used to estimate the base-position effects on the log2 intensities. A clear sequence effect on the log2 intensities is revealed. Gs and Cs are associated with positive splines coefficients and thus higher log2 intensities (Figure \ref{QC:fig13}). There is moreover a positional effect, with Gs at higher base positions showing larger effects. A boxplot stratified by GC content confirmed the strong dependency of log2-intensities on the number of G or C bases observed in the probe sequence (Figure \ref{QC:fig14}). Our results are in line with the findings that probes containing runs of guanine show abnormal binding affinities and are typically outliers with respect to the rest of the probeset to which they are assigned \cite{Upton2009}.

\vspace{\fill}

<<Quality Control - Intensity-Sequence relation,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{QC:fig13} Affinity splines coefficients indicating base position effects on the log2 intensities.","\\label{QC:fig14} Box plots of the log2 intensities in function of the probe GC content."),fig.pos="H">>=
Microarray_ALL1 <- xfun::cache_rds({
# Computes and plot nucleotide profile, describing the sequence effect on intensities.
  splinecoefs <-oligo::getAffinitySplineCoefficients(CELdata_pm_core_log2,oligo::pmSequence(CELdata))

  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name =  paste0(path,"QC/Intensity_SequenceRelation/Basepositioneffects",namei,".tiff")
  coeffi <- splinecoefs[,i]
  names(coeffi) <- rownames(splinecoefs)
  tiff(name)
  # oligo::getBaseProfile(coeffi,plot = TRUE,xlab="BasePosition")
  assign(paste0("baseposeffects",i),oligo::getBaseProfile(coeffi,probeLength = 25, plot = FALSE))
  assign(paste0("baseposeffects_melt",i),data.frame(reshape2::melt(oligo::getBaseProfile(coeffi,probeLength = 25, plot = FALSE))))
  plot(papertheme(ggplot(data=get(paste0("baseposeffects_melt",i)),aes(x=Var1,y=value,colour=Var2)) + geom_text(aes(label=Var2)),sizeselect=20)+theme(legend.position = "none")+xlab("Base Position")+ylab("Affinity Splines Coefficients")+ggtitle(rownames(CELsampledata@data)[i]) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)))
  dev.off()
  ploti <- image_read(paste0(path,"QC/Intensity_SequenceRelation/Basepositioneffects",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Basepositioneffects",namei),ploti)}

  Microarray_ALL1 <- plot_grid(BasepositioneffectsBlank1,BasepositioneffectsBlank2,BasepositioneffectsBlank3,BasepositioneffectsSHIME1,BasepositioneffectsSHIME2,BasepositioneffectsSHIME3,BasepositioneffectsSHIME_LGG1,BasepositioneffectsSHIME_LGG2,BasepositioneffectsSHIME_LGG3,BasepositioneffectsHelaControl,NULL,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.25,0.25,0.25,0.25))

  tiff(paste0(path,"QC/Intensity_SequenceRelation/Basepositioneffects_ALL.tiff"),width=6*dpitiff,height=6*dpitiff,res=dpitiff,compression="lzw")
  Microarray_ALL1
  dev.off()

  Microarray_ALL1
 },file="RDS_ISrelation1")

 Microarray_ALL2 <- xfun::cache_rds({
# Log2 intensities in function of the GC content
  GC_intdf <- data.frame(GCcontent=GCcontent_core,CELdata_pm_core_log2)

  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name =  paste0(path,"QC/Intensity_SequenceRelation/GCIntensity",namei,".tiff")
  tiff(name)
  GCint <- ggplot(data=GC_intdf) + geom_boxplot(aes(x=GCcontent,y=GC_intdf[,i+1]))+ylab('Log2 Intensity')+xlab('GC content')
  GCint <- papertheme(GCint,sizeselect = 8) +ggtitle(rownames(CELsampledata@data)[i])
  plot(GCint)
  dev.off()
  ploti <- image_read(paste0(path,"QC/Intensity_SequenceRelation/GCIntensity",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("GCIntensity",namei),ploti)
  }

  Microarray_ALL2 <- plot_grid(GCIntensityBlank1,GCIntensityBlank2,GCIntensityBlank3,GCIntensitySHIME1,GCIntensitySHIME2,GCIntensitySHIME3,GCIntensitySHIME_LGG1,GCIntensitySHIME_LGG2,GCIntensitySHIME_LGG3,GCIntensityHelaControl,NULL,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.25,0.25,0.25,0.25))

  tiff(paste0(path,"QC/Intensity_SequenceRelation/GCIntensity_ALL.tiff"),width=6*dpitiff,height=6*dpitiff,res=dpitiff,compression="lzw")
  Microarray_ALL2
  dev.off()

  Microarray_ALL2
},file="RDS_ISrelation2")


  # Microarray_ALL1
  # Microarray_ALL2
  ggdraw() +  draw_image(image_read(paste0(path,"QC/Intensity_SequenceRelation/Basepositioneffects_ALL.tiff")))
  ggdraw() +  draw_image(image_read(paste0(path,"QC/Intensity_SequenceRelation/GCIntensity_ALL.tiff")))
@


\section{ROC curves} %https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6347406/
As previously mentioned probesets targeting intron regions (normgene$\rightarrow$intron) are incorporated in the HuGene chip design and annotated as negative controls in the library files. While `normgene$\rightarrow$exon' was not registered as a type of probesets in our dataset, positive controls were included in the Affymetrix library files within the main category probeset types. These correspond to the `normgene$\rightarrow$exon' loci, an exonic region of normalization control genes (putative housekeeping genes) which are shown to have constitutive expression over a large number of samples. While in any given sample some (or many) of these putative exonic regions may not be transcribed or may be spliced out and some (or many) of the genes may not be constitutive within certain data sets, this collection of probesets in general has moderate to high signal values.

A comparison of signal values between the positive and negative controls reflects the quality of the whole experiment (RNA, target preparation, chip defects, hybridization, scanning) and is interesting given the high number of probes in the positive and negative control groups (in contrast with the spike-in and antigenomic background control probes).

Positive and negative controls are somewhat separated based on raw log2 intensities (Figure \ref{QC:fig15}). Hence the log2 unnormalized intensities have some diagnostic ability as binary classifier. This predictive value of log2 intensities for classification into positive vs negative controls is confirmed by Receiver Operator Curves (ROC) (Figure \ref{QC:fig16}).

%The genes for these probesets were identified and multiples of four probe probesets were selected against the putative exonic regions. (See the respective exon array design Technote for more information.) Thus in These probesets are used to estimate the true positive rate for the pos_vs_neg_auc metric.

ROC curves plot the true positive fraction (TPF, proportion of observations correctly predicted to be positive out of all positive observations) on the y-axis in function of the false positive fraction (FPF, proportion of observations wrongfully predicted to be positive out of all negative observations) on the x-axis at all classification thresholds. The true positive fraction is also called the sensitivity and $1 - false\: positive\: fraction$ is known as the specificity (= true negative fraction). The sensitivity and specificity can be used to assess the performance and strength of classification models at different classification thresholds. Those thresholds correspond to values of the log2 intensities and are not fixed in advance (range of observed intensities). It is implicitly assumed that the subpopulation of positive controls tends to have larger log2 intensities compared to the subpopulation of negative controls. Hence, a positive control is predicted by a log2 intensity exceeding or equaling some threshold, while a negative control probe is defined by a log2 intensity smaller than that threshold. The classification accuracy is evaluated considering the confusion matrix (Table \ref{QC:table3}). Based on the raw log2 intensity values, probabilities can be assigned that observations (probes) belong to the positive or negative control probesets \ref{ROC}. Assuming that the negative controls are a measure of false positives and the positive controls are a measure of true positives, ROC curves are constructed to evaluate how well the probe set signals separate the positive controls from the negative controls.

%Note that the AUC of the ROC curve is equivalent to a rank sum statistic used to test for differences in the center of two distributions. In the case of the exon and gene arrays the positive and negative controls are pseudo positives and negatives (see below). In practice the expected value for this metric is tissue type specific and may be sensitive to the quality of the RNA sample. %A consequence of the large sequence-related between-probe differences in signal intensity is that

<<Quality Control - ROC curve theory,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
# ROC curve dataframe
ROCexampledf <- data.frame(C1=c("",rep("Actual class",2)),C2=c("","Negative control","Positive control"),C3=c("Log2Intensity $<$ threshold","True Negative","False Negative"),C4=c("Log2Intensity $>$ threshold","False Positive","True Positive"))
ROCexampledf$C3 <- as.factor(ROCexampledf$C3)

ROCexampledf$C3 = cell_spec(ROCexampledf$C3, color = "white", align = "c", angle = 0, background = factor(ROCexampledf$C3, c("Log2Intensity $<$ threshold","True Negative","False Negative"), c("white","green", "red")),format="latex")
ROCexampledf$C4 = cell_spec(ROCexampledf$C4, color = "white", align = "c", angle = 0, background = factor(ROCexampledf$C4, c("Log2Intensity $>$ threshold","True Positive","False Positive"), c("white","green", "red")),format="latex")

ROCexampledf <- data.frame(C1=c("",rep("Actual class",2)),C2=c("","Negative control","Positive control"),C3=c("Log2Intensity $<$ threshold","True Negative","False Negative"),C4=c("Log2Intensity $>$ threshold","False Positive","True Positive"))
ROCexampledf$C3 <- as.factor(ROCexampledf$C3)

ROCexampledf$C3 = cell_spec(ROCexampledf$C3, color = "white", align = "c", angle = 0, background = factor(ROCexampledf$C3, c("Log2Intensity $<$ threshold","True Negative","False Negative"), c("white","tn", "fn")),format="latex")
ROCexampledf$C4 = cell_spec(ROCexampledf$C4, color = "white", align = "c", angle = 0, background = factor(ROCexampledf$C4, c("Log2Intensity $>$ threshold","True Positive","False Positive"), c("white","tp", "fp")),format="latex")

kable(ROCexampledf,escape = F,booktabs = T,linesep= "",caption = "\\label{QC:table3} The confusion matrix cross-classifies the predicted outcome Log2 intensity $\\geq$ threshold versus the true class of probes. This matrix is used to construct ROC curves by calculting sensitivity and specificity according to equation \\ref{ROC}.",caption.short="The confusion matrix cross-classifies the predicted outcome Log2 intensity $\\geq$ threshold versus the true class of probes.",col.names = NULL,format="latex")  %>% kable_paper() %>% kableExtra::collapse_rows(columns = 1, valign = "top")  %>% add_header_above(c(" "=2, "Predicted class" = 2), bold = T) %>% kable_styling(font_size = 8,latex_options = "HOLD_position") %>% column_spec(1, bold = T)
@

\begin{equation}\label{ROC}
\begin{split}
True\: positive\: rate & = \dfrac{True\: Positive}{True\: Positive + False\: Negative} \\
& = P(Log2\: intensity \geq threshold \mid Probe\: is\: a\: positive\: control) \\
\\
True\: negative\: rate & = \dfrac{False\: Positive}{True\: Negative + False\: Positive} \\
& = P(Log2\: intensity \geq threshold \mid Probe\: is\: a\: negative\: control)
\end{split}
\end{equation}

The ROC curves for the raw log2 intensities are not on the diagonal, implying some predictive value (Figure \ref{QC:fig16}). The diagonal in the ROC curve is a random classifier that does not have any ability to distinguish between the two classes i.e. the predicted probabilities of the two classes overlap and therefore, TPF = FPF at any threshold. A common way to summarize ROC curves in a single value is to calculate the area under the ROC curve (AUC). This presents an aggregate measure of performance of a model across all possible classification thresholds. While the AUC facilitates comparisons between arrays/classifiers, a curve with a lower AUC and lower predictive value across the range of thresholds could still yield a higher predictive value at a specific threshold value. The greater the AUC, the more informative the classifier. A model whose predictions are 100\% correct has an AUC of 1.0; one whose predictions are 100\% wrong has an AUC of 0.0. A random models has an AUC = 0.5. In our case, the areas under the curve for a predictive model with positive vs negative controls is around 0.8 for all microarrays with smaller values (0.78, 0.77 and 0.68 for SHIME\_LGG1, blank3 and the Hela control) (Figure \ref{QC:fig16}). Values for microarray data typically range between 0.80 and 0.90, which is in line with the observed values in our experiment and the example dataset (Figure \ref{exQC:fig16}).

\vspace{\fill}

%An AUC of 1 reflects perfect separation whereas as an AUC value of 0.5 would reflect no separation.

<<Quality Control - ROC curves,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{QC:fig15} Density plot of Log2 intensities for positive and negative controls.","\\label{QC:fig16} ROC curves."),fig.pos="H">>=
# perform ROC curves for all types of probes: https://cran.r-project.org/web/packages/plotROC/vignettes/examples.html
densplot <- xfun::cache_rds({
  densplot <- ggplot()+ geom_density(data=ROCcontrol_melt,aes(value,fill=posneg)) + facet_wrap(~variable,ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(name="",labels=c("Negative control","Positive control"),values=posnegcolors) + xlab("") + ylab("Density")
  densplot <- papertheme(densplot,sizeselect=12)

 densplot_strips <- ggplot_gtable(ggplot_build(densplot))
  stripr <- which(grepl('strip-t',densplot_strips$layout$name))
  fills <- c("#20b2aa","#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
  k <- 1
  for (i in stripr){
  if(length(grepl('rect',densplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect',densplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  densplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
}

  tiff(paste0(path,"QC/ROC_curves/densityplots_posvsnegcontrols.tiff"),width=6*dpitiff,height=8*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(densplot_strips)
  dev.off()

  densplot_strips

},file="RDS_rocdens")


rocplot <- xfun::cache_rds({
  rocplot <- ggplot() + geom_roc(data=ROCcontrol_melt, aes(m = value, d = posneg),n.cuts=50,labels=FALSE) + facet_wrap(~variable,ncol=3)
  rocplot_AUC <- round(calc_auc(rocplot)$AUC,2)
  rocplot_AUC <- data.frame(variable=factor(samplevel),AUC=rocplot_AUC,AUClabel=paste("AUC = ",rocplot_AUC,sep=" "))
  rocplot <- rocplot + geom_text(data=rocplot_AUC,aes(x=0.25,y=0.95,label = AUClabel))
  rocplot <- rocplot + style_roc() + geom_rocci(fill="pink")+ scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_x_continuous(labels=function(x) sprintf("%.2f", x))

  rocplot_strips <- ggplot_gtable(ggplot_build(rocplot))
  stripr <- which(grepl('strip-t',rocplot_strips$layout$name))
  fills <- c("#20b2aa","#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
  k <- 1
  for (i in stripr){
  if(length(grepl('rect',rocplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect',rocplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  rocplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}
}

  tiff(paste0(path,"QC/ROC_curves/ROCplots.tiff"),width=6*dpitiff,height=8*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(rocplot_strips)
  dev.off()

  rocplot_strips

},file="RDS_roc")

ggdraw() +  draw_image(image_read(paste0(path,"QC/ROC_curves/densityplots_posvsnegcontrols.tiff")))
ggdraw() +  draw_image(image_read(paste0(path,"QC/ROC_curves/ROCplots.tiff")))
# grid.draw(densplot)
# grid.newpage(recording=FALSE)
# grid.draw(rocplot)
@

<<Quality Control - ROC curves example data,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{exQC:fig15} Density plot of Log2 intensities for positive and negative controls in the example data.","\\label{exQC:fig16} ROC curves from the example data."),fig.pos="H">>=
# perform ROC curves for all types of probes:https://cran.r-project.org/web/packages/plotROC/vignettes/examples.html
densplot <- xfun::cache_rds({
  densplot <- ggplot()+ geom_density(data=EXROCcontrol_melt,aes(value,fill=posneg)) + facet_wrap(~variable,ncol=4) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(name="",labels=c("Negative control","Positive control"),values=posnegcolors) + xlab("") + ylab("Density")
  densplot <- papertheme(densplot,sizeselect=12)

  densplot_strips <- ggplot_gtable(ggplot_build(densplot))
  stripr <- which(grepl('strip-t',densplot_strips$layout$name))
  fills <- rev(exsamplecolors)
  k <- 1
  for (i in stripr){
  if(length(grepl('rect',densplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect',densplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  densplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}

  tiff(paste0(path,"exampleQC/ROC_curves/densityplots_posvsnegcontrols.tiff"),width=9*dpitiff,height=11*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(densplot_strips)
  dev.off()

  densplot_strips

},file="RDS_rocdensexample")

rocplot <- xfun::cache_rds({
  rocplot <- ggplot() + geom_roc(data=EXROCcontrol_melt, aes(m = value, d = posneg),n.cuts=50,labels=FALSE) +   facet_wrap(~variable,nrow=6,ncol=4)
  rocplot_AUC <- round(calc_auc(rocplot)$AUC,2)
  rocplot_AUC <- data.frame(variable=factor(levels(EXROCcontrol_melt$variable)),AUC=rocplot_AUC,AUClabel=paste("AUC= ",rocplot_AUC,sep=" "))
  rocplot <- rocplot + geom_text(data=rocplot_AUC,aes(x=0.25,y=0.95,label = AUClabel))
  rocplot <- rocplot + style_roc() + geom_rocci(fill="pink")+ scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_x_continuous(labels=function(x) sprintf("%.2f", x))

  rocplot_strips <- ggplot_gtable(ggplot_build(rocplot))
  stripr <- which(grepl('strip-t',rocplot_strips$layout$name))
  fills <- rev(exsamplecolors)
  k <- 1
  for (i in stripr){
  if(length(grepl('rect',rocplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect',rocplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  rocplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}

  tiff(paste0(path,"exampleQC/ROC_curves/ROCplots.tiff"),width=8*dpitiff,height=10*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(rocplot_strips)
  dev.off()

  rocplot_strips

},file="RDS_rocexample")

# densplot
# grid.newpage(recording=FALSE)
# grid.draw(rocplot)

ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/ROC_curves/densityplots_posvsnegcontrols.tiff")))
ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/ROC_curves/ROCplots.tiff")))
@


\section{MA plots}
% people started using them to compare each Affymetrix array to a pseudo-array. The pseudo array consists of the median intensity of each probe over all arrays.
MA plots were constructed to determine the variability in expression across different expression levels. The MA plot shows to what extent the variability in expression depends on the expression level (e.g. if there is more variation on high expression values). In an MA-plot, A (the average of the intensity of a probe on that array and the median intensity of that probe over all arrays) is plotted versus M (the difference between the intensity of a probe on that array and the median intensity of that probe over all arrays) \ref{MAeq}.

\begin{align}\label{MAeq}
A&= \dfrac{\log_{2}(PMInt\_array) + \log_{2}(PMInt\_medianarray)}{2}\\
M&= \log_{2}(PMInt\_array) – \log_{2}(PMInt\_medianarray)
\end{align}

Ideally, the cloud of data points should be centered around M=0 (blue line) since we assume that the majority of the genes is not differentially expressed and that the number of up-regulated genes is similar to the number of down-regulated genes. Additionally, the variability of the M values should be similar for different A values. We observe that the spread of the cloud increases with the average intensity: the loess curve (red line) moves further and further away from M=0 with increasing A \ref{QC:fig17}, which is in line with the example data (Figures \ref{exQC:fig17} and \ref{exQC:fig17b}). To remove (some of) this dependency, we will normalize the data (see \ref{normalization}).

\vspace{\fill}

<<Quality Control - MA plots,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
Microarray_ALL <- xfun::cache_rds({
  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name =  paste0(path,"QC/MAplots/MAplot",namei,".tiff")
  tiff(name)
  oligo::MAplot(CELdata,which=i, transfo=log2) # ,plotFun=plot to obtain usual plot without smoothscatter
  dev.off()
  ploti <- image_read(paste0(path,"QC/MAplots/MAplot",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("MAplot",namei),ploti)
  }

  Microarray_ALL <- plot_grid(MAplotBlank1,MAplotBlank2,MAplotBlank3,MAplotSHIME1,MAplotSHIME2,MAplotSHIME3,MAplotSHIME_LGG1,MAplotSHIME_LGG2,MAplotSHIME_LGG3,MAplotHelaControl,nrow=3,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.33,0.33,0.33))

  tiff(paste0(path,"QC/MAplots/MAplot_ALL.tiff"),width=8*dpitiff,height=8*dpitiff,res=dpitiff,compression="lzw")
  Microarray_ALL
  dev.off()

  Microarray_ALL

},file="RDS_MAplot")
@

<<Quality Control - MA plots plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap="\\label{QC:fig17} MA plots.",fig.pos="H">>=
  #Microarray_ALL
  ggdraw() +  draw_image(image_read(paste0(path,"QC/MAplots/MAplot_ALL.tiff")))
@

<<Quality Control - MA plots of example data,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
Microarray_tissue <- xfun::cache_rds({
  for (i in 1:24){
  namei <- rownames(EXCELsampledata@data)[i]
  name =  paste0(path,"exampleQC/MAplots/MAplot",namei,".tiff")
  tiff(name)
  oligo::MAplot(EXCELdata,which=i) # ,plotFun=plot to obtain usual plot without smoothscatter
  dev.off()
  ploti <- image_read(paste0(path,"exampleQC/MAplots/MAplot",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("MAplot",namei),ploti)
  }

  Microarray_tissue <- plot_grid(`MAplotLiver1`,`MAplotLiver2`,`MAplotLiver3`,`MAplotLiver4`,`MAplotMuscle1`,`MAplotMuscle2`,`MAplotMuscle3`,`MAplotMuscle4`,`MAplotSpleen1`,`MAplotSpleen2`,`MAplotSpleen3`,`MAplotSpleen4`,`MAplotTestes1`,`MAplotTestes2`,`MAplotTestes3`,`MAplotTestes4`,nrow=4,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.25,0.25,0.25,0.25))

  tiff(paste0(path,"exampleQC/MAplots/MAplot_tissues.tiff"),width=10*dpitiff,height=10*dpitiff,res=dpitiff,compression="lzw")
  Microarray_tissue
  dev.off()
  Microarray_tissue
},file="RDS_MAplotexampletissue")

  Microarray_MAQC <-  xfun::cache_rds({
  Microarray_MAQC <- plot_grid(`MAplotMAQCA1`,`MAplotMAQCA2`,`MAplotMAQCA3`,`MAplotMAQCA4`,`MAplotMAQCB1`,`MAplotMAQCB2`,`MAplotMAQCB3`,`MAplotMAQCB4`,nrow=2,ncol=4,rel_widths = c(0.5,0.5),rel_heights=c(0.25,0.25,0.25,0.25))

  tiff(paste0(path,"exampleQC/MAplots/MAplot_MAQC.tiff"),width=10*dpitiff,height=5*dpitiff,res=dpitiff,compression="lzw")
  Microarray_MAQC
  dev.off()

  Microarray_MAQC

},file="RDS_MAplotexampleMAQC")
@

<<Quality Control - MA plots of example data plot tissue,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap="\\label{exQC:fig17} MA plots of the tissue example data.",fig.pos="H">>=
  #Microarray_tissue
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/MAplots/MAplot_tissues.tiff")))
@

<<Quality Control - MA plots of example data plot MAQ,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="600pt",fig.cap="\\label{exQC:fig17b} MA plots of the MAQC example data.",fig.pos="H">>=
  #Microarray_MAQC
    ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/MAplots/MAplot_MAQC.tiff")))
@

\vspace{\fill}
\clearpage


\section{Presence/Absence calls - at probe and summarized probeset level}
The less clear separation between positive and negative controls for the blank3,SHIME\_LGG1 and Hela cell control as observed in ROC curve analysis is in agreement with findings from a presence/absence analysis.
Presence/absence calls can be made by applying statistical hypothesis testing to assess whether or not each of the PM intensities are compatible with observations generated by background probes \ref{PAcalls}.

\begin{align}\label{PAcalls}
H_0:&PM\: intensity = BG\: intensity \\
H_1:&PM\: intensity > BG\: intensity
\end{align}

The p-value of this hypothesis test expresses the chance of observing a "present looking" probeset when the complementary RNA is in fact absent. Small p-values imply presence while large ones imply absence of transcripts from a gene/depending on whether the analysis is conducted at probeset (PSDABG) or individual probe level (DABG). Probeset level analysis implies summarization (see \ref{summarization}).

\vspace{\fill}

<<Quality Control - PA calls: DABG,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
pacall_DABG <- xfun::cache_rds({
  pacall_DABG <- paCalls(CELdata,method="DABG")
},file="RDS_PAcall_DABG")

  dim(pacall_DABG)
  length(match(rownames(pacall_DABG),probe_annotation_probeset$fid))
  rownames(pacall_DABG) <- probe_annotation_probeset$uniqueid
  pacall_DABG  <- merge(pacall_DABG,probe_annotation_probeset,by="row.names",all=TRUE,sort=FALSE)[,-1]
  #pacall_DABG_percpresent <- apply(pacall_DABG,2,function(x) {(sum(x<0.05)/length(x))*100})
  #pacall_DABG <- rbind(pacall_DABG,pacall_DABG_percpresent)
  pacall_DABG_melt <- reshape2::melt(pacall_DABG,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  pacall_DABG_melt$variable <- factor(pacall_DABG_melt$variable,levels=samplevel)
  pacall_DABG_percpresent_grouped <- na.omit(pacall_DABG_melt %>% group_by(type,variable) %>% summarise(percentage=(sum(value<0.05)/n())*100))

DABGboxplot  <- xfun::cache_rds({
  # Probe level
  DABGboxplot <- ggplot() + geom_boxplot(data=pacall_DABG_melt,aes(x=variable,y=value,fill=variable))
  DABGboxplot <- papertheme(DABGboxplot,sizeselect = 12) + theme(legend.position = "none",axis.text.x = element_text(angle=90)) + xlab("") + ylab("DABG p-value") + geom_hline(data=data.frame(int=0.05),aes(yintercept=int),color="red",linetype="dashed") + facet_wrap(type~.,scales="free_y",nrow=9,ncol=1) + scale_fill_manual(values=samplecolors) + scale_y_continuous(labels=function(x) sprintf("%.2f", x))
  DABGboxplot <- DABGboxplot + geom_text(data=pacall_DABG_percpresent_grouped,aes(x=variable,y=1.15,label=paste(sprintf("%.1f",percentage),"%",sep="")),size=3.5) + ylim(c(0,1.25))

  DABGboxplot_strips <-  ggplot_gtable(ggplot_build(DABGboxplot))
  stripr <- which(grepl('strip-t',DABGboxplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for(i in stripr){
  if(length(grepl('rect',DABGboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', DABGboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  DABGboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}

  tiff(paste0(path,"QC/PAcalls/DABGboxplot_probes.tiff"),width=8*dpitiff,height=14*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(DABGboxplot_strips)
  dev.off()

  DABGboxplot_strips

},file="RDS_PAcall_DABGboxplot")


pacall_PSDABG <- xfun::cache_rds({
# Probeset level
  pacall_PSDABG  <- paCalls(CELdata,method="PSDABG")
  },file="RDS_PAcall_PSDABG")

  dim(pacall_PSDABG)
  pacall_PSDABG  <- merge(pacall_PSDABG,probe_annotation_probeset,by.x="row.names",by.y="fsetid",all=TRUE,sort=FALSE)
  colnames(pacall_PSDABG)[1]  <- "fsetid"
  pacall_PSDABG_percpresent <- apply(pacall_PSDABG,2,function(x) {(sum(x<0.05)/length(x))*100})
  pacall_PSDABG_melt <- reshape2::melt(pacall_PSDABG,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  pacall_PSDABG_melt$variable <- factor(pacall_PSDABG_melt$variable,levels=samplevel)
  pacall_PSDABG_percpresent_grouped <- na.omit(pacall_PSDABG_melt %>% group_by(type,variable) %>% summarise(percentage=(sum(value<0.05)/n())*100))

PSDABGboxplot  <- xfun::cache_rds({
  PSDABGboxplot <- ggplot() + geom_boxplot(data=pacall_PSDABG_melt,aes(x=variable,y=value,fill=variable))
  PSDABGboxplot <- papertheme(PSDABGboxplot,sizeselect = 12) + theme(legend.position = "none",axis.text.x = element_text(angle=90)) + xlab("") + ylab("PSDABG") + geom_hline(data=data.frame(int=0.05),aes(yintercept=int),color="red",linetype="dashed") + facet_wrap(type~.,scales="free_y",nrow=9,ncol=1) + scale_fill_manual(values=samplecolors) + scale_y_continuous(labels=function(x) sprintf("%.2f", x))
  PSDABGboxplot <- PSDABGboxplot + geom_text(data=pacall_PSDABG_percpresent_grouped,aes(x=variable,y=1.15,label=paste(sprintf("%.1f",percentage),"%",sep="")),size=3.5) + ylim(c(0,1.25))

  PSDABGboxplot_strips <-  ggplot_gtable(ggplot_build(PSDABGboxplot))
  stripr <- which(grepl('strip-t',PSDABGboxplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for(i in stripr){
  if(length(grepl('rect',PSDABGboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', PSDABGboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  PSDABGboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}

  tiff(paste0(path,"QC/PAcalls/PSDABGboxplot_probesets.tiff"),width=8*dpitiff,height=14*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(PSDABGboxplot_strips)
  dev.off()

  PSDABGboxplot_strips

},file="RDS_PAcall_PSDAGboxplot")
@

<<Quality Control - PA calls: DABG plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.width=10,fig.height=12,out.width="500pt",out.height="700pt",fig.cap=c("\\label{QC:fig18} Percent present calls detected above background at probe level.","\\label{QC:fig19} Percent present calls detected above background at probeset level."),fig.pos="H">>=
  # grid.draw(DABGboxplot)
  # grid.newpage(recording=FALSE)
  # grid.draw(PSDABGboxplot)
  ggdraw() +  draw_image(image_read(paste0(path,"QC/PAcalls/DABGboxplot_probes.tiff")))
  ggdraw() +  draw_image(image_read(paste0(path,"QC/PAcalls/PSDABGboxplot_probesets.tiff")))
@

<<Quality Control - PA calls: DABG and PSDAGB table,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
pacall_DABG_percpresent_grouped <- reshape2::dcast(pacall_DABG_percpresent_grouped,type ~ variable)
pacall_DABG_percpresent_grouped$type <- gsub("->","\\$\\\\rightarrow$",pacall_DABG_percpresent_grouped$type)
pacall_DABG_percpresent_grouped$type <- gsub("_"," ",pacall_DABG_percpresent_grouped$type)
pacall_DABG_percpresent_grouped[,-1] <- apply(pacall_DABG_percpresent_grouped[,-1],2,function(x) {sprintf("%.2f", as.numeric(x))})
colnames(pacall_DABG_percpresent_grouped) = cell_spec(colnames(pacall_DABG_percpresent_grouped), color = "white", align = "c", angle = 0, background = c("white",samplecolors),format="latex")

pacall_PSDABG_percpresent_grouped <- reshape2::dcast(pacall_PSDABG_percpresent_grouped,type ~ variable)
pacall_PSDABG_percpresent_grouped$type <- gsub("->","\\$\\\\rightarrow$",pacall_PSDABG_percpresent_grouped$type)
pacall_PSDABG_percpresent_grouped$type <- gsub("_"," ",pacall_PSDABG_percpresent_grouped$type)
pacall_PSDABG_percpresent_grouped[,-1] <- apply(pacall_PSDABG_percpresent_grouped[,-1],2,function(x) {sprintf("%.2f", as.numeric(x))})
colnames(pacall_PSDABG_percpresent_grouped) = cell_spec(colnames(pacall_PSDABG_percpresent_grouped), color = "white", align = "c", angle = 0, background = c("white",samplecolors),format="latex")
@

\begin{landscape}
<<Quality Control - PA calls: DABG and PSDAGB table render1,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
kable(pacall_DABG_percpresent_grouped,escape = F,booktabs = T,linesep= "",caption = "\\label{QC:table4} Percentage of 'present calls' at probe level.",format="latex")  %>% kable_paper() %>% column_spec(1, bold = T)  %>% kable_styling(font_size = 6)
@

<<Quality Control - PA calls: DABG and PSDAGB table render2,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
kable(pacall_PSDABG_percpresent_grouped,escape = F,booktabs = T,linesep= "",caption = "\\label{QC:table5} Percentage of 'present calls' at probeset level.",format="latex")  %>% kable_paper() %>% column_spec(1, bold = T) %>% kable_styling(font_size = 6)
@
\end{landscape}

<<Quality Control - PA calls controls: DABG and PSDAGB table,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
pacall_DABG_spikecontrols <- pacall_DABG[grep("AFFX",pacall_DABG$subtype),] %>% subset(type=="control->affx"|type=="control->affx->bac_spike"|type=="control->affx->polya_spike")
pacall_DABG_spikecontrols <- pacall_DABG_spikecontrols[,c("Blank1","Blank2","Blank3","SHIME1","SHIME2","SHIME3","SHIME_LGG1","SHIME_LGG2","SHIME_LGG3","HelaControl","fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg")]
pacall_DABG_spikecontrols_melt <- reshape2::melt(pacall_DABG_spikecontrols,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
pacall_DABG_spikecontrols_percpresent_grouped <- na.omit(pacall_DABG_spikecontrols_melt %>% group_by(type,subtype,variable) %>% summarise(percentage=(sum(value<0.05)/n())*100))

pacall_DABG_spikecontrols_percpresent_grouped <- reshape2::dcast(pacall_DABG_spikecontrols_percpresent_grouped,... ~ variable, value.var='percentage')
pacall_DABG_spikecontrols_percpresent_grouped <- pacall_DABG_spikecontrols_percpresent_grouped[,c(1:12)]
pacall_DABG_spikecontrols_percpresent_grouped[,-c(1,2)] <- apply(pacall_DABG_spikecontrols_percpresent_grouped[,-c(1,2)],2,function(x) {sprintf("%.2f", as.numeric(x))})
pacall_DABG_spikecontrols_percpresent_grouped$type <- gsub("->","\\$\\\\rightarrow$",pacall_DABG_spikecontrols_percpresent_grouped$type)
pacall_DABG_spikecontrols_percpresent_grouped$type <- gsub("_"," ",pacall_DABG_spikecontrols_percpresent_grouped$type)
pacall_DABG_spikecontrols_percpresent_grouped$subtype <- gsub("_"," ",pacall_DABG_spikecontrols_percpresent_grouped$subtype)
colnames(pacall_DABG_spikecontrols_percpresent_grouped) = cell_spec(colnames(pacall_DABG_spikecontrols_percpresent_grouped), color = "white", align = "c", angle = 0, background = c("white","white",samplecolors),format="latex")



pacall_PSDABG_spikecontrols <- pacall_PSDABG[grep("AFFX",pacall_PSDABG$subtype),] %>% subset(type=="control->affx"|type=="control->affx->bac_spike"|type=="control->affx->polya_spike")
pacall_PSDABG_spikecontrols <- pacall_PSDABG_spikecontrols[,c("Blank1","Blank2","Blank3","SHIME1","SHIME2","SHIME3","SHIME_LGG1","SHIME_LGG2","SHIME_LGG3","HelaControl","fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg")]
pacall_PSDABG_spikecontrols_melt <- reshape2::melt(pacall_PSDABG_spikecontrols,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
pacall_PSDABG_spikecontrols_percpresent_grouped <- na.omit(pacall_PSDABG_spikecontrols_melt %>% group_by(type,subtype,variable) %>% summarise(percentage=(sum(value<0.05)/n())*100))

pacall_PSDABG_spikecontrols_percpresent_grouped <- reshape2::dcast(pacall_PSDABG_spikecontrols_percpresent_grouped,... ~ variable, value.var='percentage')
pacall_PSDABG_spikecontrols_percpresent_grouped <- pacall_PSDABG_spikecontrols_percpresent_grouped[,c(1:12)]
pacall_PSDABG_spikecontrols_percpresent_grouped
pacall_PSDABG_spikecontrols_percpresent_grouped[,-c(1,2)] <- apply(pacall_PSDABG_spikecontrols_percpresent_grouped[,-c(1,2)],2,function(x) {sprintf("%.2f", as.numeric(x))})
pacall_PSDABG_spikecontrols_percpresent_grouped$type <- gsub("->","\\$\\\\rightarrow$",pacall_PSDABG_spikecontrols_percpresent_grouped$type)
pacall_PSDABG_spikecontrols_percpresent_grouped$type <- gsub("_"," ",pacall_PSDABG_spikecontrols_percpresent_grouped$type)
pacall_PSDABG_spikecontrols_percpresent_grouped$subtype <- gsub("_"," ",pacall_PSDABG_spikecontrols_percpresent_grouped$subtype)
colnames(pacall_PSDABG_spikecontrols_percpresent_grouped) = cell_spec(colnames(pacall_PSDABG_spikecontrols_percpresent_grouped), color = "white", align = "c", angle = 0, background = c("white","white",samplecolors),format="latex")
@

\begin{landscape}
<<Quality Control - PA calls controls: DABG and PSDAGB table render1,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
kable(pacall_DABG_spikecontrols_percpresent_grouped,escape = F,booktabs = T,linesep= "",caption = "\\label{QC:table6} Percentage of 'present calls' at probe level in the spike-in controls.",format="latex")  %>% kable_paper() %>% column_spec(1:2, bold = T) %>% kable_styling(font_size = 6)
@

<<Quality Control - PA calls controls: DABG and PSDAGB table render2,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
kable(pacall_PSDABG_spikecontrols_percpresent_grouped,escape = F,booktabs = T,linesep= "",caption = "\\label{QC:table7} Percentage of 'present calls' at probeset level in the spike-in controls.",format="latex")  %>% kable_paper() %>% column_spec(1:2, bold = T) %>% kable_styling(font_size = 6)
@
\end{landscape}

<<Quality Control - PA calls example data: DABG,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
pacall_DABG <- xfun::cache_rds({
# Probe level
  pacall_DABG <- paCalls(EXCELdata,method="DABG")
},file="RDS_PAcallexmaple_DABG")

  dim(pacall_DABG)
  length(match(rownames(pacall_DABG),probe_annotation_probeset$fid))
  rownames(pacall_DABG) <- probe_annotation_probeset$uniqueid
  pacall_DABG  <- merge(pacall_DABG,probe_annotation_probeset,by="row.names",all=TRUE,sort=FALSE)[,-1]
  pacall_DABG_percpresent <- apply(pacall_DABG,2,function(x) {(sum(x<0.05)/length(x))*100})
  #pacall_DABG <- rbind(pacall_DABG,pacall_DABG_percpresent)
  pacall_DABG_melt <- reshape2::melt(pacall_DABG,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  pacall_DABG_melt$variable <- factor(pacall_DABG_melt$variable,levels=exsamplevel)
  pacall_DABG_percpresent_grouped <- na.omit(pacall_DABG_melt %>% group_by(type,variable) %>% summarise(percentage=(sum(value<0.05)/n())*100))

DABGboxplot <- xfun::cache_rds({
  DABGboxplot <- ggplot() + geom_boxplot(data=pacall_DABG_melt,aes(x=variable,y=value,fill=variable))
  DABGboxplot <- papertheme(DABGboxplot,sizeselect = 12) + theme(legend.position = "none",axis.text.x = element_text(angle=90)) + xlab("") + ylab("DABG p-value") + geom_hline(data=data.frame(int=0.05),aes(yintercept=int),color="red",linetype="dashed") + facet_wrap(type~.,scales="free_y",nrow=9,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=exsamplecolors)
  DABGboxplot <- DABGboxplot + geom_text(data=pacall_DABG_percpresent_grouped,aes(x=variable,y=1.2,label=paste(sprintf("%.1f",percentage),"%",sep="")))

  DABGboxplot_strips <-  ggplot_gtable(ggplot_build(DABGboxplot))
  stripr <- which(grepl('strip-t',DABGboxplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for(i in stripr){
  if(length(grepl('rect',DABGboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', DABGboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  DABGboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}

  tiff(paste0(path,"exampleQC/PAcalls/DABGboxplot_probes.tiff"),width=12*dpi,height=16*dpi,res=dpi,compression="lzw")
  grid.draw(DABGboxplot_strips)
  dev.off()

  DABGboxplot_strips

},file="RDS_PAcallexmaple_DABGboxplot")

pacall_PSDABG <- xfun::cache_rds({
# Probeset level
  pacall_PSDABG  <- paCalls(EXCELdata,method="PSDABG")
},file="RDS_PAcallexmaple_PSDABG")

  dim(pacall_PSDABG)
  pacall_PSDABG  <- merge(pacall_PSDABG,probe_annotation_probeset,by.x="row.names",by.y="fsetid",all=TRUE,sort=FALSE)
  colnames(pacall_PSDABG)[1]  <- "fsetid"
  pacall_PSDABG_percpresent <- apply(pacall_PSDABG,2,function(x) {(sum(x<0.05)/length(x))*100})
  pacall_PSDABG_melt <- reshape2::melt(pacall_PSDABG,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  pacall_PSDABG_melt$variable <- factor(pacall_PSDABG_melt$variable,levels=exsamplevel)
  pacall_PSDABG_percpresent_grouped <- na.omit(pacall_PSDABG_melt %>% group_by(type,variable) %>% summarise(percentage=(sum(value<0.05)/n())*100))

PSDABGboxplot <- xfun::cache_rds({
  PSDABGboxplot <- ggplot() + geom_boxplot(data=pacall_PSDABG_melt,aes(x=variable,y=value,fill=variable))
  PSDABGboxplot <- papertheme(PSDABGboxplot,sizeselect = 12) + theme(legend.position = "none",axis.text.x = element_text(angle=90)) + xlab("") + ylab("PSDABG") + geom_hline(data=data.frame(int=0.05),aes(yintercept=int),color="red",linetype="dashed") + facet_wrap(type~.,scales="free_y",nrow=9,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=exsamplecolors)
  PSDABGboxplot <- PSDABGboxplot + geom_text(data=pacall_PSDABG_percpresent_grouped,aes(x=variable,y=1.2,label=paste(sprintf("%.1f",percentage),"%",sep="")))

  PSDABGboxplot_strips <-  ggplot_gtable(ggplot_build(PSDABGboxplot))
  stripr <- which(grepl('strip-t',PSDABGboxplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for(i in stripr){
  if(length(grepl('rect',PSDABGboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', PSDABGboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  PSDABGboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}

  tiff(paste0(path,"exampleQC/PAcalls/PSDABGboxplot_probesets.tiff"),width=12*dpi,height=16*dpi,res=dpi,compression="lzw")
  grid.draw(PSDABGboxplot_strips)
  dev.off()

  PSDABGboxplot_strips

},file="RDS_PAcallexmaple_PSDABGboxplot")
@

<<Quality Control - PA calls example data: DABG plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.width=12,fig.height=14,out.width="500pt",out.height="700pt",fig.cap=c("\\label{exQC:fig18} Percent present calls detected above background at probe level in the example data.","\\label{exQC:fig19} Percent present calls detected above background at probeset level in the example data."),fig.pos="H">>=
  # grid.draw(DABGboxplot)
  # grid.newpage(recording=FALSE)
  # grid.draw(PSDABGboxplot)
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/PAcalls/DABGboxplot_probes.tiff")))
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/PAcalls/PSDABGboxplot_probesets.tiff")))
@

<<Quality Control - PA calls: DABG table example data,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
pacall_DABG_percpresent_grouped <- reshape2::dcast(pacall_DABG_percpresent_grouped,type ~ variable)
pacall_DABG_percpresent_grouped[,-1] <- apply(pacall_DABG_percpresent_grouped[,-1],2,function(x) {sprintf("%.2f", as.numeric(x))})
pacall_DABG_percpresent_grouped$type <- gsub("->","\\$\\\\rightarrow$",pacall_DABG_percpresent_grouped$type)
pacall_DABG_percpresent_grouped$type <- gsub("_"," ",pacall_DABG_percpresent_grouped$type)
colnames(pacall_DABG_percpresent_grouped) = cell_spec(colnames(pacall_DABG_percpresent_grouped), color = "white", align = "c", angle = 0, background = c("white",exsamplecolors),format="latex")

pacall_PSDABG_percpresent_grouped <- reshape2::dcast(pacall_PSDABG_percpresent_grouped,type ~ variable)
pacall_PSDABG_percpresent_grouped[,-1] <- apply(pacall_PSDABG_percpresent_grouped[,-1],2,function(x) {sprintf("%.2f", as.numeric(x))})
pacall_PSDABG_percpresent_grouped$type <- gsub("->","\\$\\\\rightarrow$",pacall_PSDABG_percpresent_grouped$type)
pacall_PSDABG_percpresent_grouped$type <- gsub("_"," ",pacall_PSDABG_percpresent_grouped$type)
colnames(pacall_PSDABG_percpresent_grouped) = cell_spec(colnames(pacall_PSDABG_percpresent_grouped), color = "white", align = "c", angle = 0, background = c("white",exsamplecolors),format="latex")
@

\begin{landscape}
<<Quality Control - PA calls: DABG table example data render1,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
kable(pacall_DABG_percpresent_grouped,escape = F,booktabs = T,linesep= "",caption = "\\label{exQC:table4} Percentage of 'present calls' at probe level.",format="latex")  %>% kable_paper() %>% column_spec(1, bold = T)  %>% kable_styling(font_size = 4)
@

<<Quality Control - PA calls: DABG table example data render2,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
kable(pacall_PSDABG_percpresent_grouped,escape = F,booktabs = T,linesep= "",caption = "\\label{exQC:table5} Percentage of 'present calls' at probeset level.",format="latex")  %>% kable_paper() %>% column_spec(1, bold = T) %>% kable_styling(font_size = 4)
@
\end{landscape}

<<Quality Control - PA calls controls: DABG and PSDAGB table example data,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
pacall_DABG_spikecontrols <- pacall_DABG[grep("AFFX",pacall_DABG$subtype),] %>% subset(type=="control->affx"|type=="control->affx->bac_spike"|type=="control->affx->polya_spike")
pacall_DABG_spikecontrols_melt <- reshape2::melt(pacall_DABG_spikecontrols,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
pacall_DABG_spikecontrols_percpresent_grouped <- na.omit(pacall_DABG_spikecontrols_melt %>% group_by(type,subtype,variable) %>% summarise(percentage=(sum(value<0.05)/n())*100))

pacall_DABG_spikecontrols_percpresent_grouped <- reshape2::dcast(pacall_DABG_spikecontrols_percpresent_grouped,... ~ variable, value.var='percentage')
pacall_DABG_spikecontrols_percpresent_grouped
pacall_DABG_spikecontrols_percpresent_grouped[,-c(1,2)] <- apply(pacall_DABG_spikecontrols_percpresent_grouped[,-c(1,2)],2,function(x) {sprintf("%.2f", as.numeric(x))})
pacall_DABG_spikecontrols_percpresent_grouped$type <- gsub("->","\\$\\\\rightarrow$",pacall_DABG_spikecontrols_percpresent_grouped$type)
pacall_DABG_spikecontrols_percpresent_grouped$type <- gsub("_"," ",pacall_DABG_spikecontrols_percpresent_grouped$type)
pacall_DABG_spikecontrols_percpresent_grouped$subtype <- gsub("_"," ",pacall_DABG_spikecontrols_percpresent_grouped$subtype)
pacall_DABG_spikecontrols_percpresent_grouped <- pacall_DABG_spikecontrols_percpresent_grouped[,c("type","subtype",exsamplevel)]
colnames(pacall_DABG_spikecontrols_percpresent_grouped) = cell_spec(colnames(pacall_DABG_spikecontrols_percpresent_grouped), color = "white", align = "c", angle = 0, background = c("white","white",exsamplecolors),format="latex")


pacall_PSDABG_spikecontrols <- pacall_PSDABG[grep("AFFX",pacall_PSDABG$subtype),] %>% subset(type=="control->affx"|type=="control->affx->bac_spike"|type=="control->affx->polya_spike")
pacall_PSDABG_spikecontrols_melt <- reshape2::melt(pacall_PSDABG_spikecontrols,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
pacall_PSDABG_spikecontrols_percpresent_grouped <- na.omit(pacall_PSDABG_spikecontrols_melt %>% group_by(type,subtype,variable) %>% summarise(percentage=(sum(value<0.05)/n())*100))

pacall_PSDABG_spikecontrols_percpresent_grouped <- reshape2::dcast(pacall_PSDABG_spikecontrols_percpresent_grouped,... ~ variable, value.var='percentage')
pacall_PSDABG_spikecontrols_percpresent_grouped
pacall_PSDABG_spikecontrols_percpresent_grouped[,-c(1,2)] <- apply(pacall_PSDABG_spikecontrols_percpresent_grouped[,-c(1,2)],2,function(x) {sprintf("%.2f", as.numeric(x))})
pacall_PSDABG_spikecontrols_percpresent_grouped$type <- gsub("->","\\$\\\\rightarrow$",pacall_PSDABG_spikecontrols_percpresent_grouped$type)
pacall_PSDABG_spikecontrols_percpresent_grouped$type <- gsub("_"," ",pacall_PSDABG_spikecontrols_percpresent_grouped$type)
pacall_PSDABG_spikecontrols_percpresent_grouped$subtype <- gsub("_"," ",pacall_PSDABG_spikecontrols_percpresent_grouped$subtype)
pacall_PSDABG_spikecontrols_percpresent_grouped <- pacall_PSDABG_spikecontrols_percpresent_grouped[,c("type","subtype",exsamplevel)]
colnames(pacall_PSDABG_spikecontrols_percpresent_grouped) = cell_spec(colnames(pacall_PSDABG_spikecontrols_percpresent_grouped), color = "white", align = "c", angle = 0, background = c("white","white",exsamplecolors),format="latex")
@

\begin{landscape}
<<Quality Control - PA calls controls: DABG and PSDAGB table example data render1,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
kable(pacall_DABG_spikecontrols_percpresent_grouped,escape = F,booktabs = T,linesep= "",caption = "\\label{exQC:table6} Percentage of 'present calls' at probe level in the spike-in controls.",format="latex")  %>% kable_paper() %>% column_spec(1:2, bold = T) %>% kable_styling(font_size = 3)
@

<<Quality Control - PA calls controls: DABG and PSDAGB table example data render2,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
kable(pacall_PSDABG_spikecontrols_percpresent_grouped,escape = F,booktabs = T,linesep= "",caption = "\\label{exQC:table7} Percentage of 'present calls' at probe level in the spike-in controls.",format="latex")  %>% kable_paper() %>% column_spec(1:2, bold = T) %>% kable_styling(font_size = 3)
@
\end{landscape}

As expected the antigenomic background probes have high p-values and the percent present calls (in the absence of transcripts) is fixed at 5\% (Figures \ref{QC:fig18} and \ref{QC:fig19}). The negative controls and main probes are within the same range (4-20\%), whereas the percentage of present calls in the positive controls is around 60\%. Probeset level analysis decreases the observed variability and at transcript level, the antigenomic background controls all display 0\% present calls. Positive controls range between 70 to 100 \%. Negative controls and main probe present calls fall within the same range. Prior to normalization blank3, SHIME\_LGG1 and the Hela cell control show deviation patterns and a consistently lower percent present calls in every probe type group, except for the bac spike and background controls. Whereas this variability in the percentage of present calls might represent actual biological variability in the Hela cell control versus the coculture cell samples, the number of probesets called present relative to the total number of probesets in the replicate coculture samples should be similar. The higher polyA signal reported earlier in the Hela control translates in an increased percentage of presence calls, setting the Hela control apart from the blank3 andSHIME\_LGG1 sample. As mentioned before this suggests an increased polyA/total intact RNA ratio in the Hela control and is indicative of a less efficient target preparation in the deviation blank and SHIME\_LGG1 replicates. Hence, normalization will be required (see \ref{normalization}). This is standard in microarray analysis as can be seen from the example dataset displaying similar presence profiles (Figures \ref{exQC:fig18} and \ref{exQC:fig19}).

\vspace{\fill}
\clearpage

\section{Probe-level model fitting: Chip pseudo-images, RLE and NUSE - summarized data}
In order to better visualize discrepancies between replicates on the individual arrays, pseudo-images are generated by fitting robust Probe Level linear Models (PLM) to all probesets in the data (e.g. to the summarized data see \ref{summarization}) \cite{Bolstad2004}. Probe-level models consist of probe-level (assuming that each probe should behave the same on all arrays) and chip/array/sample-level (taking into account that a gene can have different expression levels in different samples) parameters. Probe level models assume that all probes of a probe group behave the same in the different samples (Package Oligo version \Sexpr{packageVersion("oligo")}). Probes that bind well to their target should do so on all arrays, probes that bind with low affinity should do so on all arrays. PLM implements iteratively re-weighted least squares M-estimation regression and the following model was considered:

\begin{align}\label{PLM}
&y_{ijk} = \beta_{jk} + \alpha{ik} + \eta{ijk}\\
&with\: i\: index\: for\: probes,\: j\: index\: for\: arrays\: and\: k\: index\: for\: probesets\\
&with\: y_{ijk}:\: a\: (pre-processed\: if\: normalization\: and\: background\: correction\: applied)\\
&probe\: intensity\: on\: log2\: scale\\
&with\: \alpha{ik}:\: the\: probe\: effect\: parameter\: for\: probe\: i \\
&with\: \beta_{jk}:\: the\: array\: (chip)\: effect \\
&with\: \eta{ijk}:\: an\: error\: term
\end{align}

Two types of pseudo-images were created based on the residuals (Figure \ref{QC:fig20}) respectively the weights (Figure \ref{QC:fig21}) resulting from a comparison of the model (the ideal data, without any noise) to the actual data. These weights or residuals are graphically displayed using the image() function in Bioconductor. Weights represent how much the original data contribute to the model: outliers are strongly downweighted because they are largely different from the ideal data. Weights have values between 0 and 1. The smaller the weight of a probe, the more the probe is not showing the typical behavior that it shows on the other arrays and the more its intensity can be considered an outlier. Residuals represent the difference between the original data and the ideal data according to the model. So the more a residual deviates from 0, the larger the difference between the data and the model. Residuals can be positive indicating that the intensity of the probe is larger than the ideal value according to the model or negative indicating that the intensity of the probe is smaller than the ideal value according to the model. Residuals can be further formatted in different ways:
\begin{itemize}
\item type="resids": higher red intensities corresponding with higher positive residuals, white corresponding with residuals close to 0 and more intense blues corresponding with high negative residuals.
\item type="pos.resids": Extreme positive residuals plotted in red, negative and near 0 residuals in orange
\item type="neg.resids": Extreme negative residuals plotted in blue, positive, negative and near 0 residuals plotted in white
\item type="sign.resids": all negative residuals regardless of magnitude are indicated by blue and all positive residuals in red
\end{itemize}

The artifacts observed in the microarray pictures of the raw log 2 probe intensities (Figure \ref{QC:fig1}), are also visible in the residuals and weights plots. When a large number of outliers (affected probes in a large surface area) is present, ambiguity may arise when the regressive model cannot determine whether the artifact data are too high, or the non-artifact data are too low. Since the patches do not show up in the other replicate areas, the model likely correctly identified the artifacts (Figure \ref{QC:fig20}- \ref{QC:fig21}).

%Without prior knowledge, caCORRECT, however,identifies the actual scratched region as artifact, and the surrounding data as non-artifact. With this knowledge, the regressive model fits only to the non-artifact data. The white region surrounding the scratch (and redness of the scratch itself) is evidence that caCORRECT has successfully disambiguated the decision. The positive red colored residuals are surrounded by a white region, suggesting that the artifact  The blue (negative residual) regions that surround the main red scratch (positive residual) demonstrate the

Other important QC metrics derived from PLM fitting are the Relative Log Expression (RLE) and the Normalized Unscaled Standard Errors (NUSE), displayed in box plots (Figure \ref{QC:fig22}-\ref{QC:fig23}).
The RLE is computed for each sample on every probeset by comparing the expression level of one probeset against the median expression of that probeset across samples. Assuming that most genes are not changing in expression across arrays, ideally most of these RLE values will be near 0. Typically arrays with poorer quality show up with boxes that are not centered around 0 and/or are more spread out. Boxes with larger whiskers indicate an unusually high deviation from the median in a lot of transcripts, suggesting that these arrays are different from most of the others in some way. Boxes that are shifted indicate a systematically higher or lower expression of the majority of transcripts in comparison to most of the other arrays. This could be caused by quality issues or batch effects \cite{Klaus2016}. Therefore, if shape and median of a given box varies too much from the bulk, they should be inspected and potentially removed.This is the case for blank3, SHIME\_LGG1 and the Hela cell control (Figure \ref{QC:fig22}).

To determine NUSE, the standard error estimates obtained for each probeset on each array from fitPLM are standardized across arrays so that the median standard error for that probe group is 1 across all arrays. This process accounts for differences in variability between genes. Arrays whose NUSE values are significantly higher than other samples are often lower quality chips. The interquartile ranges are slightly larger in the blank3,SHIME\_LGG1 and Hela cell control arrays without normalization (Figure \ref{QC:fig23}).
Focusing on the control probes, the RLE values are near 0 and the NUSE values are rather small, with the largest variation again observed in the Hela cell control (Figure \ref{QC:fig20} and \ref{QC:fig21}).

The RLE and NUSE values in the example data are similar, strengthening the confidence in the obtained data (Figures \ref{exQC:fig22}-\ref{exQC:fig25}).

<<Quality Control - Probe-level model fitting+Chip Pseudo Images,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show='hide'>>=
Pset <- xfun::cache_rds({
# Fit probe-level model and explore results
  #?fitProbeLevelModel(CELdata)
  Pset = oligo::fitProbeLevelModel(CELdata,target="core",background=FALSE,normalize=FALSE,method="plm")
  Pset},file="RDS_Pset")

  oligo::weights(Pset) # attributes(Pset)$weights # : "matrix" with weights - probe-level
  oligo::residuals(Pset) # attributes(Pset)$residuals # "matrix" with residuals - probe-level
  oligo::residualSE(Pset) # attributes(Pset)$residualSE
  # Chip level effects for every probeset
  length(oligo::coef(Pset))
  oligo::coef(Pset) # is equivalent to attributes(Pset)$chip.coefs # "matrix" with chip/sample effects - probeset-level
  oligo::se(Pset) # is equivalent to attributes(Pset)$se.chip.coefs "matrix" with standard errors for chip/sample coefficients
  # Probe level effects (for annotated probes at core level)
  length(oligo::coefs.probe(Pset))
  oligo::coefs.probe(Pset) #attributes(Pset)$probe.coefs # : "numeric" vector with probe effects
  oligo::se.probe(Pset) # attributes(Pset)$se.probe.coefs # "numeric" vector with standard errors for probe

# Create legends for residuals
  res <- oligo::residuals(Pset)
  dim(res)
  minres <-  min(na.omit(res))
  maxres <-  max(na.omit(res))

  ##  residuals blue white red
  col_res <- colorRampPalette(c("blue","white","red"))
  colorlegend_res <- ggplotify::as.ggplot(ggcolor.bar(col_res(100),minres,maxres,"Residuals",c(-6,-3,0,3,6))) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_residual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend_res
  dev.off()

  colorlegend_res <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_residual_colorlegend.tiff"))
  colorlegend_res <- image_trim(colorlegend_res)
  colorlegend_res <- ggdraw() +  draw_image(colorlegend_res)

  ## Positive residuals white, orange, red
  col_posres <- colorRampPalette(c("#FFF7EC", "#FEE8C8", "#FDD49E", "#FDBB84", "#FC8D59","#EF6548", "#D7301F", "#B30000", "#7F0000"))
  colorlegend_posres <- ggplotify::as.ggplot(ggcolor.bar(col_posres(100),minres,maxres,"Residuals",c(-6,-3,0,3,6))) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_posresidual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend_posres
  dev.off()

  colorlegend_posres <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_posresidual_colorlegend.tiff"))
  colorlegend_posres <- image_trim(colorlegend_posres)
  colorlegend_posres <- ggdraw() +  draw_image(colorlegend_posres)

  ## Negative residuals blue, lightblue, white
  col_negres <- colorRampPalette(c(rev(c("#F7FBFF","#DEEBF7","#C6DBEF","#9ECAE1","#6BAED6","#4292C6", "#2171B5", "#08519C", "#08306B"))))
  colorlegend_negres <- ggplotify::as.ggplot(ggcolor.bar(col_negres(100),minres,maxres,"Residuals",c(-6,-3,0,3,6))) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_negresidual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend_negres
  dev.off()

  colorlegend_negres <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_negresidual_colorlegend.tiff"))
  colorlegend_negres <- image_trim(colorlegend_negres)
  colorlegend_negres <- ggdraw() +  draw_image(colorlegend_negres)

  ## Sign residuals blue or red
  col_signres <- colorRampPalette(c("#08306B","#7F0000"))
  colorlegend_signres <- ggplotify::as.ggplot(ggcolor.bar(col_signres(2),minres,maxres,"Residuals",c("<0",">0"),fill="manual")) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_signresidual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend_signres
  dev.off()

  colorlegend_signres <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_signresidual_colorlegend.tiff"))
  colorlegend_signres <- image_trim(colorlegend_signres)
  colorlegend_signres <- ggdraw() +  draw_image(colorlegend_signres)

  ## Create legends for weights
  wt <- oligo::weights(Pset)
  minwt <- 0
  maxwt <- 1

  col_wt <- colorRampPalette(c("#F7FBFF", "#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6",
            "#4292C6", "#2171B5", "#08519C", "#08306B"))
  colorlegend_wt <- ggplotify::as.ggplot(ggcolor.bar(col_wt(100),minwt,maxwt,"Weights",c(0,0.5,1))) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_weight_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend_wt
  dev.off()

  colorlegend_wt <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_weight_colorlegend.tiff"))
  colorlegend_wt <- image_trim(colorlegend_wt)
  colorlegend_wt <- ggdraw() +  draw_image(colorlegend_wt)

# Pseudo-images by residuals
  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name = paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_residual",namei,".tiff")
  tiff(name)
  oligo::image(Pset,which=i,type="residuals",main=rownames(CELsampledata@data)[i],col=col_res(100))
  dev.off()
  ploti <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_residual",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Pseudoimage_residual",namei),ploti)
  }

  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name = paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_posresidual",namei,".tiff")
  tiff(name)
  oligo::image(Pset,which=i,type="pos.residuals",main=rownames(CELsampledata@data)[i],col=col_posres(10))
  dev.off()
  ploti <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_posresidual",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Pseudoimage_posresidual",namei),ploti)}

  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name = paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_negresidual",namei,".tiff",sep="")
  tiff(name)
  oligo::image(Pset,which=i,type="neg.residuals",main=rownames(CELsampledata@data)[i],col=col_negres(100))
  dev.off()
  ploti <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_negresidual",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Pseudoimage_negresidual",namei),ploti)}

  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name = paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_signresidual",namei,".tiff")
  tiff(name)
  oligo::image(Pset,which=i,type="sign.residuals",main=rownames(CELsampledata@data)[i],col_signres(2))
  dev.off()
  ploti <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_signresidual",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Pseudoimage_signresidual",namei),ploti)}

# Pseudo-images by weight
  for (i in 1:10){
  namei <- rownames(CELsampledata@data)[i]
  name = paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_weight",namei,".tiff",sep="")
  tiff(name)
  oligo::image(Pset,which=i,type="weight",main=rownames(CELsampledata@data)[i],col=col_wt(100))
  dev.off()
  ploti <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_weight",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Pseudoimage_weight",namei),ploti)}

# Image composition
  Microarray_ALL_res <- plot_grid(Pseudoimage_residualBlank1,Pseudoimage_residualBlank2,Pseudoimage_residualBlank3,Pseudoimage_residualSHIME1,Pseudoimage_residualSHIME2,Pseudoimage_residualSHIME3,Pseudoimage_residualSHIME_LGG1,Pseudoimage_residualSHIME_LGG2,Pseudoimage_residualSHIME_LGG3,Pseudoimage_residualHelaControl,colorlegend_res,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.25,0.25,0.25,0.25))

  tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_ALLresidual.tiff"),width=8*dpi,height=8*dpi,res=dpi,compression="lzw")
  Microarray_ALL_res
  dev.off()

  Microarray_ALL_posres <- plot_grid(Pseudoimage_posresidualBlank1,Pseudoimage_posresidualBlank2,Pseudoimage_posresidualBlank3,Pseudoimage_posresidualSHIME1,Pseudoimage_posresidualSHIME2,Pseudoimage_posresidualSHIME3,Pseudoimage_posresidualSHIME_LGG1,Pseudoimage_posresidualSHIME_LGG2,Pseudoimage_posresidualSHIME_LGG3,Pseudoimage_posresidualHelaControl,colorlegend_posres,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.25,0.25,0.25,0.25))

  tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_ALLposresidual.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_ALL_posres
  dev.off()

  Microarray_ALL_negres <- plot_grid(Pseudoimage_negresidualBlank1,Pseudoimage_negresidualBlank2,Pseudoimage_negresidualBlank3,Pseudoimage_negresidualSHIME1,Pseudoimage_negresidualSHIME2,Pseudoimage_negresidualSHIME3,Pseudoimage_negresidualSHIME_LGG1,Pseudoimage_negresidualSHIME_LGG2,Pseudoimage_negresidualSHIME_LGG3,Pseudoimage_negresidualHelaControl,colorlegend_negres,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.25,0.25,0.25,0.25))

  tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_ALLnegresidual.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_ALL_negres
  dev.off()

  Microarray_ALL_signres <- plot_grid(Pseudoimage_signresidualBlank1,Pseudoimage_signresidualBlank2,Pseudoimage_signresidualBlank3,Pseudoimage_signresidualSHIME1,Pseudoimage_signresidualSHIME2,Pseudoimage_signresidualSHIME3,Pseudoimage_signresidualSHIME_LGG1,Pseudoimage_signresidualSHIME_LGG2,Pseudoimage_signresidualSHIME_LGG3,Pseudoimage_signresidualHelaControl,colorlegend_signres,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.25,0.25,0.25,0.25))
  Microarray_ALL_signres

  tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_ALLsignresidual.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_ALL_signres
  dev.off()

  Microarray_ALL_wt <- plot_grid(Pseudoimage_weightBlank1,Pseudoimage_weightBlank2,Pseudoimage_weightBlank3,Pseudoimage_weightSHIME1,Pseudoimage_weightSHIME2,Pseudoimage_weightSHIME3,Pseudoimage_weightSHIME_LGG1,Pseudoimage_weightSHIME_LGG2,Pseudoimage_weightSHIME_LGG3,Pseudoimage_weightHelaControl,colorlegend_wt,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.25,0.25,0.25,0.25))

  Microarray_ALL
  tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_ALLweight.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_ALL_wt
  dev.off()


# Relative Log Expression: RLE # manual: 
  row_medians_assayData <- Biobase::rowMedians(as.matrix(Biobase::exprs(CELdata))) 
  RLE_data <- sweep(Biobase::exprs(CELdata), 1, row_medians_assayData)
  RLE_data <- as.data.frame(RLE_data)
  oligo::RLE(Pset,type="stats")[,1:2]
  oligo::RLE(Pset,type="values")[1:4,1:2]
  RLEstat <- oligo::RLE(Pset,type="stats")
  RLEval <- oligo::RLE(Pset,type="values")
  dim(RLEval)
  RLEvalmelt <- reshape2::melt(RLEval)
  RLEvalmelt$Var2 <- factor(RLEvalmelt$Var2,levels=samplevel)

  RLEboxplot <- xfun::cache_rds({
  RLEboxplot <- ggplot() + geom_boxplot(data=RLEvalmelt,aes(x=Var2,y=value,fill=Var2))
  RLEboxplot <- papertheme(RLEboxplot,sizeselect = 12) + theme(legend.position = "none") + xlab("") + ylab("RLE") + scale_fill_manual(values=samplecolors) + scale_fill_manual(values=samplecolors) + scale_x_discrete(labels=sampleplotname)

  tiff(paste0(path,"QC/ProbelevelModelfitting/RLEboxplot.tiff"),width=8*dpi,height=4*dpi,res=dpi,compression="lzw")
  RLEboxplot
  dev.off()

  RLEboxplot

  },file="RDS_RLEboxplot")


# Normalized Unscaled Standard Errors: NUSE
  #NUSE(Pset,type="stats")[,1:2]
  oligo::NUSE(Pset,type="values")[1:4,1:2]
  #NUSEstat <- NUSE(Pset,type="stats",na.rm=TRUE)
  NUSEval <- oligo::NUSE(Pset,type="values")
  dim(NUSEval)
  NUSEvalmelt <- reshape2::melt(NUSEval)
  NUSEvalmelt$Var2 <- factor(NUSEvalmelt$Var2,levels=samplevel)

  NUSEboxplot <- xfun::cache_rds({
  NUSEboxplot <- ggplot() + geom_boxplot(data=NUSEvalmelt,aes(x=Var2,y=value,fill=Var2))
  NUSEboxplot <- papertheme(NUSEboxplot,sizeselect =12) + theme(legend.position = "none") + xlab("") + ylab("NUSE") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=samplecolors) + scale_x_discrete(labels=sampleplotname)

  tiff(paste0(path,"QC/ProbelevelModelfitting/NUSEboxplot.tiff"),width=8*dpi,height=4*dpi,res=dpi,compression="lzw")
  NUSEboxplot
  dev.off()

  NUSEboxplot

},file="RDS_NUSEboxplot")
@

<<Quality Control - Probe-level model fitting+Chip Pseudo Images plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="700pt",fig.cap=c("\\label{QC:fig20} Pseudo-images of the estimated residuals from a probe-level model fitting","\\label{QC:fig21} Pseudo-images of the estimated weights from a probe-level model fitting"),fig.pos="H">>=
# Display plots
  # Microarray_ALL_res
  #     #Microarray_ALL_posres
  #     #Microarray_ALL_negres
  #     #Microarray_ALL_signres
  # Microarray_ALL_wt
  # RLEboxplot
  # NUSEboxplot
  
  ggdraw() +  draw_image(image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_ALLresidual.tiff")))
  ggdraw() +  draw_image(image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_ALLweight.tiff")))
@


\vspace{\fill}

\begin{landscape}
<<Quality Control - Probe-level model fitting+Chip Pseudo Images plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{QC:fig22} Box plot of the Relative Log Expression (RLE) values based on a probe-level model fitting","\\label{QC:fig23} Box plot of the Normalized Unscaled Standard Errors (NUSE) values based on a probe-level model fitting"),fig.pos="H">>=
# Display plots
  # Microarray_ALL_res
  #     #Microarray_ALL_posres
  #     #Microarray_ALL_negres
  #     #Microarray_ALL_signres
  # Microarray_ALL_wt
  # RLEboxplot
  # NUSEboxplot
  
  ggdraw() +  draw_image(image_read(paste0(path,"QC/ProbelevelModelfitting/RLEboxplot.tiff")))
  ggdraw() +  draw_image(image_read(paste0(path,"QC/ProbelevelModelfitting/NUSEboxplot.tiff")))
@
\end{landscape}

<<Quality Control - Probe-level model fitting to calculate RLE and NUSE for control probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
# Relative Log Expression: RLE
  RLEval_controls_melt <- RLEvalmelt[RLEvalmelt$Var1%in%probecontrols_core$fsetid,]
  RLEval_controls_melt$type <- mapvalues(RLEval_controls_melt$Var1,from=probecontrols_core$fsetid,to=as.character(probecontrols_core$type))

RLEboxplot_strips <- xfun::cache_rds({
  RLEboxplot <- ggplot() + geom_boxplot(data=RLEval_controls_melt,aes(x=Var2,y=value,fill=Var2))
  RLEboxplot <- papertheme(RLEboxplot,sizeselect = 12) + theme(legend.position = "none",axis.text.x=element_text(angle=90)) + xlab("") + ylab("RLE") + facet_wrap(type~.,scales="free_y") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=samplecolors)

  RLEboxplot_strips <-  ggplot_gtable(ggplot_build(RLEboxplot))
  stripr <- which(grepl('strip-t',RLEboxplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for(i in stripr){
  if(length(grepl('rect',RLEboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', RLEboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  RLEboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}

  tiff(paste0(path,"QC/ProbelevelModelfitting/RLEboxplot_controls.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  grid.draw(RLEboxplot_strips)
  dev.off()

  RLEboxplot_strips
},file="RDS_RLEboxplot_probetype")

 # Normalized Unscaled Standard Errors: NUSE
  NUSEval_controls_melt <- NUSEvalmelt[NUSEvalmelt$Var1%in%probecontrols_core$fsetid,]
  NUSEval_controls_melt$type <- mapvalues(NUSEval_controls_melt$Var1,from=probecontrols_core$fsetid,to=as.character(probecontrols_core$type))

  NUSEboxplot_strips <- xfun::cache_rds({
  NUSEboxplot <- ggplot() + geom_boxplot(data=NUSEval_controls_melt,aes(x=Var2,y=value,fill=Var2))
  NUSEboxplot <- papertheme(NUSEboxplot,sizeselect=12) + theme(legend.position = "none",axis.text.x=element_text(angle=90)) + xlab("") + ylab("NUSE") + facet_wrap(type~.,scales="free_y") + scale_y_continuous(labels=function(x) sprintf("%.2f", x))  + scale_fill_manual(values=samplecolors)

  NUSEboxplot_strips <-  ggplot_gtable(ggplot_build(NUSEboxplot))
  stripr <- which(grepl('strip-t',NUSEboxplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for(i in stripr){
  if(length(grepl('rect',NUSEboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', NUSEboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  NUSEboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}

  tiff(paste0(path,"QC/ProbelevelModelfitting/NUSEboxplot_controls.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  grid.draw(NUSEboxplot_strips)
  dev.off()

  NUSEboxplot_strips
},file="RDS_NUSEboxplot_probetype")
@

<<Quality Control - Probe-level model fitting to calculate RLE and NUSE for control probes plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="600pt",fig.cap=c("\\label{QC:fig24} Box plot of the Relative Log Expression (RLE) values of control probes based on a probe-level model fitting","\\label{QC:fig25} Box plot of the Normalized Unscaled Standard Errors (NUSE) values of control probes based on a probe-level model fitting"),fig.pos="H">>=
  # grid.draw(RLEboxplot_strips)
  # grid.newpage(recording=FALSE)
  # grid.draw(NUSEboxplot_strips)
   ggdraw() +  draw_image(image_read(paste0(path,"QC/ProbelevelModelfitting/RLEboxplot_controls.tiff")))
   ggdraw() +  draw_image(image_read(paste0(path,"QC/ProbelevelModelfitting/NUSEboxplot_controls.tiff")))
@

<<Quality Control - Probe-level model fitting+Chip Pseudo Images example data,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
Pset <- xfun::cache_rds({
# Fit probe-level model and explore results
  #?fitProbeLevelModel(EXCELdata)
  Pset = oligo::fitProbeLevelModel(EXCELdata,target="core",background=FALSE,normalize=FALSE,method="plm")
  Pset},file="RDS_Psetexample")

  oligo::weights(Pset) # attributes(Pset)$weights # : "matrix" with weights - probe-level
  oligo::residuals(Pset) # attributes(Pset)$residuals # "matrix" with residuals - probe-level
  oligo::residualSE(Pset) # attributes(Pset)$residualSE
  oligo::coef(Pset) # is equivalent to attributes(Pset)$chip.coefs # "matrix" with chip/sample effects - probeset-level
  oligo::se(Pset) # is equivalent to attributes(Pset)$se.chip.coefs "matrix" with standard errors for chip/sample coefficients
  oligo::coefs.probe(Pset) #attributes(Pset)$probe.coefs # : "numeric" vector with probe effects
  oligo::se.probe(Pset) # attributes(Pset)$se.probe.coefs # "numeric" vector with standard errors for probe effects

# Create legends for residuals
  res <- oligo::residuals(Pset)
  minres <-  min(na.omit(res))
  maxres <-  max(na.omit(res))

  ##  residuals blue white red
  col_res <- colorRampPalette(c("blue","white","red"))
  colorlegend_res <- ggplotify::as.ggplot(ggcolor.bar(col_res(100),minres,maxres,"Residuals",c(-6,-3,0,3,6))) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_residual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend_res
  dev.off()

  colorlegend_res <- image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_residual_colorlegend.tiff"))
  colorlegend_res <- image_trim(colorlegend_res)
  colorlegend_res <- ggdraw() +  draw_image(colorlegend_res)

  ## Positive residuals white, orange, red
  col_posres <- colorRampPalette(c("#FFF7EC", "#FEE8C8", "#FDD49E", "#FDBB84", "#FC8D59","#EF6548", "#D7301F", "#B30000", "#7F0000"))
  colorlegend_posres <- ggplotify::as.ggplot(ggcolor.bar(col_posres(100),minres,maxres,"Residuals",c(-6,-3,0,3,6))) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_posresidual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend_posres
  dev.off()

  colorlegend_posres <- image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_posresidual_colorlegend.tiff"))
  colorlegend_posres <- image_trim(colorlegend_posres)
  colorlegend_posres <- ggdraw() +  draw_image(colorlegend_posres)

  ## Negative residuals blue, lightblue, white
  col_negres <- colorRampPalette(c(rev(c("#F7FBFF","#DEEBF7","#C6DBEF","#9ECAE1","#6BAED6","#4292C6", "#2171B5", "#08519C", "#08306B"))))
  colorlegend_negres <- ggplotify::as.ggplot(ggcolor.bar(col_negres(100),minres,maxres,"Residuals",c(-6,-3,0,3,6))) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_negresidual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend_negres
  dev.off()

  colorlegend_negres <- image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_negresidual_colorlegend.tiff"))
  colorlegend_negres <- image_trim(colorlegend_negres)
  colorlegend_negres <- ggdraw() +  draw_image(colorlegend_negres)

  ## Sign residuals blue or red
  col_signres <- colorRampPalette(c("#08306B","#7F0000"))
  colorlegend_signres <- ggplotify::as.ggplot(ggcolor.bar(col_signres(2),minres,maxres,"Residuals",c("<0",">0"),fill="manual")) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_signresidual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend_signres
  dev.off()

  colorlegend_signres <- image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_signresidual_colorlegend.tiff"))
  colorlegend_signres <- image_trim(colorlegend_signres)
  colorlegend_signres <- ggdraw() +  draw_image(colorlegend_signres)

  ## Create legends for weights
  wt <- oligo::weights(Pset)
  minwt <- 0
  maxwt <- 1

  col_wt <- colorRampPalette(c("#F7FBFF", "#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6",
            "#4292C6", "#2171B5", "#08519C", "#08306B"))
  colorlegend_wt <- ggplotify::as.ggplot(ggcolor.bar(col_wt(100),minwt,maxwt,"Weights",c(0,0.5,1))) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_weight_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
  colorlegend_wt
  dev.off()

  colorlegend_wt <- image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_weight_colorlegend.tiff"))
  colorlegend_wt <- image_trim(colorlegend_wt)
  colorlegend_wt <- ggdraw() +  draw_image(colorlegend_wt)

# Pseudo-images by residuals
  for (i in 1:24){
  namei <- rownames(EXCELsampledata@data)[i]
  name = paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_residual",namei,".tiff")
  tiff(name)
  oligo::image(Pset,which=i,type="residuals",main=rownames(EXCELsampledata@data)[i],col=col_res(100))
  dev.off()
  ploti <- image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_residual",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Pseudoimage_residual",namei),ploti)
  }

  for (i in 1:24){
  namei <- rownames(EXCELsampledata@data)[i]
  name = paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_posresidual",namei,".tiff")
  tiff(name)
  oligo::image(Pset,which=i,type="pos.residuals",main=rownames(EXCELsampledata@data)[i],col=col_posres(10))
  dev.off()
  ploti <- image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_posresidual",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Pseudoimage_posresidual",namei),ploti)}

  for (i in 1:24){
  namei <- rownames(EXCELsampledata@data)[i]
  name = paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_negresidual",namei,".tiff",sep="")
  tiff(name)
  oligo::image(Pset,which=i,type="neg.residuals",main=rownames(EXCELsampledata@data)[i],col=col_negres(100))
  dev.off()
  ploti <- image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_negresidual",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Pseudoimage_negresidual",namei),ploti)}

  for (i in 1:24){
  namei <- rownames(EXCELsampledata@data)[i]
  name = paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_signresidual",namei,".tiff")
  tiff(name)
  oligo::image(Pset,which=i,type="sign.residuals",main=rownames(EXCELsampledata@data)[i],col_signres(2))
  dev.off()
  ploti <- image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_signresidual",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Pseudoimage_signresidual",namei),ploti)}

# Pseudo-images by weight
  for (i in 1:24){
  namei <- rownames(EXCELsampledata@data)[i]
  name = paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_weight",namei,".tiff",sep="")
  tiff(name)
  oligo::image(Pset,which=i,type="weight",main=rownames(EXCELsampledata@data)[i],col=col_wt(100))
  dev.off()
  ploti <- image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_weight",namei,".tiff"))
  ploti <- ggdraw() +  draw_image(ploti)
  ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
  assign(paste0("Pseudoimage_weight",namei),ploti)}

# Image composition
  ## Tissues
  Microarray_tissue <- plot_grid(`Pseudoimage_residualLiver1`,`Pseudoimage_residualLiver2`,`Pseudoimage_residualLiver3`,`Pseudoimage_residualLiver4`,`Pseudoimage_residualMuscle1`,`Pseudoimage_residualMuscle2`,`Pseudoimage_residualMuscle3`,`Pseudoimage_residualMuscle4`,`Pseudoimage_residualSpleen1`,`Pseudoimage_residualSpleen2`,`Pseudoimage_residualSpleen3`,`Pseudoimage_residualSpleen4`,`Pseudoimage_residualTestes1`,`Pseudoimage_residualTestes2`,`Pseudoimage_residualTestes3`,`Pseudoimage_residualTestes4`,colorlegend_res,NULL,NULL,NULL,nrow=5,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.23,0.23,0.23,0.23,0.08))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_residual_tissues.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_tissue
  dev.off()

  Microarray_tissue_posres <- plot_grid(`Pseudoimage_posresidualLiver1`,`Pseudoimage_posresidualLiver2`,`Pseudoimage_posresidualLiver3`,`Pseudoimage_posresidualLiver4`,`Pseudoimage_posresidualMuscle1`,`Pseudoimage_posresidualMuscle2`,`Pseudoimage_posresidualMuscle3`,`Pseudoimage_posresidualMuscle4`,`Pseudoimage_posresidualSpleen1`,`Pseudoimage_posresidualSpleen2`,`Pseudoimage_posresidualSpleen3`,`Pseudoimage_posresidualSpleen4`,`Pseudoimage_posresidualTestes1`,`Pseudoimage_posresidualTestes2`,`Pseudoimage_posresidualTestes3`,`Pseudoimage_posresidualTestes4`,colorlegend_posres,NULL,NULL,NULL,nrow=5,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.23,0.23,0.23,0.23,0.08))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_posresidual_tissues.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_tissue_posres
  dev.off()

  Microarray_tissue_negres <- plot_grid(`Pseudoimage_negresidualLiver1`,`Pseudoimage_negresidualLiver2`,`Pseudoimage_negresidualLiver3`,`Pseudoimage_negresidualLiver4`,`Pseudoimage_negresidualMuscle1`,`Pseudoimage_negresidualMuscle2`,`Pseudoimage_negresidualMuscle3`,`Pseudoimage_negresidualMuscle4`,`Pseudoimage_negresidualSpleen1`,`Pseudoimage_negresidualSpleen2`,`Pseudoimage_negresidualSpleen3`,`Pseudoimage_negresidualSpleen4`,`Pseudoimage_negresidualTestes1`,`Pseudoimage_negresidualTestes2`,`Pseudoimage_negresidualTestes3`,`Pseudoimage_negresidualTestes4`,colorlegend_negres,NULL,NULL,NULL,nrow=5,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.23,0.23,0.23,0.23,0.08))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_negresidual_tissues.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_tissue_negres
  dev.off()

  Microarray_tissue_signres <- plot_grid(`Pseudoimage_signresidualLiver1`,`Pseudoimage_signresidualLiver2`,`Pseudoimage_signresidualLiver3`,`Pseudoimage_signresidualLiver4`,`Pseudoimage_signresidualMuscle1`,`Pseudoimage_signresidualMuscle2`,`Pseudoimage_signresidualMuscle3`,`Pseudoimage_signresidualMuscle4`,`Pseudoimage_signresidualSpleen1`,`Pseudoimage_signresidualSpleen2`,`Pseudoimage_signresidualSpleen3`,`Pseudoimage_signresidualSpleen4`,`Pseudoimage_signresidualTestes1`,`Pseudoimage_signresidualTestes2`,`Pseudoimage_signresidualTestes3`,`Pseudoimage_signresidualTestes4`,colorlegend_signres,NULL,NULL,NULL,nrow=5,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.23,0.23,0.23,0.23,0.08))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_signresidual_tissues.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_tissue_signres
  dev.off()

  Microarray_tissue_wt <- plot_grid(`Pseudoimage_weightLiver1`,`Pseudoimage_weightLiver2`,`Pseudoimage_weightLiver3`,`Pseudoimage_weightLiver4`,`Pseudoimage_weightMuscle1`,`Pseudoimage_weightMuscle2`,`Pseudoimage_weightMuscle3`,`Pseudoimage_weightMuscle4`,`Pseudoimage_weightSpleen1`,`Pseudoimage_weightSpleen2`,`Pseudoimage_weightSpleen3`,`Pseudoimage_weightSpleen4`,`Pseudoimage_weightTestes1`,`Pseudoimage_weightTestes2`,`Pseudoimage_weightTestes3`,`Pseudoimage_weightTestes4`,colorlegend_wt,NULL,NULL,NULL,nrow=5,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.23,0.23,0.23,0.23,0.08))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_weight_tissues.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_tissue_wt
  dev.off()

  ## MAQ controls
  Microarray_MAQC <- plot_grid(`Pseudoimage_residualMAQCA1`,`Pseudoimage_residualMAQCA2`,`Pseudoimage_residualMAQCA3`,`Pseudoimage_residualMAQCA4`,`Pseudoimage_residualMAQCB1`,`Pseudoimage_residualMAQCB2`,`Pseudoimage_residualMAQCB3`,`Pseudoimage_residualMAQCB4`,colorlegend_res,NULL,NULL,NULL,nrow=3,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.31,0.31,0.31,0.05))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_residual_MAQC.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_MAQC
  dev.off()

  Microarray_MAQC_posres <- plot_grid(`Pseudoimage_posresidualMAQCA1`,`Pseudoimage_posresidualMAQCA2`,`Pseudoimage_posresidualMAQCA3`,`Pseudoimage_posresidualMAQCA4`,`Pseudoimage_posresidualMAQCB1`,`Pseudoimage_posresidualMAQCB2`,`Pseudoimage_posresidualMAQCB3`,`Pseudoimage_posresidualMAQCB4`,colorlegend_posres,NULL,NULL,NULL,nrow=3,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.31,0.31,0.31,0.05))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_posresidual_MAQC.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_MAQC_posres
  dev.off()

  Microarray_MAQC_negres <- plot_grid(`Pseudoimage_negresidualMAQCA1`,`Pseudoimage_negresidualMAQCA2`,`Pseudoimage_negresidualMAQCA3`,`Pseudoimage_negresidualMAQCA4`,`Pseudoimage_negresidualMAQCB1`,`Pseudoimage_negresidualMAQCB2`,`Pseudoimage_negresidualMAQCB3`,`Pseudoimage_negresidualMAQCB4`,colorlegend_negres,NULL,NULL,NULL,nrow=3,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.31,0.31,0.31,0.05))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_negresidual_MAQC.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_MAQC_negres
  dev.off()

  Microarray_MAQC_signres <- plot_grid(`Pseudoimage_signresidualMAQCA1`,`Pseudoimage_signresidualMAQCA2`,`Pseudoimage_signresidualMAQCA3`,`Pseudoimage_signresidualMAQCA4`,`Pseudoimage_signresidualMAQCB1`,`Pseudoimage_signresidualMAQCB2`,`Pseudoimage_signresidualMAQCB3`,`Pseudoimage_signresidualMAQCB4`,colorlegend_signres,NULL,NULL,NULL,nrow=3,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.31,0.31,0.31,0.05))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_signresidual_MAQC.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_MAQC_signres
  dev.off()

  Microarray_MAQC_wt <- plot_grid(`Pseudoimage_weightMAQCA1`,`Pseudoimage_weightMAQCA2`,`Pseudoimage_weightMAQCA3`,`Pseudoimage_weightMAQCA4`,`Pseudoimage_weightMAQCB1`,`Pseudoimage_weightMAQCB2`,`Pseudoimage_weightMAQCB3`,`Pseudoimage_weightMAQCB4`,colorlegend_wt,NULL,NULL,NULL,nrow=3,ncol=4,rel_widths = c(0.25,0.25,0.25,0.25),rel_heights=c(0.31,0.31,0.31,0.05))

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_weight_MAQC.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  Microarray_MAQC_wt
  dev.off()


# Relative Log Expression: RLE
  #oligo::RLE(Pset,type="stats")[,1:2]
  oligo::RLE(Pset,type="values")[1:4,1:2]
  #RLEstat <- oligo::RLE(Pset,type="stats")
  RLEval <- oligo::RLE(Pset,type="values")
  dim(RLEval)
  RLEvalmelt <- reshape2::melt(RLEval)
  RLEvalmelt$Var2 <- factor(RLEvalmelt$Var2,levels=exsamplevel)

  RLEboxplot <- xfun::cache_rds({
  RLEboxplot <- ggplot() + geom_boxplot(data=RLEvalmelt,aes(x=Var2,y=value,fill=Var2))
  RLEboxplot <- papertheme(RLEboxplot,sizeselect = 12) + theme(legend.position = "none",axis.text.x = element_text(angle=90)) + xlab("") + ylab("RLE") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=exsamplecolors)

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/RLEboxplot.tiff"),width=8*dpi,height=4*dpi,res=dpi,compression="lzw")
  RLEboxplot
  dev.off()

  RLEboxplot

  },file="RDS_RLEboxplotexample")

# Normalized Unscaled Standard Errors: NUSE
  #NUSE(Pset,type="stats")[,1:2]
  oligo::NUSE(Pset,type="values")[1:4,1:2]
  #NUSEstat <- NUSE(Pset,type="stats",na.rm=TRUE)
  NUSEval <- oligo::NUSE(Pset,type="values")
  dim(NUSEval)
  NUSEvalmelt <- reshape2::melt(NUSEval)
  NUSEvalmelt$Var2 <- factor(NUSEvalmelt$Var2,levels=exsamplevel)

  NUSEboxplot <- xfun::cache_rds({
  NUSEboxplot <- ggplot() + geom_boxplot(data=NUSEvalmelt,aes(x=Var2,y=value,fill=Var2))
  NUSEboxplot <- papertheme(NUSEboxplot,sizeselect = 12) + theme(legend.position = "none",axis.text.x = element_text(angle=90)) + xlab("") + ylab("NUSE") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=exsamplecolors)

  tiff(paste0(path,"exampleQC/ProbelevelModelfitting/NUSEboxplot.tiff"),width=8*dpi,height=4*dpi,res=dpi,compression="lzw")
  NUSEboxplot
  dev.off()

  NUSEboxplot

},file="RDS_NUSEboxplot_example")
@

<<Quality Control - Probe-level model fitting+Chip Pseudo Images example data plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="700pt",fig.cap=c("\\label{exQC:fig20} Pseudo-images of the estimated residuals from a probe-level model fitting of the tissue example data.","\\label{exQC:fig20b} Pseudo-images of the estimated residuals from a probe-level model fitting of the MAQC example data.","\\label{exQC:fig21} Pseudo-images of the estimated weights from a probe-level model fitting of the tissue example data.","\\label{exQC:fig21b} Pseudo-images of the estimated weights from a probe-level model fitting of the MAQC example data."),fig.pos="H">>=
  # Microarray_tissue
  #   #Microarray_tissue_posres
  #   #Microarray_tissue_negres
  #   #Microarray_tissue_signres
  # Microarray_MAQC
  #   #Microarray_MAQC_posres
  #   #Microarray_MAQC_negres
  #   #Microarray_MAQC_signres
  # Microarray_tissue_wt
  # Microarray_MAQC_wt
  # 
  # RLEboxplot
  # NUSEboxplot
  
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_residual_tissues.tiff")))
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_residual_MAQC.tiff")))
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_weight_tissues.tiff")))
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/ProbelevelModelfitting/Pseudoimage_weight_MAQC.tiff")))
@


\vspace{\fill}


\begin{landscape}
<<Quality Control - Probe-level model fitting+Chip Pseudo Images example data plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{exQC:fig22} Box plot of the Relative Log Expression (RLE) values based on a probe-level model fitting of the example data.","\\label{exQC:fig23} Box plot of the Normalized Unscaled Standard Errors (NUSE) values based on a probe-level model fitting of the example data."),fig.pos="H">>=
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/ProbelevelModelfitting/RLEboxplot.tiff")))
  ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/ProbelevelModelfitting/NUSEboxplot.tiff")))
@
\end{landscape}

<<Quality Control - Probe-level model fitting to calculate RLE and NUSE for control probes example data,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
  # Relative Log Expression: RLE
    RLEval_controls_melt <- RLEvalmelt[RLEvalmelt$Var1%in%probecontrols_core$fsetid,]
    RLEval_controls_melt$type <- mapvalues(RLEval_controls_melt$Var1,from=probecontrols_core$fsetid,to=as.character(probecontrols_core$type))
    RLEval_controls_melt$type <- factor(RLEval_controls_melt$type,levels=levels(probetypes$type_id))
    RLEval_controls_melt$Var2 <- factor(RLEval_controls_melt$Var2,levels=exsamplevel)

RLEboxplot <- xfun::cache_rds({
    RLEboxplot <- ggplot() + geom_boxplot(data=RLEval_controls_melt,aes(x=Var2,y=value,fill=Var2))
    RLEboxplot <- papertheme(RLEboxplot,sizeselect = 12) + theme(legend.position = "none",axis.text.x = element_text(angle=90)) + xlab("") + ylab("RLE") + facet_wrap(type~.,scales="free_y") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=exsamplecolors)

    RLEboxplot_strips <-  ggplot_gtable(ggplot_build(RLEboxplot))
    stripr <- which(grepl('strip-t',RLEboxplot_strips$layout$name))
    fills <- c("#afeeeeA6","#afeeee33","#ff3030A6","#ff303040","#00688bA6","#00688b80","#00688b59","#00688b33")
    k <- 1
    for(i in stripr){
    if(length(grepl('rect',RLEboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
    j <- which(grepl('rect', RLEboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
    RLEboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
    k <- k+1}

    tiff(paste0(path,"exampleQC/ProbelevelModelfitting/RLEboxplot_controls.tiff"),width=11*dpi,height=10*dpi,res=dpi,compression="lzw")
    grid.draw(RLEboxplot_strips)
    dev.off()

    RLEboxplot_strips}
    },file="RDS_RLEboxplot_pertype")



   # Normalized Unscaled Standard Errors: NUSE
    #NUSE(Pset,type="stats")[,1:2]
    NUSEval_controls_melt <- NUSEvalmelt[NUSEvalmelt$Var1%in%probecontrols_core$fsetid,]
    NUSEval_controls_melt$type <- mapvalues(NUSEval_controls_melt$Var1,from=probecontrols_core$fsetid,to=as.character(probecontrols_core$type))
    NUSEval_controls_melt$type <- factor(NUSEval_controls_melt$type,levels=levels(probetypes$type_id))
    NUSEval_controls_melt$Var2 <- factor(NUSEval_controls_melt$Var2,level=exsamplevel)

    NUSEboxplot <- xfun::cache_rds({
    NUSEboxplot <- ggplot() + geom_boxplot(data=NUSEval_controls_melt,aes(x=Var2,y=value,fill=Var2))
    NUSEboxplot <- papertheme(NUSEboxplot,sizeselect = 12) + theme(legend.position = "none",axis.text.x=element_text(angle=90)) + xlab("") + ylab("NUSE") + facet_wrap(type~.,scales="free_y") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=exsamplecolors)

    NUSEboxplot_strips <-  ggplot_gtable(ggplot_build(NUSEboxplot))
    stripr <- which(grepl('strip-t',NUSEboxplot_strips$layout$name))
    fills <- c("#afeeeeA6","#afeeee33","#ff3030A6","#ff303040","#00688bA6","#00688b80","#00688b59","#00688b33")
    k <- 1
    for(i in stripr){
    if(length(grepl('rect',NUSEboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
    j <- which(grepl('rect', NUSEboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
    NUSEboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
    k <- k+1}}

    tiff(paste0(path,"exampleQC/ProbelevelModelfitting/NUSEboxplot_controls.tiff"),width=11*dpi,height=10*dpi,res=dpi,compression="lzw")
    grid.draw(NUSEboxplot_strips)
    dev.off()

    NUSEboxplot_strips
    },file="RDS_NUSEboxplot_bytype")
@

<<Quality Control - Probe-level model fitting to calculate RLE and NUSE for control probes example data plot ,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="600pt",fig.cap=c("\\label{exQC:fig24} Box plot of the Relative Log Expression (RLE) values of control probes based on a probe-level model fitting of the example data.","\\label{exQC:fig25} Box plot of the Normalized Unscaled Standard Errors (NUSE) values of control probes based on a probe-level model fitting of the example data."),fig.pos="H">>=
    # grid.draw(RLEboxplot_strips)
    # grid.newpage(recording=FALSE)
    # grid.draw(NUSEboxplot_strips)
   ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/ProbelevelModelfitting/RLEboxplot_controls.tiff")))
   ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/ProbelevelModelfitting/NUSEboxplot_controls.tiff")))
@

\section{PCA}
Finally, after assessing the distributional assumptions, Principle Component Analysis (PCA) was performed and confidence ellipses were constructed to identify outliers based on the Hotelling's T2 test statistic in the unnormalized log2 transformed standardized data. Besides a PCA model based on all probes, subsets of the control probes were explored in a series of PCAs to identify specific steps in the experimental process that may have resulted in aberrant expression patterns. While no outlier samples were detected based on the Hotelling's T2 criterium, the Hela cell control is clearly separated from the coculture model samples in all PCA models and will be omitted during downstream pre-processing. Blank3 and SHIME\_LGG1 also seem to cluster separately in all, but the bac PCA. This indicates that hybridization went well, but anomalies may have occurred during sample preparation. This is not the case for sample SHIME1 displaying a diverging pattern in all PCAs except for polyA, suggesting that a deviation in starting RNA yield/quality may underlie the observed deviating intensity signals of the SHIME1 microarray. These moderately deviating microarrays (Blank3, SHIME1 and SHIME\_LGG1) will be re-evaluated after normalization \ref{QC:fig26} (see \ref{QCpostproc}). Outliers were also observed in the example dataset \ref{exQC:fig26}.

<<Quality Control - PCA all probes,include=TRUE,results='hide',warning=FALSE,message=TRUE,cache=TRUE>>=
# Multivariate normality
  # MVN <- xfun::cache_rds({
  # MVN <- ggpairs(CELdata_pm_core_log2_df) + scale_y_continuous(labels=function(x) sprintf("%.2f", x))
  # MVN},file="RDS_MVN")
  #
  # ## elliptic patterns in the bivariate comparisons => multivariate normality
  # maha <- xfun::cache_rds({
  # mahalanobis(CELdata_pm_core_log2_df,colMeans(CELdata_pm_core_log2_df),pracma::pinv(cov(CELdata_pm_core_log2_df)),inverted=TRUE)},file="RDS_maha_RMA") # a bit of a weird situation as distance is same for all objects accidentally
  # QQ <- xfun::cache_rds({
  # plot(qchisq(ppoints(mahalanobis(CELdata_pm_core_log2_df,colMeans(CELdata_pm_core_log2_df),pracma::pinv(cov(CELdata_pm_core_log2_df)),inverted=TRUE)),df=10),sort(mahalanobis(CELdata_pm_core_log2_df,colMeans(CELdata_pm_core_log2_df),pracma::pinv(cov(CELdata_pm_core_log2_df)),inverted=TRUE)),xlab="Observed",ylab="Expected")},file="RDS_qq")


# PCA
  # prcomp function
     PCA <- prcomp(t(CELdata_pm_core_log2_df),scale. = FALSE)
     PCAsummary <- summary(PCA)
     attributes(PCA)
  ## prcomp results
     PCA_eigval <- as.numeric(PCA$sdev^2)
     # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
     # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
     # PCA$center # colMeans(data)
     # PCA$scale
     # PCA$x # data_centered%*%svd(data_centered)$v
  ## pcromp plots
     # plot(PCA$x[,1:2],col=samplecolors)
     PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
     PCA_scores$rowname <- factor(PCA_scores$rowname,levels=samplevel)
  ## Hotelling T2 ellipse
     Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
     Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
     Zt1sq <- Zt1*Zt1
     Zt2sq <- Zt2*Zt2
     Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
     x0 <- 0
     y0 <- 0
     a <- sqrt(PCA_eigval)[1]
     b <- sqrt(PCA_eigval)[2]
     Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

     n <- nrow(t(CELdata_pm_core_log2_df))
     p <- 2 # Because we're in 2D
     fcorrect <- (n-p)/(p*(n-1))
     Ztdat$y = Ztdat$y*fcorrect
     confF <- qf(df1=p,df2=n-p,p=0.95)
     confF <- qf(df1=p,df2=n-p,p=0.99)

     ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

     PCAplot_allprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.5) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=samplecolors)
     PCAplot_allprobes <- papertheme(PCAplot_allprobes,sizeselect=12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none") + ggtitle("All probes")

# PCA background probes
  # prcomp function
     PCA <- prcomp(t(CELdata_bg_core_log2),scale. = TRUE)
     PCAsummary <- summary(PCA)
     attributes(PCA)
  ## prcomp results
     PCA_eigval <- as.numeric(PCA$sdev^2)
     # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
     # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
     # PCA$center # colMeans(data)
     # PCA$scale
     # PCA$x # data_centered%*%svd(data_centered)$v
  ## pcromp plots
     # plot(PCA$x[,1:2],col=samplecolors)
     PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
     PCA_scores$rowname <- factor(PCA_scores$rowname,levels=samplevel)
  ## Hotelling T2 ellipse
     Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
     Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
     Zt1sq <- Zt1*Zt1
     Zt2sq <- Zt2*Zt2
     Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
     x0 <- 0
     y0 <- 0
     a <- sqrt(PCA_eigval)[1]
     b <- sqrt(PCA_eigval)[2]
     Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

     n <- nrow(t(CELdata_pm_core_log2_df))
     p <- 2 # Because we're in 2D
     fcorrect <- (n-p)/(p*(n-1))
     Ztdat$y = Ztdat$y*fcorrect
     confF <- qf(df1=p,df2=n-p,p=0.95)
     confF <- qf(df1=p,df2=n-p,p=0.99)

     ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

     PCAplot_bgprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.5) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=samplecolors)
     PCAplot_bgprobes <- papertheme(PCAplot_bgprobes,sizeselect=12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none") + ggtitle("Background probes")


# PCA affx bac probes
  # prcomp function
     PCA <- prcomp(t(CELdata_control_affx_bac_log2 %>% dplyr::select(-colnames(probe_annotation_core))),scale. = TRUE)
     PCAsummary <- summary(PCA)
     attributes(PCA)
  ## prcomp results
     PCA_eigval <- as.numeric(PCA$sdev^2)
     # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
     # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
     # PCA$center # colMeans(data)
     # PCA$scale
     # PCA$x # data_centered%*%svd(data_centered)$v
  ## pcromp plots
     # plot(PCA$x[,1:2],col=samplecolors)
     PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
     PCA_scores$rowname <- factor(PCA_scores$rowname,levels=samplevel)
  ## Hotelling T2 ellipse
     Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
     Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
     Zt1sq <- Zt1*Zt1
     Zt2sq <- Zt2*Zt2
     Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
     x0 <- 0
     y0 <- 0
     a <- sqrt(PCA_eigval)[1]
     b <- sqrt(PCA_eigval)[2]
     Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

     n <- nrow(t(CELdata_pm_core_log2_df))
     p <- 2 # Because we're in 2D
     fcorrect <- (n-p)/(p*(n-1))
     Ztdat$y = Ztdat$y*fcorrect
     confF <- qf(df1=p,df2=n-p,p=0.95)
     confF <- qf(df1=p,df2=n-p,p=0.99)

     ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

     PCAplot_bacprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.5) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=samplecolors)
     PCAplot_bacprobes <- papertheme(PCAplot_bacprobes,sizeselect=12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none") + ggtitle("Bac positive control probes")

# PCA affx polyA probes
  # prcomp function
     PCA <- prcomp(t(CELdata_control_affx_polyA_log2 %>% dplyr::select(-colnames(probe_annotation_core))),scale. = TRUE)
     PCAsummary <- summary(PCA)
     attributes(PCA)
  ## prcomp results
     PCA_eigval <- as.numeric(PCA$sdev^2)
     # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
     # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
     # PCA$center # colMeans(data)
     # PCA$scale
     # PCA$x # data_centered%*%svd(data_centered)$v
  ## pcromp plots
     # plot(PCA$x[,1:2],col=samplecolors)
     PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
     PCA_scores$rowname <- factor(PCA_scores$rowname,levels=samplevel)
  ## Hotelling T2 ellipse
     Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
     Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
     Zt1sq <- Zt1*Zt1
     Zt2sq <- Zt2*Zt2
     Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
     x0 <- 0
     y0 <- 0
     a <- sqrt(PCA_eigval)[1]
     b <- sqrt(PCA_eigval)[2]
     Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

     n <- nrow(t(CELdata_pm_core_log2_df))
     p <- 2 # Because we're in 2D
     fcorrect <- (n-p)/(p*(n-1))
     Ztdat$y = Ztdat$y*fcorrect
     confF <- qf(df1=p,df2=n-p,p=0.95)
     confF <- qf(df1=p,df2=n-p,p=0.99)

     ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

     PCAplot_polyAprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.5) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=samplecolors)
     PCAplot_polyAprobes <- papertheme(PCAplot_polyAprobes,sizeselect=12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed")  + theme(legend.position = "none") + ggtitle("PolyA positive control probes")

# PCA endogenous control probes
  # prcomp function
     PCA <- prcomp(t(CELdata_control_normgene_exon_log2 %>% dplyr::select(-colnames(probe_annotation_core))),scale. = TRUE)
     PCAsummary <- summary(PCA)
     attributes(PCA)
  ## prcomp results
     PCA_eigval <- as.numeric(PCA$sdev^2)
     # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
     # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
     # PCA$center # colMeans(data)
     # PCA$scale
     # PCA$x # data_centered%*%svd(data_centered)$v
  ## pcromp plots
     # plot(PCA$x[,1:2],col=samplecolors)
     PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
     PCA_scores$rowname <- factor(PCA_scores$rowname,levels=samplevel)
    ## Hotelling T2 ellipse
     Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
     Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
     Zt1sq <- Zt1*Zt1
     Zt2sq <- Zt2*Zt2
     Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
     x0 <- 0
     y0 <- 0
     a <- sqrt(PCA_eigval)[1]
     b <- sqrt(PCA_eigval)[2]
     Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

     n <- nrow(t(CELdata_pm_core_log2_df))
     p <- 2 # Because we're in 2D
     fcorrect <- (n-p)/(p*(n-1))
     Ztdat$y = Ztdat$y*fcorrect
     confF <- qf(df1=p,df2=n-p,p=0.95)
     confF <- qf(df1=p,df2=n-p,p=0.99)

     ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

     PCAplot_endogenouscontrolprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.5) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=samplecolors)
     PCAplot_endogenouscontrolprobes <- papertheme(PCAplot_endogenouscontrolprobes,sizeselect=12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none") + ggtitle("Endogenous control probes")
@

\begin{landscape}
<<Quality Control - PCA plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{QC:fig26} PCA scores plot of the log2 transformed standardized data.")>>=
#plot_grid(PCAplot_allprobes,PCAplot_bgprobes,NULL,PCAplot_bacprobes,PCAplot_polyAprobes,PCAplot_endogenouscontrolprobes,nrow=2,ncol=3)

tiff(paste0(path,"QC/PCA/PCA.tiff"),width=8*dpi,height=6*dpi,res=dpi,compression="lzw")
plot_grid(PCAplot_allprobes,PCAplot_bgprobes,NULL,PCAplot_bacprobes,PCAplot_polyAprobes,PCAplot_endogenouscontrolprobes,nrow=2,ncol=3)
dev.off()

ggdraw() +  draw_image(image_read(paste0(path,"QC/PCA/PCA.tiff")))
@
\end{landscape}

<<Quality Control - PCA all probes example data,include=TRUE,results='hide',warning=FALSE,message=TRUE,cache=TRUE>>=
# Multivariate normality
  # MVN <- xfun::cache_rds({
  # MVN <- ggpairs(CELdata_pm_core_log2_df) + scale_y_continuous(labels=function(x) sprintf("%.2f", x))
  # MVN},file="RDS_MVN")
  #
  # ## elliptic patterns in the bivariate comparisons => multivariate normality
  # maha <- xfun::cache_rds({
  # mahalanobis(CELdata_pm_core_log2_df,colMeans(CELdata_pm_core_log2_df),pracma::pinv(cov(CELdata_pm_core_log2_df)),inverted=TRUE)},file="RDS_maha_RMA") # a bit of a weird situation as distance is same for all objects accidentally
  # QQ <- xfun::cache_rds({
  # plot(qchisq(ppoints(mahalanobis(EXCELdata_pm_core_log2_df,colMeans(EXCELdata_pm_core_log2_df),pracma::pinv(cov(EXCELdata_pm_core_log2_df)),inverted=TRUE)),df=10),sort(mahalanobis(EXCELdata_pm_core_log2_df,colMeans(EXCELdata_pm_core_log2_df),pracma::pinv(cov(EXCELdata_pm_core_log2_df)),inverted=TRUE)),xlab="Observed",ylab="Expected")},file="RDS_qq")

EXCELdata_pm_core_log2_df_PCA <- EXCELdata_pm_core_log2_df
EXCELdata_pm_core_log2_df_PCA[EXCELdata_pm_core_log2_df_PCA=="Inf"] <-0
EXCELdata_pm_core_log2_df_PCA[EXCELdata_pm_core_log2_df_PCA=="-Inf"] <-0

# PCA
  # prcomp function
     PCA <- prcomp(t(EXCELdata_pm_core_log2_df_PCA),scale. = FALSE)
     PCAsummary <- summary(PCA)
     attributes(PCA)
  ## prcomp results
     PCA_eigval <- as.numeric(PCA$sdev^2)
     # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
     # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
     # PCA$center # colMeans(data)
     # PCA$scale
     # PCA$x # data_centered%*%svd(data_centered)$v
  ## pcromp plots
     # plot(PCA$x[,1:2],col=exsamplecolors)
     PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
     PCA_scores$rowname <- factor(PCA_scores$rowname,levels=exsamplevel)
  ## Hotelling T2 ellipse
     Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
     Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
     Zt1sq <- Zt1*Zt1
     Zt2sq <- Zt2*Zt2
     Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
     x0 <- 0
     y0 <- 0
     a <- sqrt(PCA_eigval)[1]
     b <- sqrt(PCA_eigval)[2]
     Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

     n <- nrow(t(CELdata_pm_core_log2_df))
     p <- 2 # Because we're in 2D
     fcorrect <- (n-p)/(p*(n-1))
     Ztdat$y = Ztdat$y*fcorrect
     confF <- qf(df1=p,df2=n-p,p=0.95)
     confF <- qf(df1=p,df2=n-p,p=0.99)

     ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

     PCAplot_allprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.8) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=exsamplecolors)+ theme(legend.position = "none") + ggtitle("All probes") + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed")
     PCAplot_allprobes <- papertheme(PCAplot_allprobes,sizeselect=12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none") + ggtitle("All probes")

# PCA background probes
  # prcomp function
     PCA <- prcomp(t(EXCELdata_bg_core_log2),scale. = TRUE)
     PCAsummary <- summary(PCA)
     attributes(PCA)
  ## prcomp results
     # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
     # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
     # PCA$center # colMeans(data)
     # PCA$scale
     # PCA$x # data_centered%*%svd(data_centered)$v
  ## pcromp plots
     # plot(PCA$x[,1:2],col=exsamplecolors)
     PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
     PCA_scores$rowname <- factor(PCA_scores$rowname,levels=exsamplevel)
  ## Hotelling T2 ellipse
     Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
     Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
     Zt1sq <- Zt1*Zt1
     Zt2sq <- Zt2*Zt2
     Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
     x0 <- 0
     y0 <- 0
     a <- sqrt(PCA_eigval)[1]
     b <- sqrt(PCA_eigval)[2]
     Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

     n <- nrow(t(CELdata_pm_core_log2_df))
     p <- 2 # Because we're in 2D
     fcorrect <- (n-p)/(p*(n-1))
     Ztdat$y = Ztdat$y*fcorrect
     confF <- qf(df1=p,df2=n-p,p=0.95)
     confF <- qf(df1=p,df2=n-p,p=0.99)

     ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

     PCAplot_bgprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.8) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=exsamplecolors) + theme(legend.position = "none") + ggtitle("Background probes") + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed")
     PCAplot_bgprobes <- papertheme(PCAplot_bgprobes,sizeselect=12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none") + ggtitle("All probes")

# PCA affx bac probes
  # prcomp function
     PCA <- prcomp(t(EXCELdata_control_affx_bac_log2 %>% dplyr::select(-colnames(probe_annotation_core))),scale. = TRUE)
     PCAsummary <- summary(PCA)
     attributes(PCA)
  ## prcomp results
     # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
     # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
     # PCA$center # colMeans(data)
     # PCA$scale
     # PCA$x # data_centered%*%svd(data_centered)$v
  ## pcromp plots
     # plot(PCA$x[,1:2],col=exsamplecolors)
     PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
     PCA_scores$rowname <- factor(PCA_scores$rowname,levels=exsamplevel)
  ## Hotelling T2 ellipse
     Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
     Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
     Zt1sq <- Zt1*Zt1
     Zt2sq <- Zt2*Zt2
     Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
     x0 <- 0
     y0 <- 0
     a <- sqrt(PCA_eigval)[1]
     b <- sqrt(PCA_eigval)[2]
     Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

     n <- nrow(t(CELdata_pm_core_log2_df))
     p <- 2 # Because we're in 2D
     fcorrect <- (n-p)/(p*(n-1))
     Ztdat$y = Ztdat$y*fcorrect
     confF <- qf(df1=p,df2=n-p,p=0.95)
     confF <- qf(df1=p,df2=n-p,p=0.99)

     ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

     PCAplot_bacprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.8) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=exsamplecolors) + theme(legend.position = "none") + ggtitle("Bac positive control probes") + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed")
     PCAplot_bacprobes <- papertheme(PCAplot_allprobes,sizeselect=12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none") + ggtitle("All probes")

# PCA affx polyA probes
  # prcomp function
     PCA <- prcomp(t(EXCELdata_control_affx_polyA_log2 %>% dplyr::select(-colnames(probe_annotation_core))),scale. = TRUE)
     PCAsummary <- summary(PCA)
     attributes(PCA)
  ## prcomp results
     # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
     # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
     # PCA$center # colMeans(data)
     # PCA$scale
     # PCA$x # data_centered%*%svd(data_centered)$v
  ## pcromp plots
     # plot(PCA$x[,1:2],col=exsamplecolors)
     PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
     PCA_scores$rowname <- factor(PCA_scores$rowname,levels=exsamplevel)
  ## Hotelling T2 ellipse
     Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
     Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
     Zt1sq <- Zt1*Zt1
     Zt2sq <- Zt2*Zt2
     Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
     x0 <- 0
     y0 <- 0
     a <- sqrt(PCA_eigval)[1]
     b <- sqrt(PCA_eigval)[2]
     Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

     n <- nrow(t(CELdata_pm_core_log2_df))
     p <- 2 # Because we're in 2D
     fcorrect <- (n-p)/(p*(n-1))
     Ztdat$y = Ztdat$y*fcorrect
     confF <- qf(df1=p,df2=n-p,p=0.95)
     confF <- qf(df1=p,df2=n-p,p=0.99)

     ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

     PCAplot_polyAprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.8) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" "))  + scale_color_manual(values=exsamplecolors) + theme(legend.position = "none") + ggtitle("PolyA positive control probes") + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed")
     PCAplot_polyAprobes <- papertheme(PCAplot_allprobes,sizeselect=12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none") + ggtitle("All probes")

# PCA endogenous control probes
  # prcomp function
     PCA <- prcomp(t(EXCELdata_control_normgene_exon_log2 %>% dplyr::select(-colnames(probe_annotation_core))),scale. = TRUE)
     PCAsummary <- summary(PCA)
     attributes(PCA)
  ## prcomp results
     # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
     # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
     # PCA$center # colMeans(data)
     # PCA$scale
     # PCA$x # data_centered%*%svd(data_centered)$v
  ## pcromp plots
     # plot(PCA$x[,1:2],col=exsamplecolors)
     PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
     PCA_scores$rowname <- factor(PCA_scores$rowname,levels=exsamplevel)
  ## Hotelling T2 ellipse
     Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
     Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
     Zt1sq <- Zt1*Zt1
     Zt2sq <- Zt2*Zt2
     Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
     x0 <- 0
     y0 <- 0
     a <- sqrt(PCA_eigval)[1]
     b <- sqrt(PCA_eigval)[2]
     Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

     n <- nrow(t(CELdata_pm_core_log2_df))
     p <- 2 # Because we're in 2D
     fcorrect <- (n-p)/(p*(n-1))
     Ztdat$y = Ztdat$y*fcorrect
     confF <- qf(df1=p,df2=n-p,p=0.95)
     confF <- qf(df1=p,df2=n-p,p=0.99)

     ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

     PCAplot_endogenouscontrolprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.8) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=exsamplecolors) + theme(legend.position = "none")   + ggtitle("Endogenous control probes") + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed")
     PCAplot_endogenouscontrolprobes <- papertheme(PCAplot_endogenouscontrolprobes,sizeselect=12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none") + ggtitle("All probes")
@

\begin{landscape}
<<Quality Control - PCA plot example data,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{exQC:fig26} PCA scores plot of the log2 transformed standardized example data.")>>=
#plot_grid(PCAplot_allprobes,PCAplot_bgprobes,NULL,PCAplot_bacprobes,PCAplot_polyAprobes,PCAplot_endogenouscontrolprobes,nrow=2,ncol=3)


tiff(paste0(path,"exampleQC/PCA/PCA.tiff"),width=8*dpi,height=6*dpi,res=dpi,compression="lzw")
plot_grid(PCAplot_allprobes,PCAplot_bgprobes,NULL,PCAplot_bacprobes,PCAplot_polyAprobes,PCAplot_endogenouscontrolprobes,nrow=2,ncol=3)
dev.off()

ggdraw() +  draw_image(image_read(paste0(path,"exampleQC/PCA/PCA.tiff")))
@
\end{landscape}

% Affymetrix 3'5' ratio to evaluate degradation : Affymetrix probeset sequences are generally chosen to react with approximately the last 600bp (3’ terminus) of each gene or EST target transcript[11]. However, to test transcript efficiency and possible 5’ degradation, two ‘housekeeping’ genes (GAPDH and β-actin) are each targeted at three locations along the entire gene transcript. For both of these gene targets, there is one probeset for each of the 3’-transcript tail, midtranscript, and 5’ -transcript head. By comparing the ratio of binding to the 3’ tail against the binding to the mid- and 5’ transcript, one may gain clues regarding sample transcript quality -- at least for these genes. => no longer valid since probes are no longer targeting 3' terminus but interspersed across whole gene region

\section{arrayQualityMetrics tool results}
The arrayQualityMatrics tool confirmed our conclusions and additionally indicated the Hela cell control array as an outlier based on 2 different criteria (exceptionally large sum of the distances to all other arrays and a Kolmogorov-Smirnov test statistic pointing at a significantly different array distribution compared to the distribution of the pooled data).

<<Quality Control - run arrayQualityMetricsTool,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show="hide">>=
# ArrayQualityMetricsTool
  arrayQualityMetrics(expressionset = CELdata,
  outdir = paste0(path,"QC/"),
  force = TRUE, do.logtransform = TRUE,
  intgroup = "Condition")
@










\chapter{Pre-processing: Background correction, Normalization, Summarization and RMA \label{prepros}}
There are several sources of variability (noise) in microarray experiments requiring background correction and normalization and data from individual probes need to be summarized at gene level. Each of the 3 pre-processing steps can be performed separately and sequentially in a modular approach. While each step may be optimal, the combination is not guaranteed to be optimal and errors are not propagated through the sequence of steps. Alternatively, the 3 pre-processing steps can be performed simultaneously to obtain an optimal final result.

Popular data pre-processing implementations are MAS5 and RMA. MAS are Microarray Suite is software that comes with the Affymetrix Genechips. RMA or Robust Multi-array Average consists of convolution background correction, quantile normalization and summarization based on a multi-array model fit using robust median-polish for estimation.

\section{Background correction}
Within microarrays background correction is required to deal with:
\begin{itemize}
\item Optical noise
\item Cross-hybridization (= non-specific hybridization): labeled target binds to non-complementary probe resulting in measurable intensities
\item Free biotin may attach to the array, even after washing, resulting in measurable intensities
\item Differences in probe affinities: G-C binding occurs through 3 H-bonds and is stronger compared to A-T pairing with 2 H-bonds. Probes with a large GC content may hence display a larger intensity. The relation between intensities and mRNA concentrations is confounded by the probe-affinity
\end{itemize}
Background correction aims to improve the linear relationship between the log intensities and the concentration of mRNA (cDNA). In general a background corrected intensity of probe i is given by:

\begin{align}\label{BGcorrect}
&X_{i} = Y_{i} - B{i}\\
&with\: X_{i}\: the\: background\: corrected,\: true\: intensity\: of\: probe\: i\\
&with\: Y_{i}\: the\: measured\: intensity\: for\: probe\: i\\
&with\: B_{i}\: the\: estimated\: background\: intensity\: for\: probe \:i
\end{align}

The background correction method currently available in the oligo package is the one used in RMA, which treats the PM intensities as a convolution of noise and true signal. While the noise and true signal are not known at probe-level, we can make distribution assumptions about X and B. X follows an exponential distribution and B a normal distribution. Parameters of these distributions are estimated ad-hoc by fitting distributions to the observed intensities (Figures \ref{QC:fig2} and \ref{RMAconv}).

\vspace{\fill}

<<RMA convolution explained with figure,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="400pt",out.height="400pt",fig.cap=c("\\label{RMAconv} The parameters of the normal and exponential distribution used to deconvolute the probe intensity signals are estimated ad-hoc from the observed probe intensity distributions. $\\mu$ is estimated as the mode,  $\\sigma^2$ is estimated as twice the variance in the lower tail of the distribution and  $\\gamma$ is estimated by fitting an expenonential distribution to the right tail of the observed density."),fig.pos="H">>=
mode <- getmode(CELdata_bg_core_log2_melt[CELdata_bg_core_log2_melt$Var2=="SHIME1",]$value)
varest <- 2*var(CELdata_bg_core_log2_melt[CELdata_bg_core_log2_melt[CELdata_bg_core_log2_melt$Var2=="SHIME1",]$value<mode,]$value)
L95 <- mode - 1.96*sqrt(varest)
R95 <- mode + 1.96*sqrt(varest)

log2hist <- ggplot(data=CELdata_bg_core_log2_melt %>% subset(Var2=="SHIME1"),aes(value))
log2hist <- papertheme(log2hist,sizeselect = 12) + geom_density(show.legend = FALSE, color="#756bb1FF") + xlab("Log2 probe intensity") +ylab("Density") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(color = "") + stat_density(geom="line",position="identity", size = 1, color="#756bb1FF")
d <- ggplot_build(log2hist)$data[[1]]
log2hist <- log2hist + geom_vline(aes(xintercept = mode),linetype="dashed") + geom_label(data=data.frame(x=mode,y=-0.015),aes(x=x,y=y),colour="black",label=expression(mu)) + coord_cartesian(clip = "off")
log2hist <- log2hist + geom_segment(aes(x=L95,xend=mode,y=0.08,yend=0.08),colour="black") + geom_label(data=data.frame(x=L95+0.5,y=0.15),aes(x=x,y=y),colour="black",label=as.expression(bquote(.(sprintf("%0.1f",1.96))~sigma)))
log2hist <- log2hist + geom_density(data=d%>% filter(between(x,mode,max(x))),aes(x=x,y=y),fill="purple",alpha = 0.2,stat="identity") + geom_label(data=data.frame(x=5,y=0.6),aes(x=x,y=y),colour="purple",label=expression(gamma))
log2hist

#Let r fit the model
normal <- (CELdata_bg_core_log2_melt[CELdata_bg_core_log2_melt[CELdata_bg_core_log2_melt$Var2=="SHIME1",]$value<R95,]$value)
fitdistr(normal, "normal")
sqrt(varest)
mode

exp <- (CELdata_bg_core_log2_melt[CELdata_bg_core_log2_melt[CELdata_bg_core_log2_melt$Var2=="SHIME1",]$value>R95,]$value)
fitdistr(exp, "exponential")
@

<<Background correction,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="500pt",out.height="700pt",fig.show='hide'>>=
 # Available methods
   backgroundCorrectionMethods()

 # RMA method for background correction
   CELdata_bgcorrected <- xfun::cache_rds({
   CELdata_bgcorrected <-  oligo::backgroundCorrect(CELdata_nocontrol,method="rma")},file="RDS_bgcorrection")
   class(CELdata_bgcorrected)

   CELdata_bgcorrected <- oligo::pm(CELdata_bgcorrected)
   rownames(CELdata_bgcorrected) <- paste(probenames_core,probe_annotation_core$fid,sep="_")
   CELdata_bgcorrected_log2 <- log2(CELdata_bgcorrected)
   CELdata_bgcorrected_log2_annotated <- merge(CELdata_bgcorrected_log2,probe_annotation_core,by="row.names",all=TRUE,sort=FALSE)[,-1]
   CELdata_bgcorrected_log2_annotated_melt <- reshape2::melt(CELdata_bgcorrected_log2_annotated,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
   CELdata_bgcorrected_log2_annotated_melt$variable <- factor(CELdata_bgcorrected_log2_annotated_melt$variable,levels=samplevel_nocontrol)
   CELdata_bgcorrected_log2_annotated_melt$raw <- CELdata_pm_core_log2_annotated_melt[CELdata_pm_core_log2_annotated_melt$variable!="HelaControl",]$value

 # Compare raw and background corrected intensities of background probes: correlation plot
   bgcoreffectsplot <- xfun::cache_rds({
   bgcoreffectsplot <- ggplot(data=CELdata_bgcorrected_log2_annotated_melt %>% subset(type=="control->bgp->antigenomic"),aes(x=raw,y=value)) + geom_point() + geom_abline(intercept=0,slope=1,colour='red') + facet_wrap(.~variable,ncol=3)
   bgcoreffectsplot <- papertheme(bgcoreffectsplot,sizeselect = 12) + xlab("Raw log2 intensities") + ylab("Background-corrected log2 intensities ")
   bgcoreffectsplot

   bgcoreffectsplot_strips <-  ggplot_gtable(ggplot_build(bgcoreffectsplot))
   stripr <- which(grepl('strip-t',bgcoreffectsplot_strips$layout$name))
   fills <- c("#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
   k <- 1
   for(i in stripr){
   if(length(grepl('rect',bgcoreffectsplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect', bgcoreffectsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   bgcoreffectsplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}}
   grid.draw(bgcoreffectsplot_strips)

   tiff(paste0(path,"Preprocessing/bgcorrection_corrplot.tiff"),width=8*dpi,height=8*dpi,res=dpi,compression="lzw")
   grid.draw(bgcoreffectsplot_strips)
   dev.off()

   bgcoreffectsplot_strips
   },file="RDS_bgcorrection_correlationplot")

 # Compare raw and background corrected intensities: boxplot
   for (i in 1:9){
   namei <- rownames(CELsampledata_nocontrol@data)[i]
   name = paste0(path,"Preprocessing/bgcorrection_boxplot",namei,".tiff")
   tiff(name)
   oligo::boxplot(CELdata_bgcorrected[,i], which="pm", transfo=log2, nsample=10000,ylab='Background-corrected log2 intensities',main=rownames(CELsampledata_nocontrol@data)[i],target="core")
   dev.off()}

   bgcoreffectsboxplot <- xfun::cache_rds({
   bgcoreffectsboxplot <- ggplot(CELdata_bgcorrected_log2_annotated_melt, aes(variable,value,fill = variable))
   bgcoreffectsboxplot <- papertheme(bgcoreffectsboxplot,sizeselect = 12) + geom_boxplot() + guides(fill=guide_legend(ncol=4,nrow=3)) + xlab("") + ylab("Background-corrected log2 probe intensities") + theme(legend.position = "none") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "")  + facet_wrap(~type,ncol=1,nrow=9) + scale_fill_manual(values=sample_nocontrolcolors) + scale_x_discrete(labels=sampleplotname)
   bgcoreffectsboxplot

   bgcoreffectsboxplot_strips <-  ggplot_gtable(ggplot_build(bgcoreffectsboxplot))
   stripr <- which(grepl('strip-t',bgcoreffectsboxplot_strips$layout$name))
   fills <- rev(probetypecolors)
   k <- 1
   for(i in stripr){
   if(length(grepl('rect',bgcoreffectsboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect', bgcoreffectsboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   bgcoreffectsboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}}
   grid.draw(bgcoreffectsboxplot_strips)

   tiff(paste0(path,"Preprocessing/bgcorrection_boxplot.tiff"),width=8*dpi,height=10*dpi,res=dpi,compression="lzw")
   grid.draw(bgcoreffectsboxplot_strips)
   dev.off()

   bgcoreffectsboxplot_strips
 },file="RDS_bgcorrection_boxplot")
@

<<Background correction plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.width=8,fig.height=10,out.width="500pt",out.height="700pt",fig.cap=c("\\label{BG:fig1} Biplot of the raw and background corrected intensities.","\\label{BG:fig2} Boxplot of the background-corrected log2 intensities"),fig.pos="H">>=
  # grid.draw(bgcoreffectsplot)
  # grid.newpage(recording=FALSE)
  # grid.draw(bgcoreffectsboxplot)
   ggdraw() +  draw_image(image_read(paste0(path,"Preprocessing/bgcorrection_corrplot.tiff")))
   ggdraw() +  draw_image(image_read(paste0(path,"Preprocessing/bgcorrection_boxplot.tiff")))
@

If there would be no difference between raw and background corrected data, the data points should end up on the diagonal. This is of course not the case (Figure \ref{BG:fig1}). Low intensities are strongly affected by the background subtraction since the background intensity is a small value and subtracting a small value from a small value has a much bigger impact than subtracting a small value from a high value.

\section{Normalization \label{normalization}}
Normalization across arrays is required to deal with:
\begin{itemize}
\item Technical variation:
\begin{itemize}
\item Imperfections on the array surface
\item Imperfect synthesis of the probes (probe fixation) during the array production process
\item Differences in hybridization conditions
\item Different scanning conditions
\end{itemize}
\item Biological variation:
\begin{itemize}
\item Different amounts of mRNA used for labeling and hybridization
\item Different efficiencies of reverse transcription, labeling during sample preparation or hybridization reactions
\item Reagent batch differences
\item Different laboratory conditions
\end{itemize}
\end{itemize}
Normalization removes systematic differences between the samples that are due to noise rather than true biological variability in order to make biologically meaningful conclusions about the data.

%The MAS5.0 normalization algorithm sets the trimmed mean intensity of every array to an arbitrary level (target=100). The scaling factor is a measure of the scaling applied to each individual array to bring the average intensity to this value.

Several normalization methods are available. Quantile normalization is a commonly used method assuming the same probe level intensity distribution across chips. Basically, data points are projected onto the diagonal in a QQ-plot of the intensities of the arrays being compared (Figures \ref{quantilenorm}). All arrays can be compared to one baseline array (2D), which is selected by the algorithm to represent a typical array or all arrays can be compared simultaneously (n dimensions). Note that normalization is generally performed at probe level prior to summarization.

\vspace{\fill}

<<Quantile normalization explained with figure,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="400pt",out.height="400pt",fig.cap=c("\\label{quantilenorm} The principle of Quantile Normalization in 2D."),fig.pos="H">>=
normdf <- data.frame(x=c(0,1,2,3,4,5,6),y=c(0.1,1.5,1.9,3.5,4.8,5,5.9))
normdf$xend <- (normdf$x + normdf$y)/2
normdf$yend <- (normdf$x + normdf$y)/2
papertheme(ggplot(normdf,aes(x,y))+ geom_point() +geom_abline(intercept=0,slope=1) + geom_segment(aes(xend=xend,yend=yend),color="red")+ coord_fixed(),sizeselect = 12)
@

%RMA is one of the few normalization methods that only uses the PM probes:  RMA which completely ignores the issue of non-specific binding.
% In particular, the quantile normalization assumes identical intensity profiles between the different tissues and this is probably not a valid assumption.
%not available in oligo:
%GCRMA uses probe sequence information to estimate probe affinity to non-specific binding. Each nucleotide of the probe contributes to the affinity of the probe. The contributions of each nucleotide on each position of the probes were estimated in a pilot experiment with artificial DNAs that mismatch the probes, done by the people who developed the algorithm. In this experiment there was no specific binding so the only thing was measured was non-specific binding. The data of this experiment allowed to estimate the affinities of the probes.
%GCRMA allows you to use the affinities calculated based on this reference experiment or you can let GCRMA compute probe affinities based on the signals of the negative control probes of your own microarray experiment.
%The gcrma package contains all available methods to perform GCRMA normalization.

<<Normalization,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.height=8,fig.show='hide'>>=
# Matrix to start from
   CELdata_bgcorrected <- xfun::cache_rds({
   CELdata_bgcorrected <-  oligo::backgroundCorrect(CELdata_nocontrol,method="rma")},file="RDS_bgcorrection")
   class(CELdata_bgcorrected)

# Available methods
  oligo::normalizationMethods()

# Quantile normalization
  CELdata_norm <- xfun::cache_rds({
  CELdata_norm <- oligo::normalize(CELdata_bgcorrected,target="core",method="quantile")},file="RDS_normalization")
  class(CELdata_norm)

  CELdata_norm <- oligo::pm(CELdata_norm)
  colnames(CELdata_norm) <- rownames(CELsampledata_nocontrol@data)
  rownames(CELdata_norm) <- paste(probenames_core,probe_annotation_core$fid,sep="_")
  CELdata_norm_log2 <- log2(CELdata_norm)
  CELdata_norm_log2_annotated <- merge(CELdata_norm_log2,probe_annotation_core,by="row.names",all=TRUE,sort=FALSE)[,-1]
  CELdata_norm_log2_annotated_melt <- reshape2::melt(CELdata_norm_log2_annotated,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg"))
  CELdata_norm_log2_annotated_melt$variable <- factor(CELdata_norm_log2_annotated_melt$variable,levels=samplevel_nocontrol)
  CELdata_norm_log2_annotated_melt$bgcorrect <- CELdata_bgcorrected_log2_annotated_melt$value
  CELdata_norm_log2_annotated_melt$bg <- "bg"
  CELdata_norm_log2_annotated_melt[CELdata_norm_log2_annotated_melt$type!="control->bgp->antigenomic",]$bg <- "nobg"
  CELdata_norm_log2_annotated_melt$bg <- factor(CELdata_norm_log2_annotated_melt$bg,levels=c("bg","nobg"))

# Compare background corrected and normalized intensities: correlation plot
  normeffectsplot <- xfun::cache_rds({
  normeffectsplot <- ggplot(data=CELdata_norm_log2_annotated_melt,aes(x=bgcorrect,y=value)) + geom_point() + geom_abline(intercept=0,slope=1,colour='red') + facet_wrap(.~variable,ncol=3)
  normeffectsplot <- papertheme(normeffectsplot,sizeselect = 12) + xlab("Background corrected log2 intensities") + ylab("Normalized log2 intensities ")
  #normeffectsplot

  normeffectsplot_strips <-  ggplot_gtable(ggplot_build(normeffectsplot))
  stripr <- which(grepl('strip-t',normeffectsplot_strips$layout$name))
  fills <- c("#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
  k <- 1
  for(i in stripr){
  if(length(grepl('rect',normeffectsplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', normeffectsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  normeffectsplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}
  grid.draw(normeffectsplot_strips)

  tiff(paste0(path,"Preprocessing/normalization_corrplot.tiff"),width=8*dpi,height=8*dpi,res=dpi,compression="lzw")
  grid.draw(normeffectsplot_strips)
  dev.off()

  normeffectsplot_strips
  },file="RDS_normalization_correlationplot")

# Compare raw and normalized intensities: boxplot
  for (i in 1:9){
  namei <- rownames(CELsampledata_nocontrol@data)[i]
  name = paste0(path,"Preprocessing/normalization_boxplot",namei,".tiff")
  tiff(name)
  oligo::boxplot(CELdata_norm[,i], which="pm", transfo=log2,nsample=10000,ylab='Log2 probe intensity',main=rownames(CELsampledata_nocontrol@data)[i],target="core")
  dev.off()}

  normeffectsboxplot <- xfun::cache_rds({
  normeffectsboxplot <- ggplot(CELdata_norm_log2_annotated_melt, aes(variable,value,fill = variable))
  normeffectsboxplot <- papertheme(normeffectsboxplot,sizeselect = 12) + geom_boxplot() + guides(fill=guide_legend(ncol=4,nrow=3)) + xlab("") + ylab("Normalized log2 probe intensity") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=samplecolors) + theme(legend.position="none") + facet_wrap(~type,ncol=1,nrow=9)
  #normeffectsboxplot

  normeffectsboxplot_strips <-  ggplot_gtable(ggplot_build(normeffectsboxplot))
  stripr <- which(grepl('strip-t',normeffectsboxplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for(i in stripr){
  if(length(grepl('rect',normeffectsboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', normeffectsboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  normeffectsboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}
  grid.draw(normeffectsboxplot_strips)

  tiff(paste0(path,"Preprocessing/normalization_boxplot.tiff"),width=8*dpi,height=10*dpi,res=dpi,compression="lzw")
  grid.draw(normeffectsboxplot_strips)
  dev.off()

  normeffectsboxplot_strips
  },file="RDS_normalization_boxplot")

# Compare raw and normalized intensities: histogram
  for (i in 1:9){
  namei <- rownames(CELsampledata_nocontrol@data)[i]
  name = paste0(path,"Preprocessing/normalization_histogram",namei,".tiff")
  tiff(name)
  oligo::hist(CELdata_norm[,i],transfo=identity,which='pm',target="core",nsample=10000,ylab="Normalized log2 probe intensity",main=rownames(CELsampledata_nocontrol@data)[i])
  dev.off()}

  log2hist <- xfun::cache_rds({
  log2hist <- ggplot(CELdata_norm_log2_annotated_melt,aes(value, color = variable))
  log2hist <- papertheme(log2hist,sizeselect = 12) + geom_density(show.legend = FALSE) + guides(color=guide_legend(ncol=4,nrow=3)) + xlab("Normalized log2 probe intensity") +ylab("Density") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(color = "") + scale_color_manual(values=sample_nocontrolcolors) + stat_density(geom="line",position="identity", size = 1)

  tiff(paste0(path,"Preprocessing/normalization_histogram.tiff"),width=6*dpi,height=6*dpi,res=dpi,compression="lzw")
  log2hist
  dev.off()

  log2hist
  },file="RDS_normalization_histogram")
@

<<Normalization plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.width=10,fig.height=8,out.width=c("500pt","500pt","400pt"),out.height=c("600pt","600pt","400pt"),fig.cap=c("\\label{N:fig1} Biplot of the background-corrected and normalized intensities.","\\label{N:fig2} Boxplot of the normalized log2 intensities","\\label{N:fig3} Histogram of the normalized log2 intensities"),fig.pos="H">>=
  # grid.draw(normeffectsplot)
  # grid.newpage(recording=FALSE)
  # grid.draw(normeffectsboxplot)
  # grid.newpage(recording=FALSE)
  # log2hist
  
   ggdraw() +  draw_image(image_read(paste0(path,"Preprocessing/normalization_corrplot.tiff")))
   ggdraw() +  draw_image(image_read(paste0(path,"Preprocessing/normalization_boxplot.tiff")))
   ggdraw() +  draw_image(image_read(paste0(path,"Preprocessing/normalization_histogram.tiff")))
@

After normalization, none of the samples should stand out from the rest. The different arrays should have the same (or at least a very comparable) median expression level. Also the scale of the boxes should be almost the same indicating that also the spread of the intensity values on the different arrays is comparable (Figures \ref{N:fig1}-\ref{N:fig3}).

\section{Summarization \label{summarization}}
In the pre-processing step, data is summarized at the gene/transcript level (option target = core) or probeset level. This is necessary for downstream analysis because there are multiple probes per probeset. The summary measure is a proxy for the transcript concentration or the expression value of a gene.

Since the Human Gene 2.1 ST microarrays were created as an affordable version of the `Exon' arrays by reducing the number of probes keeping only the `good' probes from the Exon arrays, probesets or exons are represented by only a few probes and summarization on this level is not recommended \cite{Klaus2016}.
%Initially on the Exon array, at least four probes were part of one “Exon”. With the thinned out “Gene” array, many probesets were made up of three or fewer probes.

Several single- and multi-chip methods exist, including the robust average (MAS), robust estimation, median polish (RMA) and plm. The robust average method calculates the average log2 intensity for all probes within a probeset excluding outlier probes. However, the parallel behavior in probe response across arrays and the relationship between concentration and expression level on each array (Figure \ref{QC:fig12}) motivates the use of multi-chip models with probe and chip response parameters. RMA makes use of such advanced additive regression models. Since there are often probes on individual arrays that behave discordantly due to non-biological causes, it is advantageous to fit the model robustly and use median polish instead of common linear regression. This is done by using the median polish algorithm to fit the more general model displayed in equation \ref{RMAmedpol} \cite{Bolstad2004}. See \url{https://mgimond.github.io/ES218/Week11a.html} for more information on the median polish algorithm. Alternatively, PLM described above (\ref{PLM}) can be used to summarize the data.

\begin{align}\label{RMAmedpol}
& y_{ijk} = \mu_{k} + \teta{jk} + \alpha{ik} + \eta{ijk}\\
& with\: i\: index\: for\: probes,\: j\: index\: for\: arrays\: and\: k\: index\: for\: probesets\\
& with\: y_{ijk}:\: a\: (pre-processed\: if\: normalization\: and\: background\: correction\: \\ & applied\: according\: to\: RMA)\: probe\: intensity\: on\: log2\: scale \\
& with\: \mu_{k}:\: the\: overall\: expression\: value \\
& with\: \teta{jk}:\: the\: array\: effect\: for\: array\: j\: (column\: effect\: in\: median\: polish)\\
& with\: \alpha{ik}:\: the\: probe\: effect\: parameter\: for\: probe\: i\: (row\: effect\: in\: median\: polish)\\
& with\: \eta{ijk}:\: an\: error\: or\: residual\: term\\
& with\: constraints:\: median(\alpha{ik})\: =\: median(\teta{jk})\: =\: median(\eta{ijk})\\
& where\: \beta_{jk}\: = \mu_{k} + \teta{jk}\\
& with\: \beta_{jk}:\: the\: log2\: expressions \\
\end{align}

\vspace{\fill}

<<Summarization,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show="hide">>=
# Available methods
  oligo::summarizationMethods()

# summarization
  CELdata_summ <- xfun::cache_rds({
  CELdata_summ <- oligo::summarize(CELdata_norm,method="medianpolish",probes=CELdata_norm_log2_annotated$fsetid)
  CELdata_summ},file="RDS_summarization")

  dim(CELdata_summ)
  length(unique(probe_annotation_core$fsetid))
  CELdata_summ_log2 <- CELdata_summ # summarized data is already log2 transformed during the summarization process
  CELdata_summ_log2_annotated <- merge(CELdata_summ_log2,gene_annotation,by="row.names",all=TRUE,sort=FALSE)[,-1]
  CELdata_summ_log2_annotated_melt <- reshape2::melt(CELdata_summ_log2_annotated,id.vars=c("man_fsetid","fsetid","chrom","type","subtype","posneg"))
  CELdata_summ_log2_annotated_melt$variable <- factor(CELdata_summ_log2_annotated_melt$variable,levels=samplevel_nocontrol)

# Compare raw and summarized intensities: boxplot
  for (i in 1:9){
  namei <- rownames(CELsampledata_nocontrol@data)[i]
  name = paste0(path,"Preprocessing/summarization_boxplot",namei,".tiff")
  tiff(name)
  oligo::boxplot(CELdata_summ[,i], which="pm", transfo=identity,nsample=10000,ylab='Log2 probe intensity',main=rownames(CELsampledata_nocontrol@data)[i],target="core") # summarized data is already log2 transformed
  dev.off()}

  summeffectsboxplot <- xfun::cache_rds({
  summeffectsboxplot <- ggplot(CELdata_summ_log2_annotated_melt, aes(variable,value,fill = variable))
  summeffectsboxplot <- papertheme(summeffectsboxplot,sizeselect = 12) + geom_boxplot() + guides(fill=guide_legend(ncol=4,nrow=3)) + xlab("") + ylab("Summarized log2 probe intensity") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=samplecolors) + theme(legend.position="none") + facet_wrap(~type,ncol=1,nrow=9)
  #summeffectsboxplot

  summeffectsboxplot_strips <-  ggplot_gtable(ggplot_build(summeffectsboxplot))
  stripr <- which(grepl('strip-t',summeffectsboxplot_strips$layout$name))
  fills <- rev(probetypecolors)
  k <- 1
  for(i in stripr){
  if(length(grepl('rect',summeffectsboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
  j <- which(grepl('rect', summeffectsboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
  summeffectsboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
  k <- k+1}}
  grid.draw(summeffectsboxplot_strips)

  tiff(paste0(path,"Preprocessing/summarization_boxplot.tiff"),width=8*dpi,height=10*dpi,res=dpi,compression="lzw")
  grid.draw(summeffectsboxplot_strips)
  dev.off()

  summeffectsboxplot_strips
  },file="RDS_summarization_boxplot")

# Compare raw and summalized intensities: histogram
  for (i in 1:9){
  namei <- rownames(CELsampledata_nocontrol@data)[i]
  name = paste0(path,"Preprocessing/summarization_histogram",namei,".tiff")
  tiff(name)
  oligo::hist(CELdata_summ[,i],transfo=identity,which='pm',target="core",nsample=10000,ylab="summalized log2 probe intensity",main=rownames(CELsampledata_nocontrol@data)[i])
  dev.off()}

  log2hist <- xfun::cache_rds({
  log2hist <- ggplot(CELdata_summ_log2_annotated_melt,aes(value, color = variable))
  log2hist <- papertheme(log2hist,sizeselect = 12) + geom_density(show.legend = FALSE) + guides(color=guide_legend(ncol=4,nrow=3)) + xlab("Summarized log2 probe intensity") +ylab("Density") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(color = "") + scale_color_manual(values=sample_nocontrolcolors) + stat_density(geom="line",position="identity", size = 1)

  tiff(paste0(path,"Preprocessing/summarization_histogram.tiff"),width=6*dpi,height=6*dpi,res=dpi,compression="lzw")
  log2hist
  dev.off()

  log2hist
  },file="RDS_summarization_histogram")
@

% The boxplot and hist methods are also implemented for ExpressionSet objects. Note that rma's
% output is in the log2 scale, so we call such methods using the argument transfo=identity, so the
% data are not transformed in any way.

<<Summarization plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.width=10,fig.height=8,out.width=c("500pt","400pt"),out.height=c("600pt","400pt"),fig.cap=c("\\label{S:fig1} Boxplot of the summarized log2 intensities.","\\label{fig:figS2} Density plot of the summarized log2 intensities."),fig.pos="H">>=
  # grid.draw(summeffectsboxplot)
  # grid.newpage(recording=FALSE)
  # log2hist
   ggdraw() +  draw_image(image_read(paste0(path,"Preprocessing/summarization_boxplot.tiff")))
   ggdraw() +  draw_image(image_read(paste0(path,"Preprocessing/summarization_histogram.tiff")))
@

\clearpage
\section{RMA}
As mentioned before background subtraction, quantile normalization and summarization via median polish can be combined through RMA. RMA was performed at the gene level  (target = core) and after omission of the Hela cell control sample.

% signature(object = "ExpressionFeatureSet") When used on an ExpressionFeatureSet object, rma produces summaries at the probeset level (as defined in the CDF or NDF files, depending on the manufacturer).
% signature(object = "GeneFeatureSet") When applied to a GeneFeatureSet object, rma can
% produce summaries at different levels: probeset (as defined in the PGF) and ’core genes’
% (as defined in the core.mps file). To determine the level for summarization, use the target
% argument.

%TAC was run with transcript (= core) option

The RMA algorithm performs
\begin{itemize}
\item Background correction to correct for spatial variation within individual arrays: a background-corrected intensity is calculated for each PM probe in such a way that all background corrected intensities are positive
\item Log transformation to improve the distribution of the data: the base-2 logarithm of the background corrected intensity is calculated for each probe. The log transformation will make the data less skewed and more normally distributed and provide an equal spread of up- and down-regulated expression ratios
\item Quantile normalization to correct for variation between the arrays: equalizes the data distributions of the arrays and make the samples completely comparable
\item Probe normalization to correct for variation within probesets: equalizes the behavior of the probes between the arrays and combines normalized data values of probes from a probeset into a single value for the whole probeset
\end{itemize}

%An alternative to quantile normalization would be the vsn algorithm,that performs background correction and normalization by robustly shifting and scaling intensity values within arrays before log-transforming them. This is less “severe” than quantile normalization \cite{Klaus2016}.












\chapter{Quality Control of the RMA pre-processed data \label{QCpostproc}}
Quality was inspected after RMA processing with the same QC tools as before (array images, box plots, density plots, model fit residual/weight plots, MA plots, RLE, NUSE, DABG, PCA).

\section{Distribution of the RMA pre-processed intensities}
After normalization, the distribution of the samples should be homogeneous. The different arrays should have a very comparable median expression level and the scale of the boxes should be very comparable indicating that the spread of the intensity values on the different arrays is equalized. Samples blank3 and SHIME\_LGG1 still stand out from the other samples (Figures \ref{RMAQC:fig2}-\ref{RMAQC:fig3}), displaying a slightly higher median expression and smaller standard deviations. Most of the background probes shifted to lower expression values after RMA pre-processing, but some probes retained higher signals resulting in a bimodal distribution of the background probes post-RMA processing. The blank3 and SHIME\_LGG1 samples have higher medians and spreads, and therefore do not align well with the other samples (Figures \ref{RMAQC:fig2bg}-\ref{RMAQC:fig3bg}). The reduced background signal also affected the negative control samples and is reflected in decreased median signal intensities (Figures \ref{RMAQC:fig5} and \ref{RMAQC:fig6}). While the endogenous and bac spike positive controls have comparable distributions with the exception of samples blank3 and SHIME\_LGG1, the polyA spike still shows a high level of between-array variability (also within replicate arrays). Different ratios of the spike-in compared to the input RNA amount may explain the observed differences. The $R^{2}$ of the linear regression model of the RMA pre-processed signal intensities in function of the spike-in concentration improved for all microarrays (Figures \ref{RMAQC:fig7}-\ref{RMAQC:fig10}).

% RMA signal linearized + CV calculated per probe st
\clearpage
\subsection{Distribution of the RMA pre-processed all-transcript intensities}
<<RMA Quality Control - Histograms of log2 intensity,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="300pt",out.height="300pt",fig.cap=c("\\label{RMAQC:fig2} Density plot of the transcript intensities after RMA pre-processing."),fig.pos="H">>=
   log2hist <- xfun::cache_rds({
   # Perfect matches
   ## Histogram of log2 intensities
   set.seed(123)
   for (i in 1:9){
   namei <- rownames(CELsampledata_nocontrol@data)[i]
   name = paste0(path,"RMA_QC/Distribution/histogram",namei,".tiff")
   tiff(name)
   oligo::hist(CELdata_RMA_core[,i],transfo=identity,nsample=10000,target="core",ylab='Density',xlab='Transcript intensity after RMA pre-processing',main=rownames(CELsampledata_nocontrol@data)[i])
   dev.off()}

   log2hist <- ggplot(CELdata_RMA_core_annotated_melt,aes(value, color = variable))
   log2hist <- papertheme(log2hist,sizeselect = 12) + geom_density(show.legend = FALSE) + guides(color=guide_legend(ncol=4,nrow=3)) + xlab("Transcript intensity after RMA pre-processing") +ylab("Density") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(color = "") + scale_color_manual(values=sample_nocontrolcolors) + stat_density(geom="line",position="identity", size = 1)

   tiff(paste0(path,"RMA_QC/Distribution/histogram.tiff"),width=6*dpitiff,height=6*dpitiff,res=dpitiff,compression="lzw")
   log2hist
   dev.off()

   log2hist

 },file="RDS_RMA_histogram_pm")

   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/histogram.tiff")))
 @

\vspace{\fill}

\begin{landscape}
 <<RMA Quality Control - Boxplots of log2 intensity,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{RMAQC:fig3} Box plots of the transcript intensities after RMA pre-processing."),fig.pos="H">>=
 log2box <- xfun::cache_rds({
 # Perfect matches
   ## Boxplot of log2 intensities
   for (i in 1:9){
   namei <- rownames(CELsampledata_nocontrol@data)[i]
   name = paste0(path,"RMA_QC/Distribution/boxplot",namei,".tiff")
   tiff(name)
   oligo::boxplot(CELdata_RMA_core[,i],transfo=identity, nsample=10000,target="core",ylab='Transcript intensity after RMA pre-processing',main=rownames(CELsampledata_nocontrol@data)[i])
   dev.off()}

   log2box <- ggplot(CELdata_RMA_core_annotated_melt, aes(variable,value,fill = variable))
   log2box <- papertheme(log2box,sizeselect = 12) + geom_boxplot() + guides(fill=guide_legend(ncol=4,nrow=3)) + xlab("") +ylab("Transcript intensity after RMA pre-processing") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=sample_nocontrolcolors) + theme(legend.position="none") + scale_x_discrete(labels=sampleplotname_nocontrol)

   tiff(paste0(path,"RMA_QC/Distribution/boxplot.tiff"),width=8*dpitiff,height=4*dpitiff,res=dpitiff,compression="lzw")
   log2box
   dev.off()

   log2box

 },file="RDS_RMA_boxplot_pm")

   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplot.tiff")))
 @
\end{landscape}

\subsection{Distribution of the RMA pre-processed background transcript intensities}
<<RMA Quality Control - Histograms of log2 intensity background probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="400pt",out.height="400pt",fig.cap=c("\\label{RMAQC:fig2bg} Density plot of the background probe intensities after RMA pre-processing."),fig.pos="H">>=
 log2hist <- xfun::cache_rds({
   log2hist <- ggplot(CELdata_RMA_core_annotated_melt_bg,aes(value, color = variable))
   log2hist <- papertheme(log2hist,sizeselect = 12) + geom_density(show.legend = FALSE) + guides(color=guide_legend(ncol=4,nrow=3)) + xlab("Intensity of the background probes after RMA pre-processing") +ylab("Density") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(color = "") + scale_color_manual(values=samplecolors) + stat_density(geom="line",position="identity", size = 1)

   tiff(paste0(path,"RMA_QC/Distribution/histogram_bg.tiff"),width=6*dpitiff,height=6*dpitiff,res=dpitiff,compression="lzw")
   log2hist
   dev.off()

   log2hist

 },file="RDS_RMA_histogram_bg")

   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/histogram.tiff")))
 @

\begin{landscape}
<<RMA Quality Control - Boxplots of log2 intensity background probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{RMAQC:fig3bg} Box plots of the background probe log2 intensities after RMA pre-processing."),fig.pos="H">>=
 log2box <- xfun::cache_rds({
   ## Boxplot of log2 intensities
   log2box <- ggplot(CELdata_RMA_core_annotated_melt_bg, aes(variable,value,fill = variable))
   log2box <- papertheme(log2box,sizeselect = 12) + geom_boxplot() + guides(fill=guide_legend(ncol=4,nrow=3)) + xlab("") +ylab("Intensity of the background probes after RMA pre-processing") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=sample_nocontrolcolors) + theme(legend.position="none") + scale_x_discrete(labels=sampleplotname_nocontrol)

   tiff(paste0(path,"RMA_QC/Distribution/boxplot_bg.tiff"),width=8*dpitiff,height=4*dpitiff,res=dpitiff,compression="lzw")
   log2box
   dev.off()

   log2box

 },file="RDS_RMA_boxplot_bg")

   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplot_bg.tiff")))
 @
\end{landscape}

\subsection{Distribution of the RMA pre-processed control transcript intensities}
<<RMA Quality Control - control probes vs main probes log2 intensity,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,fig.show='hide'>>=
 controlsplot_strips2 <- xfun::cache_rds({
 # Box plots of the control probe log2 intensities per control type
   controlsplot <- ggplot(CELdata_RMA_core_annotated_melt,aes(x=variable,y=value)) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Intensity after RMA pre-processing")  + facet_wrap(~type,scales = "free_y",nrow=9,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=sample_nocontrolcolors)
   controlsplot <- papertheme(controlsplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 0),legend.position = "none") + guides(fill=guide_legend(nrow=3,ncol=4)) + scale_x_discrete(labels=sampleplotname_nocontrol)

   controlsplot_strips <-   ggplot_gtable(ggplot_build(controlsplot))
   stripr <- which(grepl('strip-t',controlsplot_strips$layout$name))
   fills <- rev(probetypecolors)
   k <- 1
   for (i in stripr){
   j <- which(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   controlsplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}
   controlsplot_strips2 <- controlsplot_strips

   tiff(paste0(path,"RMA_QC/Distribution/boxplots_controls_perprobetype.tiff"),width=8*dpi,height=11*dpi,res=dpi,compression="lzw")
   grid.draw(controlsplot_strips)
   dev.off()

   controlsplot_strips2

 },file="RDS_RMA_control_mainprobes2")


 controlsplot_strips3 <- xfun::cache_rds({
 # Box plots of the control probe log2 intensities per sample type
   controlsplot <- ggplot(CELdata_RMA_core_annotated_melt,aes(x=type,y=as.numeric(as.character(value)))) + geom_boxplot(aes(fill=type,group=type)) + labs(x="",y="Intensity after RMA pre-processing")  + facet_wrap(~variable,drop=TRUE,scales = "free_y",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x))  + scale_fill_manual(values=probetypecolors)
   controlsplot <- papertheme(controlsplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 90)) + guides(color=guide_legend(nrow=3,ncol=4))+ labs(color = "") + theme(legend.position = "none")

   controlsplot_strips <-   ggplot_gtable(ggplot_build(controlsplot))
   stripr <- which(grepl('strip-t',controlsplot_strips$layout$name))
   rev(samplecolors)
   fills <- c("#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
   k <- 1
   for (i in stripr){
   if(length(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect', controlsplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   controlsplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}}
   controlsplot_strips3 <- controlsplot_strips

   tiff(paste0(path,"RMA_QC/Distribution/boxplots_controls_perarray.tiff"),width=8*dpi,height=8*dpi,res=dpi,compression="lzw")
   grid.draw(controlsplot_strips)
   dev.off()

   controlsplot_strips3

 },file="RDS_RMA_control_mainprobes3")
 @

<<RMA Quality Control - control probes vs main probes log2 intensity plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="600pt",fig.cap=c("\\label{RMAQC:fig5} Box plots of the intensities of all control probes after RMA pre-processing within the probesets corresponding to the spike-in positive controls (control$\\rightarrow$affx, control$\\rightarrow$affx$\\rightarrow$bac\\_spike, control$\\rightarrow$affx$\\rightarrow$polya\\_spike) and negative controls (control$\\rightarrow$affx$\\rightarrow$ercc, control$\\rightarrow$bgp$\\rightarrow$antigenomic,normgene$\\rightarrow$intron) faceted by the controls.","\\label{RMAQC:fig6} Box plots of the intensities of all control probes after RMA pre-processing within the probesets corresponding to the spike-in positive controls (control$\\rightarrow$affx, control$\\rightarrow$affx$\\rightarrow$bac\\_spike, control$\\rightarrow$affx$\\rightarrow$polya\\_spike) and negative controls (control$\\rightarrow$affx$\\rightarrow$ercc, control$\\rightarrow$bgp$\\rightarrow$antigenomic,  normgene$\\rightarrow$intron) faceted by the samples."),fig.scap=c("Box plots of the intensities of all control probes after RMA pre-processing within the probesets corresponding to the spike-in positive and negative controls faceted by the controls.","Box plots of the intensities of all control probes after RMA pre-processing within the probesets corresponding to the spike-in positive and negative controls faceted by the samples."),fig.pos="H">>=
   #grid::grid.draw(controlsplot_strips2)
   #grid.newpage(recording = FALSE)
   #grid::grid.draw(controlsplot_strips3)
   #grid.newpage(recording = FALSE)
 
  ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplots_controls_perprobetype.tiff")))
  ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplots_controls_perarray.tiff")))
@


\vspace{\fill}

\begin{landscape}
\subsubsection{Distribution of the RMA pre-processed bac and polyA transcript intensities}
 <<RMA Quality Control - bac affx type control probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
 affx_bacplot_strips1 <- xfun::cache_rds({
 # Look at intensities of affx_bac per array
   affx_bacplot  <- ggplot(CELdata_RMA_core_annotated_affx_bac_melt,aes(x=variable,y=value)) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Intensity after RMA pre-processing")  + facet_wrap(~type,scales = "free_y",nrow=8,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=sample_nocontrolcolors) + scale_x_discrete(labels=sampleplotname_nocontrol)
   affx_bacplot  <- papertheme(affx_bacplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 0),legend.position = "none") + guides(fill=guide_legend(nrow=3,ncol=4))

   affx_bacplot_strips <-ggplot_gtable(ggplot_build(affx_bacplot ))
   stripr <- which(grepl('strip-t',affx_bacplot_strips$layout$name))
   fills <- "#00688b66"
   k <- 1
   for (i in stripr){
   j <- which(grepl('rect', affx_bacplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   affx_bacplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}
   affx_bacplot_strips1 <- affx_bacplot_strips

   tiff(paste0(path,"RMA_QC/Distribution/boxplot_affx_bacgenes_perarray.tiff"),width=8*dpi,height=4*dpi,res=dpi,compression="lzw")
   grid.draw(affx_bacplot_strips)
   dev.off()

   affx_bacplot_strips1

 },file="RDS_RMA_control_baxprobes1")


 affx_bacplot_strips2 <- xfun::cache_rds({
   CELdata_RMA_core_annotated_affx_bac_melt_regression <- data.frame(CELdata_RMA_core_annotated_affx_bac_melt %>%  subset(grepl("^AFFX",subtype)))
   CELdata_RMA_core_annotated_affx_bac_melt_regression$concentration <- as.numeric(mapvalues(CELdata_RMA_core_annotated_affx_bac_melt_regression$subtype,from=stdcurvebac$subtype,to=stdcurvebac$conc))
   equatons <- lm_eqn(CELdata_RMA_core_annotated_affx_bac_melt_regression,"value","concentration","variable")
   #equations$x <- "AFFX-r2-Ec-bioD-3_at"
   equations$x <- 50
   equations$y <- 15

   # affx_bacplot <- ggplot(CELdata_RMA_core_annotated_affx_bac_melt > subset(grepl("^AFFX",subtype)),aes(x=subtype,y=as.numeric(as.character(value)))) + geom_point(aes(color=subtype,group=subtype)) + labs(x="",y="Log2 probe intensity")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_color_manual(values=affx_bac_colors)
   # affx_bacplot <- papertheme(affx_bacplot,sizeselect = 8)+theme(axis.text.x = element_text(angle = 90)) + guides(color=guide_legend(nrow=3,ncol=4))  + labs(color = "") + theme(axis.text.x = element_blank())
   # affx_bacplot <- affx_bacplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b66",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b66",parse=T) + ylim(0,15)

   affx_bacplot <- ggplot(CELdata_RMA_core_annotated_affx_bac_melt_regression,aes(x=concentration,y=as.numeric(as.character(value)))) + geom_point(aes(color=factor(subtype))) + labs(x="Bac spike concentration (pm)",y="Intensity after RMA pre-processing")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_color_manual(values=affx_bac_colors)
   affx_bacplot <- papertheme(affx_bacplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 0)) + guides(color=guide_legend(nrow=3,ncol=4))  + labs(color = "") + theme(legend.position = "none")
   affx_bacplot <- affx_bacplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b66",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b66",parse=T) + ylim(0,15)

   affx_bacplot_strips <-   ggplot_gtable(ggplot_build(affx_bacplot))
   stripr <- which(grepl('strip-t',affx_bacplot_strips$layout$name))
   rev(samplecolors)
   fills <- c("#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
   k <- 1
   for (i in stripr){
   if(length(grepl('rect', affx_bacplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect', affx_bacplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   affx_bacplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}
   }
   affx_bacplot_strips2 <- affx_bacplot_strips

   tiff(paste0(path,"RMA_QC/Distribution/boxplot_affx_bacgenes_persubtype.tiff"),width=11*dpi,height=13*dpi,res=dpi,compression="lzw")
   grid.draw(affx_bacplot_strips2)
   dev.off()

   affx_bacplot_strips2
   
   },file="RDS_RMA_control_baxprobes2")

   # grid.draw(affx_bacplot_strips1)
   # grid.newpage(recording="FALSE")
   # grid.draw(affx_bacplot_strips2)
 @

 <<RMA Quality Control - bac affx type control probes plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{RMAQC:fig7} Intensities of all probes after RMA pre-processing within the probesets corresponding to the bacterial Affymetrix spike-in faceted by the samples. "),fig.pos="H">>=
  ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplot_affx_bacgenes_perarray.tiff")))
 @
\end{landscape}

 <<RMA Quality Control - bac affx type control probes plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="700pt",fig.cap=c("\\label{RMAQC:fig8} Intensities of the BioB, BioC, BioD and Cre bacterial Affymetrix spike-in probes after RMA pre-processing faceted by the samples."),fig.pos="H">>=
  ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplot_affx_bacgenes_persubtype.tiff")))
 @


<<RMA Quality Control - polyA affx type control probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE>>=
 affx_polyAplot_strips1 <- xfun::cache_rds({
 # Look at intensities of affx_polyA per array
   affx_polyAplot  <- ggplot(CELdata_RMA_core_annotated_polyA_melt,aes(x=variable,y=value)) + geom_boxplot(aes(fill=variable,group=variable)) + labs(x="",y="Intensity after RMA pre-processing")  + facet_wrap(~type,scales = "free_y",nrow=8,ncol=1) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=sample_nocontrolcolors) + scale_x_discrete(labels=sampleplotname_nocontrol)
   affx_polyAplot  <- papertheme(affx_polyAplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 0),legend.position = "none") + guides(fill=guide_legend(nrow=3,ncol=4))

   affx_polyAplot_strips <-   ggplot_gtable(ggplot_build(affx_polyAplot))
   stripr <- which(grepl('strip-t',affx_polyAplot_strips$layout$name))
   fills <- "#00688b33"
   k <- 1
   for (i in stripr){
   j <- which(grepl('rect', affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}
   affx_polyAplot_strips1 <- affx_polyAplot_strips

   tiff(paste0(path,"RMA_QC/Distribution/boxplot_affx_polyAgenes_perarray.tiff"),width=8*dpi,height=4*dpi,res=dpi,compression="lzw")
   grid.draw(affx_polyAplot_strips)
   dev.off()

   affx_polyAplot_strips1

 },file="RDS_RMA_control_polyaprobes1")


 affx_polyAplot_strips2 <- xfun::cache_rds({
    CELdata_RMA_core_annotated_polyA_melt_AFFXonly <- CELdata_RMA_core_annotated_polyA_melt  %>% subset(grepl("^AFFX",subtype))
   CELdata_RMA_core_annotated_polyA_melt_AFFXonly$subtype <- factor(CELdata_RMA_core_annotated_polyA_melt_AFFXonly$subtype,levels=rev(polyAlevel))

    CELdata_RMA_core_annotated_polyA_melt_AFFXonly_regression <- data.frame(CELdata_RMA_core_annotated_polyA_melt_AFFXonly  %>%  subset(grepl("^AFFX",subtype)))
   CELdata_RMA_core_annotated_polyA_melt_AFFXonly_regression$concentration <- as.numeric(as.character(mapvalues(CELdata_RMA_core_annotated_polyA_melt_AFFXonly_regression$subtype,from=stdcurvepolyA$subtype,to=stdcurvepolyA$conc)))
   equations <- lm_eqn(CELdata_RMA_core_annotated_polyA_melt_AFFXonly_regression,"value","concentration","variable")
   equations$x <- 1/12500
   equations$y <- 14

   affx_polyAplot <- ggplot(CELdata_RMA_core_annotated_polyA_melt_AFFXonly_regression,aes(x=concentration,y=as.numeric(as.character(value)))) + geom_point(aes(color=subtype,group=subtype)) + labs(x="",y="Intensity after RMA pre-processing")  + facet_wrap(~variable,drop=TRUE,scales = "free",ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_color_manual(values=rev(affx_polyA_colors)) + scale_x_continuous(breaks=unique(CELdata_RMA_core_annotated_polyA_melt_AFFXonly_regression$concentration),labels=c("1/6667","1/100000","1/50000","1/25000","0"))
   affx_polyAplot <- papertheme(affx_polyAplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=0.5)) + guides(color=guide_legend(nrow=6,ncol=5,reverse=TRUE)) + labs(color = "") + theme(legend.position = "none")
   affx_polyAplot <- affx_polyAplot  + geom_smooth(method = "lm", se=TRUE, aes(group=type),colour="#00688b",fill="#00688b66",linetype="solid",size=0.5) + geom_text(data=equations,aes(x=x,y=y,label=equation),color="#00688b66",parse=T) + ylim(0,15)


   affx_polyAplot_strips <-   ggplot_gtable(ggplot_build(affx_polyAplot))
   stripr <- which(grepl('strip-t',affx_polyAplot_strips$layout$name))
   rev(samplecolors)
   fills <- c("#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
   k <- 1
   for (i in stripr){
   if(length(grepl('rect', affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect', affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   affx_polyAplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}}
   affx_polyAplot_strips2 <- affx_polyAplot_strips

   tiff(paste0(path,"RMA_QC/Distribution/boxplot_affx_polyAgenes_persubtype.tiff"),width=11*dpi,height=13*dpi,res=dpi,compression="lzw")
   grid.draw(affx_polyAplot_strips)
   dev.off()

   affx_polyAplot_strips2

 },file="RDS_RMA_control_polyaprobes")


   # grid.draw(affx_polyAplot_strips1)
   # grid.newpage(recording="FALSE")
   # grid.draw(affx_polyAplot_strips2)
 @

\begin{landscape}
<<RMA Quality Control - polyA affx type control probes plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{RMAQC:fig9} Intensities of all probes after RMA pre-processing within the probesets corresponding to the polyA Affymetrix spike-in faceted by the samples."),fig.pos="H">>=
   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplot_affx_polyAgenes_perarray.tiff")))
 @
\end{landscape}

<<RMA Quality Control - polyA affx type control probes plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="700pt",fig.cap=c("\\label{RMAQC:fig10} Intensities of all probes after RMA pre-processing within the probesets corresponding to the polyA Affymetrix spike-in faceted by the samples."),fig.pos="H">>=
   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplot_affx_polyAgenes_persubtype.tiff")))
 @



\vspace{\fill}

\clearpage

\subsubsection{Distribution of the RMA pre-processed housekeeping gene transcript intensities}
<<RMA Quality Control - housekeeping gene probes log2 intensity,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.show="hide">>=
 housekeepingplot_strips1 <- xfun::cache_rds({
 # Look at a specific probeset ID (corresponding to a gene of interest): boxplot
   housekeepingplot <- ggplot(CELdata_RMA_housekeeping_melt,aes(x=variable,y=as.numeric(as.character(value)))) + geom_point(aes(color=variable,group=variable)) + labs(x="",y="Intensity of the housekeeping gene transcripts after RMA pre-processing")  + facet_wrap(~genename,scales = "free_y",nrow=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_color_manual(values=sample_nocontrolcolors) + scale_x_discrete(labels=sampleplotname_nocontrol)
   housekeepingplot <- papertheme(housekeepingplot,sizeselect = 12)+theme(axis.text.x = element_text(angle = 0),legend.position = "none") + guides(color=guide_legend(nrow=3,ncol=4))  + labs(color = "")

   housekeepingplot_strips <-   ggplot_gtable(ggplot_build(housekeepingplot))
   stripr <- which(grepl('strip-t',housekeepingplot_strips$layout$name))
   rev(samplecolors)
   fills <- housekeepingcolors
   k <- 1
   for (i in stripr){
   if(length(grepl('rect', housekeepingplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect', housekeepingplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   housekeepingplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}
   }
   housekeepingplot_strips1 <- housekeepingplot_strips

   tiff(paste0(path,"RMA_QC/Distribution/boxplot_housekeepinggenesperarray.tiff"),width=7*dpi,height=9*dpi,res=dpi,compression="lzw")
   grid.draw(housekeepingplot_strips)
   dev.off()

   housekeepingplot_strips1

 },file="RDS_RMA_housekeeping1")
 @

<<RMA Quality Control - housekeeping gene probes log2 intensity plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{RMAQC:fig11} Intensities of all probes after RMA pre-processing within the probesets corresponding to the housekeeping genes ACTB, GAPHD and HMBS."),fig.pos="H">>=
   #grid.draw(housekeepingplot_strips1)
   #grid.newpage(recording="FALSE")
   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplot_housekeepinggenesperarray.tiff")))
@

\vspace{\fill}

\section{ROC curves}
 RMA pre-processing increased the AUC values of ROC curves assessing the predictive value of the log2 probe intensities for classification of the negative and positive control samples. The AUC value increased from around 0.8 to 0.86/0.87 for most microarrays, except for sample Blank3 and SHIME\_LGG1, which increased from 0.77/0.78 to 0.82 (Figures \ref{RMAQC:fig14} and \ref{RMAQC:fig15}).
 
 \vspace{\fill}

<<RMA Quality Control - ROC curves,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="650pt",fig.cap=c("\\label{RMAQC:fig14} Density plot of the RMA pre-processed intensities for positive and negative controls.","\\label{RMAQC:fig15} ROC curves of the RMA pre-processed data."),fig.pos="H">>=
 # perform ROC curves for all types of probes: https://cran.r-project.org/web/packages/plotROC/vignettes/examples.html
 densplot <- xfun::cache_rds({
   densplot <- ggplot()+ geom_density(data=ROCcontrol_RMA_melt,aes(value,fill=posneg)) + facet_wrap(~variable,ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(name="",labels=c("Negative control","Positive control"),values=posnegcolors) + xlab("") + ylab("Density")
   densplot <- papertheme(densplot,sizeselect = 12)

   densplot_strips <- ggplot_gtable(ggplot_build(densplot))
   stripr <- which(grepl('strip-t',densplot_strips$layout$name))
   fills <- c("#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
   k <- 1
   for (i in stripr){
   if(length(grepl('rect',densplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect',densplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   densplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}
 }

   tiff(paste0(path,"RMA_QC/ROC_curves/densityplots_posvsnegcontrols.tiff"),width=8*dpi,height=10*dpi,res=dpi,compression="lzw")
   grid.draw(densplot_strips)
   dev.off()

   densplot_strips

 },file="RDS_RMA_rocdens")


 rocplot <- xfun::cache_rds({
   rocplot <- ggplot() + geom_roc(data=ROCcontrol_RMA_melt, aes(m = value, d = posneg),n.cuts=50,labels=FALSE) + facet_wrap(~variable,ncol=3)
   rocplot_AUC <- round(calc_auc(rocplot)$AUC,2)
   rocplot_AUC <- data.frame(variable=factor(samplevel_nocontrol),AUC=rocplot_AUC,AUClabel=paste("AUC = ",rocplot_AUC,sep=" "))
   rocplot <- rocplot + geom_text(data=rocplot_AUC,aes(x=0.25,y=0.95,label = AUClabel))
   rocplot <- rocplot + style_roc() + geom_rocci(fill="pink")+ scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_x_continuous(labels=function(x) sprintf("%.2f", x))

   rocplot_strips <- ggplot_gtable(ggplot_build(rocplot))
   stripr <- which(grepl('strip-t',rocplot_strips$layout$name))
   fills <- c("#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
   k <- 1
   for (i in stripr){
   if(length(grepl('rect',rocplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect',rocplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   rocplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}
 }

   tiff(paste0(path,"RMA_QC/ROC_curves/ROCplots.tiff"),width=6*dpi,height=8*dpi,res=dpi,compression="lzw")
   grid.draw(rocplot_strips)
   dev.off()

   rocplot_strips

 },file="RDS_RMA_roc")

# 
#  grid.draw(densplot)
#  grid.newpage(recording=FALSE)
#  grid.draw(rocplot)
 ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/ROC_curves/densityplots_posvsnegcontrols.tiff")))
 ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/ROC_curves/ROCplots.tiff")))
 @


\section{MA plots}
 Compared to the raw intensities, a more symmetric and even spread of the data is observed indicating that the dependence of the variability on the average expression level is less strong than before normalization. The loess fit coincides with the M=0 line for most samples, except Blank3 and SHIME\_LGG1 (Figure \ref{RMAQC:fig22}).

<<RMA Quality Control - MA plots,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.width=10,fig.height=8,fig.show='hide'>>=
 Microarray_ALL <- xfun::cache_rds({
   for (i in 1:9){
   namei <- rownames(CELsampledata_nocontrol@data)[i]
   name =  paste0(path,"RMA_QC/MAplots/MAplot",namei,".tiff")
   tiff(name)
   oligo::MAplot(CELdata_RMA_core,which=i, transfo=identity) # ,plotFun=plot to obtain usual plot without smoothscatter
   dev.off()
   ploti <- image_read(paste0(path,"RMA_QC/MAplots/MAplot",namei,".tiff"))
   ploti <- ggdraw() +  draw_image(ploti)
   ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
   assign(paste0("MAplot",namei),ploti)
   }

   Microarray_ALL <- plot_grid(MAplotBlank1,MAplotBlank2,MAplotBlank3,MAplotSHIME1,MAplotSHIME2,MAplotSHIME3,MAplotSHIME_LGG1,MAplotSHIME_LGG2,MAplotSHIME_LGG3,nrow=3,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.33,0.33,0.33))

   tiff(paste0(path,"RMA_QC/MAplots/MAplot_ALL.tiff"),width=10*dpitiff,height=10*dpitiff,res=dpitiff,compression="lzw")
   Microarray_ALL
   dev.off()

   Microarray_ALL

 },file="RDS_RMA_MAplot")
@

<<RMA Quality Control - MA plots plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="550pt",fig.cap=c("\\label{RMAQC:fig22} MAplots."),fig.pos="H">>=
   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/MAplots/MAplot_ALL.tiff")))
@


\section{PA calls \label{RMA_pacall}}
To the best of our knowledge, functions to perform presence/absence calling for RMA pre-processed data at transcript level are not available (except in the xps package). We implemented Wilcoxon signed rank-based gene expression presence/absence detection to give an indication about which genes are not expressed in the entire dataset. The following hypotheses were considered:

\begin{align}
H_0:&PM\: intensity <= BG\: intensity \\
H_1:&PM\: intensity > BG\: intensity
\end{align}

Note that use of a global universal background estimate for all probes is not acceptable and results in a large distribution of errors in a PLM type of model. Instead, background estimates of probes with similar GC content as the probe to be analyzed (GC-bins) performed equally good as the mismatch probe methods in earlier versions of Affymetrix arrays. Therefore, the expression of all probes corresponding to a gene/transcript were compared to background probes with a similar GC count.

\vspace{\fill}

<<RMA Quality Control - PA calls - intensity probes compared to BG,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=

 pacall_RMA_TSDABG <- xfun::cache_rds({
 TSDABG <- readRDS(file=paste0(path,"TSDABG_kim2"))
 TSDABG
  },file="RDS_RMA_TSDABG")
 pacall_RMA_TSDABG <- data.frame(pacall_RMA_TSDABG)

 pacall_RMA_TSDABG_pval <- reshape2::dcast(na.omit(pacall_RMA_TSDABG),fsetid~variable,value.var='pvalue')




 # in byobu modus in mobaxterm:
 # P-values
 # pacall_RMA_TSDABG <- xfun::cache_rds({
 # TSDABG <- data.frame()
 #
 # TSDABG <- foreach(i = 1:length(unique(CELdata_RMA_core_annotated_melt$fsetid)), .combine=rbind,.packages=c("doSNOW")) :
 #   foreach(j = 1:9, .combine=rbind,.packages="dplyr") dopar {
 #       jname <- as.character(unique(CELdata_RMA_core_annotated_melt$variable)[j])
 #       iname <- as.integer(unique(CELdata_RMA_core_annotated_melt$fsetid)[i])
 #       print(paste0(jname,"_",iname,"_",i))
 #       if(iname in unique(CELdata_RMA_core_annotated_melt[CELdata_RMA_core_annotated_melt$bg!="bg",]$fsetid)){
 #         BG_GCbin <- GCcontent_core_annotated > subset(fsetid==iname)
 #         BG_GCbin_mean <- mean(as.numeric(BG_GCbin$GCcontent))
 #         BG_GCbin_median<- median(as.numeric(BG_GCbin$GCcontent))
 #         BG_GCbin_LT <- min(BG_GCbin_median,BG_GCbin_mean)-1
 #         BG_GCbin_UT <- max(BG_GCbin_median,BG_GCbin_mean)+1
 #
 #         BG_GCbin_probes <- GCcontent_core_annotated  > subset(type=="control->bgp->antigenomic") > subset(GCcontent<=BG_GCbin_UT) > subset(GCcontent>=BG_GCbin_LT)
 #
 #         CELdata_norm_core_annotated_melt_ij <- CELdata_norm_log2_annotated_melt > subset(fsetid==iname|fsetid in BG_GCbin_probes$fsetid) > subset(variable==jname)
 #         pval_pair <- na.omit(reshape2::melt(tibble::rownames_to_column(data.frame(pairwise.wilcox.test(as.numeric(as.character(CELdata_norm_core_annotated_melt_ij$value)),CELdata_norm_core_annotated_melt_ij$bg,paired=FALSE,p.adjust.method = "holm",alternative="greater")$p.value)),id.vars="rowname"))
 #         pval_pair$variable <-gsub("X","",pval_pair$variable)
 #        TSDABGtemp <- c(iname,pval_pair$value,"nobg",jname)
 #       }else{TSDABGtemp <- c(NA,NA,NA,NA)}
 #        TSDABGtemp
 #   }
 # colnames(TSDABG) <- c("fsetid","pvalue","bg","variable")
 # TSDABG
 # },file="RDS_RMA_TSDABG")





 # Parallelize tasks
 # detectCores()
 # cl <- parallel::makeCluster(9,outfile="")
 # registerDoSNOW(cl)
 # stopCluster(cl)

 # old method on RMA summarized values -> looks at triplicates of arrays only and not individual arrays because you need replicates to run the WSR on
 # for(i in unique(CELdata_RMA_core_annotated_melt[CELdata_RMA_core_annotated_melt$bg!="bg",]$fsetid)){
 # CELdata_RMA_core_annotated_melt$Condition <- mapvalues(as.character(CELdata_RMA_core_annotated_melt$variable),from=metadata_nocontrol$SampleName,to=as.character(metadata_nocontrol$Condition))
 #
 # for(j in unique(CELdata_RMA_core_annotated_melt$variable)){
 #       CELdata_RMA_core_annotated_melt_ij <- CELdata_RMA_core_annotated_melt > subset(fsetid==i|bg=="bg") > subset(condition==j)
 #       pval_pair <- na.omit(reshape2::melt(tibble::rownames_to_column(data.frame(pairwise.wilcox.test(as.numeric(as.character(CELdata_RMA_core_annotated_melt_ij$value)),CELdata_RMA_core_annotated_melt_ij$bg,paired=FALSE,p.adjust.method = "holm",alternative="greater")$p.value)),id.vars="rowname"))
 #       pval_pair$variable <-gsub("X","",pval_pair$variable)
 #       TSDABG <- rbind(TSDABG,c(i,pval_pair$value,"nobg",j))
 #       colnames(TSDABG) <- c("fsetid","pvalue","bg","Condition")
 # }
 # }
@

 <<RMA Quality Control - PA calls - obsolete: intensity bg corrected probes compared to 0 DOES NOT WORK,include=FALSE,eval=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.width=10,fig.height=8,fig.pos="H">>=
 # in byobu modus in mobaxterm:
 # Parallelize tasks
 # detectCores()
 # cl <- parallel::makeCluster(9,outfile="")
 # registerDoSNOW(cl)

 # P-values
 # pacall_RMA_TSDABG <- xfun::cache_rds({
 # TSDABG <- data.frame()
 #
 # TSDABG <- foreach(i = 1:length(unique(CELdata_RMA_core_annotated_melt$fsetid)), .combine=rbind,.packages=c("doSNOW")) :
 #   foreach(j = 1:9, .combine=rbind,.packages="dplyr") dopar {
 #       jname <- as.character(unique(CELdata_RMA_core_annotated_melt$variable)[j])
 #       iname <- as.integer(unique(CELdata_RMA_core_annotated_melt$fsetid)[i])
 #       print(paste0(jname,"_",iname,"_",i))
 #       if(iname in unique(CELdata_RMA_core_annotated_melt[CELdata_RMA_core_annotated_melt$bg!="bg",]$fsetid)){
 #         CELdata_RMA_core_annotated_melt_ij <- CELdata_norm_log2_annotated_melt > subset(fsetid==iname) > subset(variable==jname)
 #         pval_pair <- na.omit(reshape2::melt(tibble::rownames_to_column(data.frame(wilcox.test(x=as.numeric(as.character(CELdata_RMA_core_annotated_melt_ij$bgcorrect)),mu=0,p.adjust.method = "holm",alternative="greater")$p.value)),id.vars="rowname"))
 #         pval_pair$variable <-gsub("X","",pval_pair$variable)
 #        TSDABGtemp <- c(iname,pval_pair$value,"nobg",jname)
 #       }else{TSDABGtemp <- c(NA,NA,NA,NA)}
 #        TSDABGtemp
 #   }
 # colnames(TSDABG) <- c("fsetid","pvalue","bg","variable")
 # TSDABG
 # },file="RDS_RMA_TSDABG")

 #stopCluster(cl)

 # # old method on RMA summarized values -> looks at triplicates of arrays only and not individual arrays because you need replicates to run the WSR on
 # for(i in unique(CELdata_RMA_core_annotated_melt[CELdata_RMA_core_annotated_melt$bg!="bg",]$fsetid)){
 # CELdata_RMA_core_annotated_melt$Condition <- mapvalues(as.character(CELdata_RMA_core_annotated_melt$variable),from=metadata_nocontrol$SampleName,to=as.character(metadata_nocontrol$Condition))
 #
 #   for(j in unique(CELdata_RMA_core_annotated_melt$variable)){
 #       CELdata_RMA_core_annotated_melt_ij <- CELdata_RMA_core_annotated_melt > subset(fsetid==i|bg=="bg") > subset(condition==j)
 #       pval_pair <- na.omit(reshape2::melt(tibble::rownames_to_column(data.frame(pairwise.wilcox.test(as.numeric(as.character(CELdata_RMA_core_annotated_melt_ij$value)),CELdata_RMA_core_annotated_melt_ij$bg,paired=FALSE,p.adjust.method = "holm",alternative="greater")$p.value)),id.vars="rowname"))
 #       pval_pair$variable <-gsub("X","",pval_pair$variable)
 #       TSDABG <- rbind(TSDABG,c(i,pval_pair$value,"nobg",j))
 #       colnames(TSDABG) <- c("fsetid","pvalue","bg","Condition")
 #   }
 # }
 @

<<RMA Quality Control - PA calls plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="500pt",fig.cap=c("\\label{RMAQC:fig23} Detected Above Background plots, with probe intensities per microaray. The $\\alpha$ = 0.05 significance level is indicated by a vertical dashed line. The per-sample average background probe intensity and standard deviation are marked by a horizontal dashed line with shaded interval."),fig.scap=c("Detected Above Background plots, with probe intensities per microaray."),fig.pos="H">>=

 # Per sample plot
   CELdata_RMA_core_annotated_melt_present <- merge(CELdata_RMA_core_annotated_melt,na.omit(pacall_RMA_TSDABG),by=c("fsetid","variable"),all=TRUE,sort=FALSE)
   CELdata_RMA_core_annotated_melt_present$pvalue[is.na(CELdata_RMA_core_annotated_melt_present$pvalue)] <- 1

   ## Percent present
   CELdata_RMA_core_annotated_melt_percentpresent <- na.omit(CELdata_RMA_core_annotated_melt_present %>%  group_by(variable)  %>%  summarise(percentage=(sum(pvalue<0.05)/n())*100))

   CELdata_RMA_core_annotated_melt_present_avbgprobes <-  ddply(CELdata_RMA_core_annotated_melt_present  %>%  subset(bg.x=="bg"),.(variable),numcolwise(mean))
   CELdata_RMA_core_annotated_melt_present_medbgprobes <-  ddply(CELdata_RMA_core_annotated_melt_present  %>%  subset(bg.x=="bg"),.(variable),numcolwise(median))
   CELdata_RMA_core_annotated_melt_present_avbgprobes$x <-  -Inf
   CELdata_RMA_core_annotated_melt_present_avbgprobes <- rbind(CELdata_RMA_core_annotated_melt_present_avbgprobes,CELdata_RMA_core_annotated_melt_present_avbgprobes)
   CELdata_RMA_core_annotated_melt_present_avbgprobes[c(10:18),]$x <- Inf
   CELdata_RMA_core_annotated_melt_present_sdbgprobes <-  ddply(CELdata_RMA_core_annotated_melt_present  %>%  subset(bg.x=="bg"),.(variable),numcolwise(sd))

   PAplot <- ggplot()+ geom_point(data=CELdata_RMA_core_annotated_melt_present,aes(y=value,x=as.numeric(pvalue),color=type),size=1) + facet_wrap(~variable,ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_color_manual(name="",values=probetypecolors) + xlab("p-value") + ylab("Log2 RMA pre-processed intensity") + geom_vline(xintercept=0.05,color="black",linetype="dashed") + guides(color=guide_legend(nrow=4))
   PAplot <- papertheme(PAplot,sizeselect = 12)
   PAplot <- PAplot + geom_hline(data=CELdata_RMA_core_annotated_melt_present_avbgprobes,aes(yintercept=value),linetype="dashed")
   PAplot <- PAplot + geom_ribbon(data=CELdata_RMA_core_annotated_melt_present_avbgprobes, aes(x=x,y=NULL,ymin = value - CELdata_RMA_core_annotated_melt_present_sdbgprobes$value, ymax = value + CELdata_RMA_core_annotated_melt_present_sdbgprobes$value), fill = 'black',alpha = 0.4)
   #PAplot

   PAplot_strips <- ggplot_gtable(ggplot_build(PAplot))
   stripr <- which(grepl('strip-t',PAplot_strips$layout$name))
   fills <- c("#8b0a50FF","#8b0a50A6","#8b0a5040","#756bb1FF","#756bb1A6","#756bb140","#ee7600FF","#ee7600A6","#ee760040")
   k <- 1
   for (i in stripr){
   if(length(grepl('rect',PAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect',PAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   PAplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}}

   #PAplot_strips
   
   tiff(paste0(path,"RMA_QC/PAcalls/DABG_PAcalls.tiff"),width=8*dpitiff,height=8*dpitiff,res=dpitiff,compression="lzw")
   grid.draw(PAplot_strips)
   dev.off()
   
   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/PAcalls/DABG_PAcalls.tiff")))
 # # Per sample type plot
 #   CELdata_RMA_core_avexpr_melt <- reshape2::melt(tibble::rownames_to_column(CELdata_RMA_core_avexpr))
 #   CELdata_RMA_core_avexpr_present <- merge(CELdata_RMA_core_avexpr_melt,na.omit(pacall_RMA_TSDABG),by.x=c("rowname","variable"),by.y=c("fsetid","variable"),all=TRUE,sort=FALSE)
 #   CELdata_RMA_core_avexpr_present$pvalue[is.na(CELdata_RMA_core_avexpr_present$pvalue)] <- 1
 #   CELdata_RMA_core_avexpr_present$bg[is.na(CELdata_RMA_core_avexpr_present$bg)] <- "bg"
 #   CELdata_RMA_core_avexpr_present <- merge(CELdata_RMA_core_avexpr_present,gene_annotation,by.x="rowname",by.y="fsetid")
 #
 #   CELdata_RMA_core_avexpr_present_melt_avbgprobes <-  ddply(CELdata_RMA_core_avexpr_present > subset(bg=="bg"),.(variable),numcolwise(mean))
 #   CELdata_RMA_core_avexpr_present_melt_avbgprobes$x <-  -Inf
 #   CELdata_RMA_core_avexpr_present_melt_avbgprobes <- rbind(CELdata_RMA_core_avexpr_present_melt_avbgprobes,CELdata_RMA_core_avexpr_present_melt_avbgprobes)
 #   CELdata_RMA_core_avexpr_present_melt_avbgprobes[c(4:6),]$x <- Inf
 #   CELdata_RMA_core_avexpr_present_melt_sdbgprobes <-  ddply(CELdata_RMA_core_avexpr_present > subset(bg=="bg"),.(variable),numcolwise(sd))
 #
 #   PAplot <- ggplot()+ geom_point(data=CELdata_RMA_core_avexpr_present,aes(y=value,x=as.numeric(pvalue),color=type),size=0.2)+ facet_wrap(~variable,ncol=3) + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_color_manual(name="",values=probetypecolors) + xlab("p-value") + ylab("Log2 RMA pre-processed intensity") + geom_vline(xintercept=0.05,color="black",linetype="dashed") + guides(color=guide_legend(nrow=4))
 #   PAplot <- papertheme(PAplot,sizeselect = 8)
 #   PAplot <- PAplot + geom_hline(data=CELdata_RMA_core_avexpr_present_melt_avbgprobes,aes(yintercept=value),linetype="dashed")
 #   PAplot <- PAplot + geom_ribbon(data=CELdata_RMA_core_avexpr_present_melt_avbgprobes, aes(x=x,y=NULL,ymin = value -CELdata_RMA_core_avexpr_present_melt_sdbgprobes$value, ymax = value + CELdata_RMA_core_avexpr_present_melt_sdbgprobes$value), fill = 'black',alpha = 0.4)
 #   PAplot
 #
 #   PAplot_strips <- ggplot_gtable(ggplot_build(PAplot))
 #   stripr <- which(grepl('strip-t',PAplot_strips$layout$name))
 #   fills <- c("#ee7600FF","#756bb1FF","#8b0a50FF")
 #   k <- 1
 #   for (i in stripr){
 #   if(length(grepl('rect',PAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
 #   j <- which(grepl('rect',PAplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
 #   PAplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
 #   k <- k+1}}
 #
 #   grid.draw(PAplot_strips)
   
 #  ,"\\label{RMAQC:fig24} Detected Above Background plots, with average probe intensities per condition (n=3). The $\\alpha$ = 0.05 significance level is indicated by a vertical dashed line. The per-condition average background probe intensity and standard deviation are marked by a horizontal dashed line with shaded interval.")
 @

Only \Sexpr{round(CELdata_RMA_core_annotated_melt_percentpresent$percentage[1],2)} percent of the transcripts significantly exceeds the background probe signal. The p-value increases with decreasing probe intensity and as expected the negative control probes are enriched at p$>$0.05 (Figure \ref{RMAQC:fig23}).

\vspace{\fill}

\section{Probe-level model fitting: Chip pseudo-images, RLE and NUSE - summarized data}
Although the median polish algorithm (used in RMA) is not available in the fit PLM model, the pseudochip images generated with the PLM method suggest that the blobs are properly disambiguated since the identified overly intense artefacts are not showing up in the unaffected high-quality arrays as under-expressed areas (Figures \ref{RMAQC:fig16}-\ref{RMAQC:fig17}). To ensure that blobs were properly dealt with, intensities of the probes in the blob region were manually inspected prior to and after RMA normalization. Blob regions were gated with the gglocator function and probes with coordinates within the demarcated polygon were identified. Boxplots comparing the intensities in the blob area before and after RMA pre-processing confirmed that the artefact was succesfully removed, without affecting the other arrays (Figures \ref{RMAQC:fig28} and \ref{RMAQC:fig29}) .
The output from RMA suggests that RMA does a fair job of disambiguating the scratch from the surrounding data, but some areas of blue still exist near the scratch, suggesting that the gene expression values for these probe sets have been overestimated.
All NUSE values are around 1, with slight deviations for sample blank3 and SHIME\_LGG1, indicating that the skewdness in raw intensities in not properly corrected by normalization in these chips (Figure \ref{RMAQC:fig19}). The bigger spread for blank3 and SHIME\_LGG1 is also apparent in the RLE values (Figure \ref{RMAQC:fig18}), which are still nicely centered around zero.

\vspace{\fill}
%applications and deviations from zero typically indicate a skewness in the raw intensities for  chip that was not properly corrected by normalization

<<RMA Quality Control - Probe-level model fitting+Chip Pseudo Images,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show='hide'>>=
 Pset <- xfun::cache_rds({
 # Fit probe-level model and explore results
   #?fitProbeLevelModel(CELdata)
   Pset = oligo::fitProbeLevelModel(CELdata_nocontrol,target="core",background=TRUE,normalize=TRUE,method="plm")
   Pset},file="RDS_RMA_Pset")

   oligo::weights(Pset) # attributes(Pset)$weights # : "matrix" with weights - probe-level
   oligo::residuals(Pset) # attributes(Pset)$residuals # "matrix" with residuals - probe-level
   oligo::residualSE(Pset) # attributes(Pset)$residualSE
   # Chip level effects for every probeset
   length(oligo::coef(Pset))
   oligo::coef(Pset) # is equivalent to attributes(Pset)$chip.coefs # "matrix" with chip/sample effects - probeset-level
   oligo::se(Pset) # is equivalent to attributes(Pset)$se.chip.coefs "matrix" with standard errors for chip/sample coefficients
   # Probe level effects (for annotated probes at core level)
   length(oligo::coefs.probe(Pset))
   oligo::coefs.probe(Pset) #attributes(Pset)$probe.coefs # : "numeric" vector with probe effects
   oligo::se.probe(Pset) # attributes(Pset)$se.probe.coefs # "numeric" vector with standard errors for probe

 # Create legends for residuals
   res <- oligo::residuals(Pset)
   dim(res)
   minres <-  min(na.omit(res))
   maxres <-  max(na.omit(res))

   ##  residuals blue white red
   col_res <- colorRampPalette(c("blue","white","red"))
   colorlegend_res <- ggplotify::as.ggplot(ggcolor.bar(col_res(100),minres,maxres,"Residuals",c(-7.3,-4,0,4,7,9),c(-7,-4,0,4,7,9),fill="gradient",legdir="horizontal")) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_residual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
   colorlegend_res
   dev.off()

   colorlegend_res <- image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_residual_colorlegend.tiff"))
   colorlegend_res <- image_trim(colorlegend_res)
   colorlegend_res <- ggdraw() +  draw_image(colorlegend_res)

   ## Positive residuals white, orange, red
   col_posres <- colorRampPalette(c("#FFF7EC", "#FEE8C8", "#FDD49E", "#FDBB84", "#FC8D59","#EF6548", "#D7301F", "#B30000", "#7F0000"))
   colorlegend_posres <- ggplotify::as.ggplot(ggcolor.bar(col_posres(100),minres,maxres,"Residuals",c(-7.3,-4,0,4,7,9),c(-7,-4,0,4,7,9),fill="gradient",legdir="horizontal")) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_posresidual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
   colorlegend_posres
   dev.off()

   colorlegend_posres <- image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_posresidual_colorlegend.tiff"))
   colorlegend_posres <- image_trim(colorlegend_posres)
   colorlegend_posres <- ggdraw() +  draw_image(colorlegend_posres)

   ## Negative residuals blue, lightblue, white
   col_negres <- colorRampPalette(c(rev(c("#F7FBFF","#DEEBF7","#C6DBEF","#9ECAE1","#6BAED6","#4292C6", "#2171B5", "#08519C", "#08306B"))))
   colorlegend_negres <- ggplotify::as.ggplot(ggcolor.bar(col_negres(100),minres,maxres,"Residuals",c(-7.3,-4,0,4,7,9),c(-7,-4,0,4,7,9),fill="gradient",legdir="horizontal")) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_negresidual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
   colorlegend_negres
   dev.off()

   colorlegend_negres <- image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_negresidual_colorlegend.tiff"))
   colorlegend_negres <- image_trim(colorlegend_negres)
   colorlegend_negres <- ggdraw() +  draw_image(colorlegend_negres)

   ## Sign residuals blue or red
   col_signres <- colorRampPalette(c("#08306B","#7F0000"))
   colorlegend_signres <- ggplotify::as.ggplot(ggcolor.bar(col_signres(2),minres,maxres,"Residuals",c("<0",">0"),fill="manual",legdir="horizontal")) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_signresidual_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
   colorlegend_signres
   dev.off()

   colorlegend_signres <- image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_signresidual_colorlegend.tiff"))
   colorlegend_signres <- image_trim(colorlegend_signres)
   colorlegend_signres <- ggdraw() +  draw_image(colorlegend_signres)

   ## Create legends for weights
   wt <- oligo::weights(Pset)
   minwt <- 0
   maxwt <- 1

   col_wt <- colorRampPalette(c("#F7FBFF", "#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6",
             "#4292C6", "#2171B5", "#08519C", "#08306B"))
   colorlegend_wt <- ggplotify::as.ggplot(ggcolor.bar(col_wt(100),minwt,maxwt,"Weights",c(0,0.5,1),fill="gradient",legdir="horizontal")) + theme(plot.margin = unit(c(0,0,0,0), "cm"))

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_weight_colorlegend.tiff"),width=3*dpi,height=2*dpi,res=dpi,compression="lzw")
   colorlegend_wt
   dev.off()

   colorlegend_wt <- image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_weight_colorlegend.tiff"))
   colorlegend_wt <- image_trim(colorlegend_wt)
   colorlegend_wt <- ggdraw() +  draw_image(colorlegend_wt)

 # Pseudo-images by residuals
   for (i in 1:9){
   namei <- rownames(CELsampledata_nocontrol@data)[i]
   name = paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_residual",namei,".tiff")
   tiff(name)
   oligo::image(Pset,which=i,type="residuals",main=rownames(CELsampledata_nocontrol@data)[i],col=col_res(100))
   dev.off()
   ploti <- image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_residual",namei,".tiff"))
   ploti <- ggdraw() +  draw_image(ploti)
   ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
   assign(paste0("RMA_Pseudoimage_residual",namei),ploti)
   }

   for (i in 1:9){
   namei <- rownames(CELsampledata_nocontrol@data)[i]
   name = paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_posresidual",namei,".tiff")
   tiff(name)
   oligo::image(Pset,which=i,type="pos.residuals",main=rownames(CELsampledata_nocontrol@data)[i],col=col_posres(10))
   dev.off()
   ploti <- image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_posresidual",namei,".tiff"))
   ploti <- ggdraw() +  draw_image(ploti)
   ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
   assign(paste0("RMA_Pseudoimage_posresidual",namei),ploti)}

   for (i in 1:9){
   namei <- rownames(CELsampledata_nocontrol@data)[i]
   name = paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_negresidual",namei,".tiff",sep="")
   tiff(name)
   oligo::image(Pset,which=i,type="neg.residuals",main=rownames(CELsampledata_nocontrol@data)[i],col=col_negres(100))
   dev.off()
   ploti <- image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_negresidual",namei,".tiff"))
   ploti <- ggdraw() +  draw_image(ploti)
   ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
   assign(paste0("RMA_Pseudoimage_negresidual",namei),ploti)}

   for (i in 1:9){
   namei <- rownames(CELsampledata_nocontrol@data)[i]
   name = paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_signresidual",namei,".tiff")
   tiff(name)
   oligo::image(Pset,which=i,type="sign.residuals",main=rownames(CELsampledata_nocontrol@data)[i],col_signres(2))
   dev.off()
   ploti <- image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_signresidual",namei,".tiff"))
   ploti <- ggdraw() +  draw_image(ploti)
   ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
   assign(paste0("RMA_Pseudoimage_signresidual",namei),ploti)}

 # Pseudo-images by weight
   for (i in 1:9){
   namei <- rownames(CELsampledata_nocontrol@data)[i]
   name = paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_weight",namei,".tiff",sep="")
   tiff(name)
   oligo::image(Pset,which=i,type="weight",main=rownames(CELsampledata_nocontrol@data)[i],col=col_wt(100))
   dev.off()
   ploti <- image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_weight",namei,".tiff"))
   ploti <- ggdraw() +  draw_image(ploti)
   ploti <- ploti + theme(plot.margin = unit(c(0,0,0,0), "cm"))
   assign(paste0("RMA_Pseudoimage_weight",namei),ploti)}

 # Image composition
   Microarray_ALL_res <- plot_grid(RMA_Pseudoimage_residualBlank1,RMA_Pseudoimage_residualBlank2,RMA_Pseudoimage_residualBlank3,RMA_Pseudoimage_residualSHIME1,RMA_Pseudoimage_residualSHIME2,RMA_Pseudoimage_residualSHIME3,RMA_Pseudoimage_residualSHIME_LGG1,RMA_Pseudoimage_residualSHIME_LGG2,RMA_Pseudoimage_residualSHIME_LGG3,colorlegend_res,NULL,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.3,0.3,0.3,0.1))

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_ALLresidual.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
   Microarray_ALL_res
   dev.off()

   Microarray_ALL_posres <- plot_grid(RMA_Pseudoimage_posresidualBlank1,RMA_Pseudoimage_posresidualBlank2,RMA_Pseudoimage_posresidualBlank3,RMA_Pseudoimage_posresidualSHIME1,RMA_Pseudoimage_posresidualSHIME2,RMA_Pseudoimage_posresidualSHIME3,RMA_Pseudoimage_posresidualSHIME_LGG1,RMA_Pseudoimage_posresidualSHIME_LGG2,RMA_Pseudoimage_posresidualSHIME_LGG3,colorlegend_posres,NULL,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.3,0.3,0.3,0.1))

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_ALLposresidual.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
   Microarray_ALL_posres
   dev.off()

   Microarray_ALL_negres <- plot_grid(RMA_Pseudoimage_negresidualBlank1,RMA_Pseudoimage_negresidualBlank2,RMA_Pseudoimage_negresidualBlank3,RMA_Pseudoimage_negresidualSHIME1,RMA_Pseudoimage_negresidualSHIME2,RMA_Pseudoimage_negresidualSHIME3,RMA_Pseudoimage_negresidualSHIME_LGG1,RMA_Pseudoimage_negresidualSHIME_LGG2,RMA_Pseudoimage_negresidualSHIME_LGG3,colorlegend_negres,NULL,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.3,0.3,0.3,0.1))

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_ALLnegresidual.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
   Microarray_ALL_negres
   dev.off()

   Microarray_ALL_signres <- plot_grid(RMA_Pseudoimage_signresidualBlank1,RMA_Pseudoimage_signresidualBlank2,RMA_Pseudoimage_signresidualBlank3,RMA_Pseudoimage_signresidualSHIME1,RMA_Pseudoimage_signresidualSHIME2,RMA_Pseudoimage_signresidualSHIME3,RMA_Pseudoimage_signresidualSHIME_LGG1,RMA_Pseudoimage_signresidualSHIME_LGG2,RMA_Pseudoimage_signresidualSHIME_LGG3,colorlegend_signres,NULL,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.3,0.3,0.3,0.1))
   Microarray_ALL_signres

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_ALLsignresidual.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
   Microarray_ALL_signres
   dev.off()

   Microarray_ALL_wt <- plot_grid(RMA_Pseudoimage_weightBlank1,RMA_Pseudoimage_weightBlank2,RMA_Pseudoimage_weightBlank3,RMA_Pseudoimage_weightSHIME1,RMA_Pseudoimage_weightSHIME2,RMA_Pseudoimage_weightSHIME3,RMA_Pseudoimage_weightSHIME_LGG1,RMA_Pseudoimage_weightSHIME_LGG2,RMA_Pseudoimage_weightSHIME_LGG3,colorlegend_wt,NULL,NULL,nrow=4,ncol=3,rel_widths = c(0.33,0.33,0.33),rel_heights=c(0.3,0.3,0.3,0.1))

   Microarray_ALL_wt
   tiff(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_ALLweight.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
   Microarray_ALL_wt
   dev.off()


 # Relative Log Expression: RLE
   oligo::RLE(Pset,type="stats")[,1:2]
   oligo::RLE(Pset,type="values")[1:4,1:2]
   RLEstat <- oligo::RLE(Pset,type="stats")
   RLEval <- oligo::RLE(Pset,type="values")
   dim(RLEval)
   RLEvalmelt <- reshape2::melt(RLEval)
   RLEvalmelt$Var2 <- factor(RLEvalmelt$Var2,levels=samplevel)

   RLEboxplot <- xfun::cache_rds({
   RLEboxplot <- ggplot() + geom_boxplot(data=RLEvalmelt,aes(x=Var2,y=value,fill=Var2))
   RLEboxplot <- papertheme(RLEboxplot,sizeselect = 12) + theme(legend.position = "none") + xlab("") + ylab("RLE after background correction and normalization") + scale_fill_manual(values=samplecolors) + scale_fill_manual(values=samplecolors) + scale_x_discrete(labels=sampleplotname)

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/RLEboxplot.tiff"),width=8*dpi,height=4*dpi,res=dpi,compression="lzw")
   RLEboxplot
   dev.off()

   RLEboxplot

   },file="RDS_RMA_RLEboxplot")


 # Normalized Unscaled Standard Errors: NUSE
   #NUSE(Pset,type="stats")[,1:2]
   oligo::NUSE(Pset,type="values")[1:4,1:2]
   #NUSEstat <- NUSE(Pset,type="stats",na.rm=TRUE)
   NUSEval <- oligo::NUSE(Pset,type="values")
   dim(NUSEval)
   NUSEvalmelt <- reshape2::melt(NUSEval)
   NUSEvalmelt$Var2 <- factor(NUSEvalmelt$Var2,levels=samplevel)

   NUSEboxplot <- xfun::cache_rds({
   NUSEboxplot <- ggplot() + geom_boxplot(data=NUSEvalmelt,aes(x=Var2,y=value,fill=Var2))
   NUSEboxplot <- papertheme(NUSEboxplot,sizeselect =12) + theme(legend.position = "none") + xlab("") + ylab("NUSE after background correction and normalization") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=samplecolors) + scale_x_discrete(labels=sampleplotname)

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/NUSEboxplot.tiff"),width=8*dpi,height=4*dpi,res=dpi,compression="lzw")
   NUSEboxplot
   dev.off()

   NUSEboxplot

 },file="RDS_RMA_NUSEboxplot")
 @

<<RMA Quality Control - Probe-level model fitting+Chip Pseudo Images plot1,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="700pt",fig.cap=c("\\label{RMAQC:fig16} Pseudo-images of the estimated residuals from a probe-level model fitting after background correction and normalization","\\label{RMAQC:fig17} Pseudo-images of the estimated weights from a probe-level model fitting after background correction and normalization"),fig.pos="H">>=
 # # Display plots
 #   Microarray_ALL_res
 #       #Microarray_ALL_posres
 #       #Microarray_ALL_negres
 #       #Microarray_ALL_signres
 #   Microarray_ALL_wt
 #   RLEboxplot
 #   NUSEboxplot
  ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/Pseudoimage_ALLresidual.tiff"))) 
  ggdraw() +  draw_image(image_read(paste0(path,"QC/ProbelevelModelfitting/Pseudoimage_ALLweight.tiff"))) 
 @

\begin{landscape}
<<RMA Quality Control - Probe-level model fitting+Chip Pseudo Images plot2,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{RMAQC:fig18} Box plot of the Relative Log Expression (RLE) values based on a probe-level model fitting after background correction and normalization","\\label{RMAQC:fig19} Box plot of the Normalized Unscaled Standard Errors (NUSE) values based on a probe-level model fitting after background correction and normalization"),fig.pos="H">>=
 # # Display plots
 #   Microarray_ALL_res
 #       #Microarray_ALL_posres
 #       #Microarray_ALL_negres
 #       #Microarray_ALL_signres
 #   Microarray_ALL_wt
 #   RLEboxplot
 #   NUSEboxplot
  ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/RLEboxplot.tiff")))  
  ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/NUSEboxplot.tiff")))  
 @
\end{landscape}

<<RMA Quality Control - Probe-level model fitting to calculate RLE and NUSE for control probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show='hide'>>=
 # Relative Log Expression: RLE
   RLEval_controls_melt <- RLEvalmelt[RLEvalmelt$Var1%in%probecontrols_core$fsetid,]
   RLEval_controls_melt$type <- mapvalues(RLEval_controls_melt$Var1,from=probecontrols_core$fsetid,to=as.character(probecontrols_core$type))

 RLEboxplot_strips <- xfun::cache_rds({
   RLEboxplot <- ggplot() + geom_boxplot(data=RLEval_controls_melt,aes(x=Var2,y=value,fill=Var2))
   RLEboxplot <- papertheme(RLEboxplot,sizeselect = 12) + theme(legend.position = "none",axis.text.x=element_text(angle=90)) + xlab("") + ylab("RLE after background correction and normalization") + facet_wrap(type~.,scales="free_y") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + scale_fill_manual(values=samplecolors)

   RLEboxplot_strips <-  ggplot_gtable(ggplot_build(RLEboxplot))
   stripr <- which(grepl('strip-t',RLEboxplot_strips$layout$name))
   fills <- rev(probetypecolors)
   k <- 1
   for(i in stripr){
   if(length(grepl('rect',RLEboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect', RLEboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   RLEboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}}

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/RLEboxplot_controls.tiff"),width=8*dpitiff,height=8*dpitiff,res=dpitiff,compression="lzw")
   grid.draw(RLEboxplot_strips)
   dev.off()

   RLEboxplot_strips
 },file="RDS_RMA_RLEboxplot_probetype")

  # Normalized Unscaled Standard Errors: NUSE
   NUSEval_controls_melt <- NUSEvalmelt[NUSEvalmelt$Var1%in%probecontrols_core$fsetid,]
   NUSEval_controls_melt$type <- mapvalues(NUSEval_controls_melt$Var1,from=probecontrols_core$fsetid,to=as.character(probecontrols_core$type))

   NUSEboxplot_strips <- xfun::cache_rds({
   NUSEboxplot <- ggplot() + geom_boxplot(data=NUSEval_controls_melt,aes(x=Var2,y=value,fill=Var2))
   NUSEboxplot <- papertheme(NUSEboxplot,sizeselect=12) + theme(legend.position = "none",axis.text.x=element_text(angle=90)) + xlab("") + ylab("NUSE after background correction and normalization") + facet_wrap(type~.,scales="free_y") + scale_y_continuous(labels=function(x) sprintf("%.2f", x))  + scale_fill_manual(values=samplecolors)

   NUSEboxplot_strips <-  ggplot_gtable(ggplot_build(NUSEboxplot))
   stripr <- which(grepl('strip-t',NUSEboxplot_strips$layout$name))
   fills <- rev(probetypecolors)
   k <- 1
   for(i in stripr){
   if(length(grepl('rect',NUSEboxplot_strips $grobs[[i]]$grobs[[1]]$childrenOrder))!=0){
   j <- which(grepl('rect', NUSEboxplot_strips$grobs[[i]]$grobs[[1]]$childrenOrder))
   NUSEboxplot_strips$grobs[[i]]$grobs[[1]]$children[[j]]$gp$fill <- fills[k]
   k <- k+1}}

   tiff(paste0(path,"RMA_QC/ProbelevelModelfitting/NUSEboxplot_controls.tiff"),width=8*dpitiff,height=8*dpitiff,res=dpitiff,compression="lzw")
   grid.draw(NUSEboxplot_strips)
   dev.off()

   NUSEboxplot_strips
 },file="RDS_RMA_NUSEboxplot_probetype")
 @

<<RMA Quality Control - Probe-level model fitting to calculate RLE and NUSE for control probes plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="600pt",fig.cap=c("\\label{RMAQC:fig20} Box plot of the Relative Log Expression (RLE) values of control probes based on a probe-level model fitting after background correction and normalization","\\label{RMAQC:fig21} Box plot of the Normalized Unscaled Standard Errors (NUSE) values of control probes based on a probe-level model fitting after background correction and normalization"),fig.pos="H">>=
   # grid.draw(RLEboxplot_strips)
   # grid.newpage(recording=FALSE)
   # grid.draw(NUSEboxplot_strips)
   
   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/RLEboxplot_controls.tiff"))) 
   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/ProbelevelModelfitting/NUSEboxplot_controls.tiff")))  
 @

<<RMA Quality Control - blob inspection,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show='hide'>>=
 # Positional effects are encoded in the x and y coordinates in the probe annotation files
 sort(unique(probe_annotation_core$x))
 sort(unique(probe_annotation_core$y))
 # Microarray pictures can be manually reproduced using ggplot2
 col <- colorRampPalette(c('blue','white',"red"),interpolate="linear")
 max(CELdata_pm_core_log2_annotated$Blank3)
 min(CELdata_pm_core_log2_annotated$Blank3)
 manualblank3 <- ggplot(data=CELdata_pm_core_log2_annotated) + geom_point(aes(x=x,y=y,colour=Blank3)) + scale_colour_gradientn(colours=col(100), limits=c(3, 13),name="Log2 Intensity")
 manualblank3 <- papertheme(manualblank3,sizeselect=12) + theme(legend.position = "none")
 #manualblank3

 #uppercorner <- gglocator2(papertheme(ggplot(),sizeselect=8),8)
 #write.csv(as.matrix(uppercorner),"uppercorner.csv")
 uppercorner <- read.csv("uppercorner.csv")
 uppercorner$V1 <- uppercorner$V1*1000
 uppercorner$V2 <- uppercorner$V2*1240
 manualblank3 <- manualblank3 + geom_polygon(data=data.frame(uppercorner),aes(x=V1,y=V2),fill="NA",color="magenta")
 #manualblank3

 tiff(paste0(path,"RMA_QC/Distribution/blob_gated.tiff"),width=6*dpi,height=6*dpi,res=dpi,compression="lzw")
 manualblank3
 dev.off()
 
 
 # Select the probes in the probeset
 probeblob_blank3 <- probe_annotation_core[probe_annotation_core$x,]

 probeblob_blank3.poly <- sp::point.in.polygon(CELdata_pm_core_log2_annotated$x,CELdata_pm_core_log2_annotated$y,uppercorner$V1,uppercorner$V2)
 inpoly <- as.matrix(probeblob_blank3.poly)
 # Polygon in raw data
 CELdata_pm_core_log2_annotated_poly <- CELdata_pm_core_log2_annotated
 CELdata_pm_core_log2_annotated_poly$poly <- inpoly
 CELdata_pm_core_log2_annotated_poly <- CELdata_pm_core_log2_annotated_poly %>%  subset(inpoly=="1")
 CELdata_pm_core_log2_annotated_poly_melt <- reshape2::melt(CELdata_pm_core_log2_annotated_poly,id.vars=c("fid","man_fsetid","fsetid","x","y","chrom","type","uniqueid","sequence","subtype","posneg","poly"))
 # Polygon in RMA pre-processed data
 CELdata_RMA_core_annotated_poly <- CELdata_RMA_core_annotated
 CELdata_RMA_core_annotated_poly <- CELdata_RMA_core_annotated_poly  %>%  subset(fsetid%in%CELdata_pm_core_log2_annotated_poly$fsetid)
 CELdata_RMA_core_annotated_poly_melt <- reshape2::melt(CELdata_RMA_core_annotated_poly,id.vars=c("man_fsetid","fsetid","chrom","type","subtype","posneg"))
 @

<<RMA Quality Control - blob gating,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="400pt",out.height="400pt",fig.cap=c("\\label{RMAQC:fig30} Gating the blob region to extract data of the affected probes."),fig.pos="H">>=
# Blob gated
  ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/blob_gated.tiff"))) 
@

\begin{landscape}
<<RMA Quality Control - blob box plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.width=10,out.width="450pt",out.height="400pt",fig.cap=c("\\label{RMAQC:fig28} Box plot of the unnormalized raw intensities of the blob probes","\\label{RMAQC:fig29} Box plot of the RMA pre-processed intensities of the blob probes"),fig.pos="H">>=
# Box plots before RMA correction
 log2box <- xfun::cache_rds({
   ## Boxplot of log2 intensities
   log2box <- ggplot(CELdata_pm_core_log2_annotated_poly_melt, aes(variable,value,fill = variable))
   log2box <- papertheme(log2box,sizeselect = 12) + geom_boxplot() + guides(fill=guide_legend(ncol=4,nrow=3)) + xlab("") +ylab("Log2 probe intensity") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=samplecolors) + theme(legend.position="none") + scale_x_discrete(labels=sampleplotname)

   tiff(paste0(path,"RMA_QC/Distribution/boxplot_blob_beforeRMA.tiff"),width=8*dpi,height=4*dpi,res=dpi,compression="lzw")
   log2box
   dev.off()

   log2box

 },file="RDS_RMA_boxplot_blob_beforeRMA")

   #log2box
   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplot_blob_beforeRMA.tiff"))) 

 # Box plots after RMA correction
 log2box <- xfun::cache_rds({
   ## Boxplot of log2 intensities
   log2box <- ggplot(CELdata_RMA_core_annotated_poly_melt, aes(variable,value,fill = variable))
   log2box <- papertheme(log2box,sizeselect = 12) + geom_boxplot() + guides(fill=guide_legend(ncol=4,nrow=3)) + xlab("") +ylab("Log2 probe intensity") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(fill = "") + scale_fill_manual(values=sample_nocontrolcolors) + theme(legend.position="none") + scale_x_discrete(labels=sampleplotname)

   tiff(paste0(path,"RMA_QC/Distribution/boxplot_blob_afterRMA.tiff"),width=8*dpi,height=4*dpi,res=dpi,compression="lzw")
   log2box
   dev.off()

   log2box

 },file="RDS_RMA_boxplot_blob_afterRMA")

   #log2box
   ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/Distribution/boxplot_blob_afterRMA.tiff"))) 
 @
\end{landscape}

\section{PCA}
While no outlier samples were identified according to the Hotelling's T2 criterion, sample Blank3 and SHIME\_LGG1 are separated from the other samples in most probesets, including the bac spike-in controls suggesting that differences in hybridization efficiency underlie the observed discrepancies (Figure \ref{RMAQC:fig26}).

<<RMA Quality Control - PCA all probes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
   CELdata_RMA_core_expr <- data.frame(CELdata_RMA_core_expr)

 # Multivariate normality
   # MVN <- xfun::cache_rds({
   # MVN <- ggpairs(CELdata_RMA_core) + scale_y_continuous(labels=function(x) sprintf("%.2f", x))
   # MVN},file="RDS_RMA_MVN")
   #
   # ## elliptic patterns in the bivariate comparisons => multivariate normality
   # maha <- xfun::cache_rds({
   # mahalanobis(CELdata_RMA_core,colMeans(CELdata_RMA_core),pracma::pinv(cov(CELdata_RMA_core)),inverted=TRUE)},file="RDS_RMA_maha") # a bit of a weird situation as distance is same for all objects accidentally
   # QQ <- xfun::cache_rds({
   # plot(qchisq(ppoints(mahalanobis(CELdata_RMA_core,colMeans(CELdata_RMA_core),pracma::pinv(cov(CELdata_RMA_core)),inverted=TRUE)),df=10),sort(mahalanobis(CELdata_RMA_core,colMeans(CELdata_RMA_core),pracma::pinv(cov(CELdata_RMA_core)),inverted=TRUE)),xlab="Observed",ylab="Expected")},file="RDS_RMA_qq")


 # PCA
   # prcomp function
      PCA <- prcomp(t(CELdata_RMA_core_expr),scale. = FALSE)
      PCAsummary <- summary(PCA)
      attributes(PCA)
   ## prcomp results
      PCA_eigval <- as.numeric(PCA$sdev^2)
      # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
      # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
      # PCA$center # colMeans(data)
      # PCA$scale
      # PCA$x # data_centered*svd(data_centered)$v
   ## pcromp plots
      # plot(PCA$x[,1:2],col=samplecolors)
      PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
      PCA_scores$rowname <- factor(PCA_scores$rowname,levels=samplevel_nocontrol)
   ## Hotelling T2 ellipse
      Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
      Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
      Zt1sq <- Zt1*Zt1
      Zt2sq <- Zt2*Zt2
      Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
      x0 <- 0
      y0 <- 0
      a <- sqrt(PCA_eigval)[1]
      b <- sqrt(PCA_eigval)[2]
      Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

      n <- nrow(t(CELdata_pm_core_log2_df))
      p <- 2 # Because we're in 2D
      fcorrect <- (n-p)/(p*(n-1))
      Ztdat$y = Ztdat$y*fcorrect
      confF <- qf(df1=p,df2=n-p,p=0.95)
      confF <- qf(df1=p,df2=n-p,p=0.99)

      ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

      PCAplot_allprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.5) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=samplecolors)  + ggtitle("All probes")
      PCAplot_allprobes <- papertheme(PCAplot_allprobes,sizeselect = 12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none")

 # PCA background probes
   # prcomp function
      PCA <- prcomp(t(CELdata_RMA_bg_core_expr),scale. = TRUE)
      PCAsummary <- summary(PCA)
      attributes(PCA)
   ## prcomp results
      PCA_eigval <- as.numeric(PCA$sdev^2)
      # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
      # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
      # PCA$center # colMeans(data)
      # PCA$scale
      # PCA$x # data_centered*svd(data_centered)$v
   ## pcromp plots
      # plot(PCA$x[,1:2],col=samplecolors)
      PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
      PCA_scores$rowname <- factor(PCA_scores$rowname,levels=samplevel_nocontrol)
   ## Hotelling T2 ellipse
      Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
      Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
      Zt1sq <- Zt1*Zt1
      Zt2sq <- Zt2*Zt2
      Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
      x0 <- 0
      y0 <- 0
      a <- sqrt(PCA_eigval)[1]
      b <- sqrt(PCA_eigval)[2]
      Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

      n <- nrow(t(CELdata_pm_core_log2_df))
      p <- 2 # Because we're in 2D
      fcorrect <- (n-p)/(p*(n-1))
      Ztdat$y = Ztdat$y*fcorrect
      confF <- qf(df1=p,df2=n-p,p=0.95)
      confF <- qf(df1=p,df2=n-p,p=0.99)

      ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

      PCAplot_bgprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.5) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=samplecolors)  + ggtitle("Background probes")
      PCAplot_bgprobes <- papertheme(PCAplot_bgprobes,sizeselect = 12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none")


 # PCA affx bac probes
   # prcomp function
      PCA <- prcomp(t(CELdata_RMA_core_affx_bac),scale. = TRUE)
      PCAsummary <- summary(PCA)
      attributes(PCA)
   ## prcomp results
      PCA_eigval <- as.numeric(PCA$sdev^2)
      # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
      # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
      # PCA$center # colMeans(data)
      # PCA$scale
      # PCA$x # data_centered*svd(data_centered)$v
   ## pcromp plots
      # plot(PCA$x[,1:2],col=samplecolors)
      PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
      PCA_scores$rowname <- factor(PCA_scores$rowname,levels=samplevel_nocontrol)
   ## Hotelling T2 ellipse
      Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
      Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
      Zt1sq <- Zt1*Zt1
      Zt2sq <- Zt2*Zt2
      Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
      x0 <- 0
      y0 <- 0
      a <- sqrt(PCA_eigval)[1]
      b <- sqrt(PCA_eigval)[2]
      Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

      n <- nrow(t(CELdata_pm_core_log2_df))
      p <- 2 # Because we're in 2D
      fcorrect <- (n-p)/(p*(n-1))
      Ztdat$y = Ztdat$y*fcorrect
      confF <- qf(df1=p,df2=n-p,p=0.95)
      confF <- qf(df1=p,df2=n-p,p=0.99)

      ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

      PCAplot_bacprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.5) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=samplecolors) + ggtitle("Bac positive control probes")
      PCAplot_bacprobes <- papertheme(PCAplot_bacprobes,sizeselect = 12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none")

 # PCA affx polyA probes
   # prcomp function
      PCA <- prcomp(t(CELdata_RMA_core_affx_polyA),scale. = TRUE)
      PCAsummary <- summary(PCA)
      attributes(PCA)
   ## prcomp results
      PCA_eigval <- as.numeric(PCA$sdev^2)
      # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
      # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
      # PCA$center # colMeans(data)
      # PCA$scale
      # PCA$x # data_centered*svd(data_centered)$v
   ## pcromp plots
      # plot(PCA$x[,1:2],col=samplecolors)
      PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
      PCA_scores$rowname <- factor(PCA_scores$rowname,levels=samplevel_nocontrol)
   ## Hotelling T2 ellipse
      Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
      Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
      Zt1sq <- Zt1*Zt1
      Zt2sq <- Zt2*Zt2
      Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
      x0 <- 0
      y0 <- 0
      a <- sqrt(PCA_eigval)[1]
      b <- sqrt(PCA_eigval)[2]
      Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

      n <- nrow(t(CELdata_pm_core_log2_df))
      p <- 2 # Because we're in 2D
      fcorrect <- (n-p)/(p*(n-1))
      Ztdat$y = Ztdat$y*fcorrect
      confF <- qf(df1=p,df2=n-p,p=0.95)
      confF <- qf(df1=p,df2=n-p,p=0.99)

      ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

      PCAplot_polyAprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.5) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=samplecolors)  + ggtitle("PolyA positive control probes")
      PCAplot_polyAprobes <- papertheme(PCAplot_polyAprobes,sizeselect = 12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none")

 # PCA endogenous control probes
   # prcomp function
      PCA <- prcomp(t(CELdata_RMA_housekeeping_numeric),scale. = TRUE)
      PCAsummary <- summary(PCA)
      attributes(PCA)
   ## prcomp results
      PCA_eigval <- as.numeric(PCA$sdev^2)
      # PCA$sdev # eigenvalues = prcomp(data)$sdev^2
      # PCA$rotation # loadings = prcomp(data)$rotation*prcomp(data)$sdev
      # PCA$center # colMeans(data)
      # PCA$scale
      # PCA$x # data_centered*svd(data_centered)$v
   ## pcromp plots
      # plot(PCA$x[,1:2],col=samplecolors)
      PCA_scores <- tibble::rownames_to_column(data.frame(PCA$x))
      PCA_scores$rowname <- factor(PCA_scores$rowname,levels=samplevel_nocontrol)
     ## Hotelling T2 ellipse
      Zt1 <- PCA_scores[,2]/sqrt(PCA_eigval)[1]
      Zt2 <- PCA_scores[,3]/sqrt(PCA_eigval)[2]
      Zt1sq <- Zt1*Zt1
      Zt2sq <- Zt2*Zt2
      Ztmat <- Zt1sq+Zt2sq # equation of ellipse centered at 0
      x0 <- 0
      y0 <- 0
      a <- sqrt(PCA_eigval)[1]
      b <- sqrt(PCA_eigval)[2]
      Ztdat <- data.frame(y=Ztmat,x=PCA_scores$rowname)

      n <- nrow(t(CELdata_pm_core_log2_df))
      p <- 2 # Because we're in 2D
      fcorrect <- (n-p)/(p*(n-1))
      Ztdat$y = Ztdat$y*fcorrect
      confF <- qf(df1=p,df2=n-p,p=0.95)
      confF <- qf(df1=p,df2=n-p,p=0.99)

      ellipsedf <- data.frame(x0 = 0, y0 = 0, a = a*(1/fcorrect)*sqrt(confF), b = b*(1/fcorrect)*sqrt(confF), angle = 0)

      PCAplot_endogenouscontrolprobes <- ggplot(data=PCA_scores) + geom_point(aes(x=PC1,y=PC2,color=rowname),size=4,alpha=0.5) + geom_text(aes(x=PC1,y=PC2,color=rowname,label=rowname),size=3,show.legend = FALSE) + xlab(paste('PCA Dim1',round((PCAsummary$importance[2,1]*100),2),'%',sep=" ")) + ylab(paste('PCA Dim2',round((PCAsummary$importance[2,2]*100),2),'%',sep=" ")) + scale_color_manual(values=samplecolors)  + ggtitle("Endogenous control probes")
      PCAplot_endogenouscontrolprobes <- papertheme(PCAplot_endogenouscontrolprobes,sizeselect = 12) + geom_ellipse(data=ellipsedf,aes(x0=x0,y0=y0,a=a,b=b,angle=angle),colour="black",linetype="dashed") + theme(legend.position = "none")
@

\begin{landscape}
<<RMA Quality Control - PCA plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="450pt",out.height="400pt",fig.cap=c("\\label{RMAQC:fig26} PCA scores plot of the RMA pre-processed standardized data.")>>=
 #plot_grid(PCAplot_allprobes,PCAplot_bgprobes,NULL,PCAplot_bacprobes,PCAplot_polyAprobes,PCAplot_endogenouscontrolprobes,nrow=2,ncol=3)

 tiff(paste0(path,"RMA_QC/PCA/PCA.tiff"),width=8*dpi,height=6*dpi,res=dpi,compression="lzw")
 plot_grid(PCAplot_allprobes,PCAplot_bgprobes,NULL,PCAplot_bacprobes,PCAplot_polyAprobes,PCAplot_endogenouscontrolprobes,nrow=2,ncol=3)
 dev.off()
 
ggdraw() +  draw_image(image_read(paste0(path,"RMA_QC/PCA/PCA.tiff"))) 
@
\end{landscape}











\chapter{Triple coculture cell model validation}
To validate the triple coculture cell model, expression above background was evaluated for several genes of interest related to epithelial barrier integrity (TJP1 = ZO-1), mucus expression (MUC2), cell surface receptors (MS4A12), immune signalling (TLR4) and transport (SLC16A1 = MCT1), as well as, marker genes for the presence of macrophages (CD68, ITGAM = CD11b). Results from the presence/absence calling for RMA pre-processed data at transcript level were used (see \ref{RMA_pacall}).

\begin{landscape}
<<Validation triple coculture cell model,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=TRUE>>=
 genesofinterest_IDs_expression <- xfun::cache_rds({
   # Genes of interest: map to affymetrix probeset identifiers
     ## Loading most recent ensembl homo sapiens gene dataset
        listEnsemblArchives()
        ensembl <- useMart("ENSEMBL_MART_ENSEMBL", dataset="hsapiens_gene_ensembl",host='ensembl.org',archive=FALSE)
     ## List the available attributes and filters
        ensembllist <- listAttributes(ensembl)
        ensemblfilters <- listFilters(ensembl)
     ## Look for the specific genes in Ensembl https://www.ensembl.org/index.html
        genesofinterest <- c("ENSG00000104067","ENSG00000198788","ENSG00000071203","ENSG00000136869","ENSG00000281917","ENSG00000129226","ENSG00000169896")
        genesofinterest_IDs <- getBM(attributes=c("affy_hugene_2_0_st_v1","ensembl_gene_id","entrezgene_id","external_gene_name"), filters="ensembl_gene_id",values=genesofinterest, mart=ensembl)
        genesofinterest_IDs  <- na.omit(genesofinterest_IDs)
        genesofinterest_IDs

     ## Present DABG
        genesofinterest_IDs$affy_hugene_2_0_st_v1%in%CELdata_RMA_core_annotated_melt_present$fsetid

     ## Average expression
        CELdata_RMA_core_genesofinterest <- data.frame(CELdata_RMA_core_expr[rownames(CELdata_RMA_core_expr)%in%genesofinterest_IDs$affy_hugene_2_0_st_v1,])
        CELdata_RMA_core_genesofinterest <- mutate(CELdata_RMA_core_genesofinterest,Average_expression=rowMeans(CELdata_RMA_core_genesofinterest))

     ## Merge with table
        genesofinterest_IDs_expression <- merge(genesofinterest_IDs,CELdata_RMA_core_genesofinterest,by.y="row.names",by.x="affy_hugene_2_0_st_v1" ,all=TRUE,sort=FALSE)
        genesofinterest_IDs_expression <- genesofinterest_IDs_expression[-8,-c(1,5:13)]
        colnames(genesofinterest_IDs_expression) <- c("Ensembl gene ID","Entrez gene ID","Gene name","Average expression across all conditions")
        within(genesofinterest_IDs_expression,`Average expression across all conditions` <-  sprintf("%.0f",genesofinterest_IDs_expression$`Average expression across all conditions`)) 
        genesofinterest_IDs_expression

 },file="RDS_RMA_validation_triplecoculturemodel_expression")

## Display table
kable(genesofinterest_IDs_expression,booktabs = T,escape =F,linesep= "",caption = "\\label{validation:table1} Average above background expression for several genes of interest related to epithelial barrier integrity (TJP1 = ZO-1), mucus expression (MUC2), cell surface receptors (MS4A12), immune signalling (TLR4) and transport (SLC16A1 = MCT1), as well as, marker genes for the presence of macrophages (CD68, ITGAM = CD11b).",row.names = FALSE,format="latex") %>% kable_styling(font_size = 12,latex_options = "HOLD_position") %>%  row_spec(row = 0,bold = TRUE)
 @
\end{landscape}









\chapter{Differential expression analysis with Limma \label(limma)}
 Differential expression was assessed by means of the Limma package \Sexpr{packageVersion("limma")}) \cite{Ritchie2015,Phipson2016}. The central principle in Limma is to fit a linear model to the expression data of each gene, which can be either log-ratios or log-intensities. A moderated t-test or ANOVA with F-test statistic is then used to identify differential expression. An empirical Bayes method is used to moderate/smooth the standard errors of the estimated log-fold changes (e.g. standard errors are squeezed towards a common value by borrowing information across genes), making the analyses stable while at the same time improving the power, even for experiments with a small number of arrays.% This has the same interpretation as an ordinary t-statistic except that the standard errors have been moderated across genes using a simple Bayesian model. 
% In microarray analysis, the number of arrays often is quite small, and thus variance estimation is difficult. Using a combination of the per-gene-variance and a prior variance we can improve the variance estimate, hence the term “moderation”. “Empirical Bayes” means that the prior is estimated from the data. The result of the eBayes() step is that the individual variances are shrunken towards the prior value
% As with all model-based methods, the p-values depend on normality and other mathematical assumptions which are never exactly true for microarray data. It has been argued that the p-values are useful for ranking genes even in the presence of large deviations from the assumptions. Similarly, Benjamini and Hochberg's control of the false discovery rate (described below) assumes independence between genes, although Reiner et al. have argued that it works for many forms of dependence as well \cite{Reiner2003}. 

As we have 3 groups of samples (Blank/SHIME/SHIME\_LGG), a One-way ANOVA will be performed, followed by pairwise comparisons of contrasts. 

\section{Running limma on the raw data}
<<DE Limma,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
  # Check if the correct metadata is appended to the ExpressionFeature object
     CELdata_RMA_core_annotated_Eset_db@phenoData
     CELdata_RMA_core_annotated_Eset_db@phenoData@varMetadata
     CELdata_RMA_core_annotated_Eset_db@phenoData@data[,2]
  # Check if condition is specified as factor variable
     metadata_nocontrol$Condition <- factor(metadata_nocontrol$Condition,levels=c("Blank","SHIME","SHIME_LGG"))

  # Specify the design of the ANOVA model
     design = model.matrix(~ 0 + metadata_nocontrol$Condition)
     colnames(design)=c("Blank","SHIME","SHIME_LGG")
     design

  # Fit the ANOVA model
    data.fit = limma::lmFit(CELdata_RMA_core_annotated_Eset_db,design)
    data.fit$coefficients
    data.fit$df.residual
    hist(data.fit$Amean)
    plotSA(data.fit)
    CELdata_RMA_core_annotated_Eset_db_avexpr <- data.frame(data.fit$coefficients)
    CELdata_RMA_core_annotated_Eset_db_sdexpr <- t(ddply(cbind(t(CELdata_RMA_core_expr),metadata_nocontrol),.(Condition),numcolwise(sd)))

  # Specify contrasts of interest
    contrast.matrix = makeContrasts(SHIME-Blank,SHIME_LGG-Blank,SHIME_LGG-SHIME,levels=design)
    data.fit.con = contrasts.fit(data.fit,contrast.matrix)
    data.fit.eb = eBayes(data.fit.con,trend=TRUE,robust=TRUE)
    data.fit.eb_list <- unclass(data.fit.eb)

  # View ANOVA and pairwise t-test results
    ## Dimension
    dim(data.fit.eb)
    ## Log2 FC
    data.fit.eb$coefficients
    ## F test and corresponding p-value
    data.fit.eb$F
    data.fit.eb$F.p.value
    ## t test and corresponding p-value
    data.fit.eb$t
    data.fit.eb$p.value

  # Number of significant genes at the 5% significance level
    data.fit.ebsign <- data.fit.eb[data.fit.eb$F.p.value<0.05,]
    ## Dimension
    dim(data.fit.ebsign)
    colnames(data.fit.ebsign)
    rownames(data.fit.ebsign)

  # Pairwise comparisons results
    DEresults_SHIME_Blank_unfiltered = topTable(data.fit.eb,coef=1,number=53617,adjust.method="hochberg",sort.by="p")
    DEresults_SHIME_Blank_unfiltered
    DEresults_SHIMELGG_Blank_unfiltered = topTable(data.fit.eb,coef=2,number=53617,adjust.method="hochberg",sort.by="P")
    DEresults_SHIMELGG_Blank_unfiltered
    DEresults_SHIMELGG_SHIME_unfiltered = topTable(data.fit.eb,coef=3,number=53617,adjust.method="hochberg",sort.by="P")
    DEresults_SHIMELGG_SHIME_unfiltered
    DEresults_unfiltered <- rbind(cbind(comparison="SHIME_Blank",DEresults_SHIME_Blank_unfiltered),cbind(comparison="SHIMELGG_Blank",DEresults_SHIMELGG_Blank_unfiltered),cbind(comparison="SHIMELGG_SHIME",DEresults_SHIMELGG_SHIME_unfiltered))
    colnames(DEresults_unfiltered) <- c("Comparison","Affymetrix probe ID","Ensembl ID","Entrez ID","RefSeq ID","KEGG Pathway ID","Gene symbol","Gene name","LogFC","Average Expression","t-statistic","p-value","Adjusted p-value","Log-ods")

    write.csv(DEresults_unfiltered,paste0(path,"DE/","DEresults_unfiltered.csv"))
@

The ANOVA moderated F-statistic (F) combines the t-statistics for all the contrasts (3 groups) into an overall test of significance for that gene. The F-statistic tests whether any of the contrasts are non-zero for that gene, i.e., whether that gene is differentially expressed on any contrast.
%The denominator degrees of freedom is the same as that of the moderated-t. Its p-value is stored as fit$F.p.value. It is similar to the ordinary F-statistic from analysis of variance except that the denominator mean squares are moderated across genes.
The ANOVA F-test p-value is significant ($<$ 0.05) for \Sexpr{dim(data.fit.ebsign)} genes. To establish which of the 3 groups differ, the ANOVA will be followed by a series of pairwise comparisons to determine the t-statistics and corresponding p-values. The output of the moderated t-tests together with the Log2 fold Changes (logFC) stored in the coefficients data slot are used to construct volcano plots. Volcano plots arrange genes according to biological and statistical significance. The X-axis shows the logFC between the two groups (a positive logFC indicates up-regulated expression in the FC numerator), which represents biological impact of the change. The Y-axis displays the p-value of a t-test comparing samples (on a negative log scale so smaller p-values appear higher up) and hence indicates the statistical evidence of the change. A large number of significant genes was observed in all individual pairwise comparisons (contrasts), but only a fraction of genes displayed absolute log2FC $>$2 (Figure \ref{DE:fig1}).

%Limma provides functions topTable() and decideTests() which summarize the results of the linear model, perform hypothesis tests and adjust the p-values for multiple testing. Results include (log2) fold changes, standard errors, t-statistics and p-values.

The moderated t-test statistic is computed for each contrast and for each probe, resulting in a large number of hypotheses to be tested and the need for multiple testing correction. The most popular form of multiple testing adjustment is Benjamini and Hochberg's method to control the false discovery rate. The adjusted values are often called q-values if the intention is to control or estimate the false discovery rate. If all genes with q-value below a threshold, say 0.05, are selected as differentially expressed, then the expected proportion of false discoveries in the selected group is controlled to be less than the threshold value, in this case 5\%.

%A number of summary statistics are presented by topTable() for the top genes and the selected contrast. The logFC column gives the value of the contrast. Usually this represents a log2-fold change between two or more experimental conditions although sometimes it represents a log2-expression level. The AveExpr column gives the average log2-expression level for that gene across all the arrays and channels in the experiment. Column t is the moderated t-statistic. Column P.Value is the associated p-value and adj.P.Value is the p-value adjusted for multiple testing.

%The B-statistic (lods or B) is the log-odds that the gene is differentially expressed. Suppose for example that B = 1:5. The odds of differential expression is exp(1.5)=4.48, i.e, about four and a half to one. The probability that the gene is differentially expressed is 4.48/(1+4.48)=0.82, the probability is about 82% that this gene is differentially expressed. A B-statistic of zero corresponds to a 50-50 chance that the gene is differentially expressed. The B-statistic is automatically adjusted for multiple testing by assuming that 1% of the genes, or some other percentage specified by the user in the call to eBayes(), are expected to be differentially expressed. The p-values and B-statistics will normally rank genes in the same order. In fact, if the data contains no missing values or quality weights, then the order will be precisely the same.

%The B-statistic probabilities depend on the same assumptions but require in addition a prior guess for the proportion of differentially expressed probes. The p-values may be preferred to the B-statistics because they do not require this prior knowledge.

Implementing FDR control with Benjamini and Hochberg's method resulted in adjusted p-values equal to 1. This is an indication that there is no evidence of differential expression in the data after adjusting for multiple testing. This can occur even though many of the raw p-values may seem highly significant when taken as individual values. This situation typically occurs when none of the raw p-values are less than $\frac{1}{G}$, where G is the number of probes included in the fit. %In that case the adjusted p-values are typically equal to 1 using any of the adjustment methods except for adjust="none"

% Many scientific papers quote the non-adjusted p-values, however this is not a good idea for the massive number of comparisons you make for the identification of DE genes. Adjusted p-values accompanied by the FDR you used as a cutoff is much more accurate. As of yet no conventions have been established for false discovery rate in published work. An FDR of 5\% or less should be acceptable for journal publication of gene lists.

% The output from topTable includes adjusted p-values, i.e., it performs multiple testing for the contrast
% being considered. If several contrasts are being tested simultaneously, then the issue arises of multiple
% testing for the entire set of hypotheses being considered, across contrasts as well as probes. The
% function decideTests() offers a number of strategies for doing this.
%
% The simplest multiple testing method is method="separate". This method does multiple testing for each contrast separately. This method is the default because it is equivalent to using topTable(). Using this method, testing a set of contrasts together will give the same results as when each contrast is tested on its own. The great advantage of this method is that it gives the same results regardless of which set of contrasts are tested together. The disadvantage of this method is that it does not do any multiple testing adjustment between contrasts. Another disadvantage is that the raw p-value cutoff corresponding to significance can be very different for different contrasts, depending on the number of DE probes. This method is recommended when different contrasts are being analysed to answer more or less independent questions.
%
% method="global" is recommended when a set of closely related contrasts are being tested. This method simply appends all the tests together into one long vector of tests, i.e., it treats all the tests as equivalent regardless of which probe or contrast they relate to. An advantage is that the raw
% p-value cutoff is consistent across all contrasts. For this reason, method="global" is recommended if
% you want to compare the number of DE genes found for different contrasts, for example interpreting
% the number of DE genes as representing the strength of the contrast. However users need to be aware
% that the number of DE genes for any particular contrasts will depend on which other contrasts are
% tested at the same time. Hence one should include only those contrasts which are closely related to
% the question at hand. Unnecessary contrasts should be excluded as these would affect the results for
% the contrasts of interest. Another more theoretical issue is that there is no theorem which proves that
% adjust.method="BH" in combination with method="global" will correctly control the false discovery
% rate for combinations of negatively correlated contrasts, however simulations, experience and some
% theory suggest that the method is safe in practice
%
% method="nestedF" has a more specialised aim to give greater weight to probes that are significant
% for two or more contrasts. Most multiple testing methods tend to underestimate the number of such
% probes. There is some practical experience to suggest that method="nestedF" gives less conservative
% results when finding probes which respond to several different contrasts at once. However this method
% should still be viewed as experimental. It provides formal false discovery rate control at the probe
% level only, not at the contrast level.

Since the microarray design includes many genes \Sexpr{nrow(CELdata_RMA_core)}, it is common practice to apply a filtering prior to differential expression analysis to reduce the number of pairwise comparisons to be tested. Genes that are not expressed in any of the assessed conditions are by definition not differentially expressed, and such genes are unlikely to be of biological interest in a study. Removing such genes from further consideration increases the power of differential expression analysis \cite{Klaus2016}. Filtering can be done based on the average log expression values computed by the fit or through a more rigorous Detected Above Background (DABG) approach comparing the main probe intensities to the background probe intensities. Additionally a LFC cut-off can be defined to select genes with a strong biological meaning.

% table top function: number only affects the number of genes shown, not the number of genes for which multiple correction is applied => pre-filter to reduce nr of multiple comparisons  ZIE PG 106 affymetrix vignette

% To decide on the number of DE genes that you’re going to proceed with, you can make Volcano plots highlighting different numbers of genes. As you increase the number of genes highlighted on the plot, you can see at what point you begin to select genes with rather low fold changes. Make a conservative decision about the number of genes you want to use for follow up.

% DESeq2 has three optional additional features: automatic independent filtering, detection % of count outliers and shrinkage of the fold change estimation. Automatic independent % filtering can be applied on the p-values after the analysis. It uses average expression % strength across all samples as criterion to filter transcripts. These transcripts are believed % to have little chance to be differentially expressed. Removing them increases the power of % the analysis, because it decreases the number of hypotheses to be tested

%filterbyExpr edgeR
%geneFIlter

<<DE Limma volcanoplots,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
  # Autofunction limma
    volcanoplot(data.fit.eb,coef=1,highlight=20)
    volcanoplot(data.fit.eb,coef=2,highlight=20)
    volcanoplot(data.fit.eb,coef=3,highlight=20)

  # KDP function pretty
    volcano_SHIME_Blank <- volcanokim_limma(DEresults_SHIME_Blank_unfiltered,"fsetid",2,-2,"P.Value") + theme(legend.box = "vertical")
    volcano_legend <- get_legend(volcano_SHIME_Blank)
    volcano_SHIME_Blank <- volcano_SHIME_Blank + theme(legend.position = "none") + ggtitle(expression("FC = "~frac(SHIME,Blank)))
    volcano_SHIMELGG_Blank <- volcanokim_limma(DEresults_SHIMELGG_Blank_unfiltered,"fsetid",2,-2,"P.Value") + theme(legend.position = "none") + ggtitle(expression("FC = "~frac(SHIME~LGG,Blank)))
    volcano_SHIMELGG_SHIME <- volcanokim_limma(DEresults_SHIMELGG_SHIME_unfiltered,"fsetid",2,-2,"P.Value") + theme(legend.position = "none") + ggtitle(expression("FC = "~frac(SHIME~LGG,SHIME)))

    volcano_all <- ggdraw() + draw_plot(volcano_SHIME_Blank,0,0.5,0.5,0.5) + draw_plot(volcano_SHIMELGG_Blank,0.5,0.5,0.5,0.5) + draw_plot(volcano_SHIMELGG_SHIME,0,0,0.5,0.5) + draw_plot(volcano_legend,0.5,0,0.5,0.5)
@

<<DE Limma volcanoplots plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.show="TRUE",out.width="500pt",out.height="450pt",fig.cap="\\label{DE:fig1} Volcano plots.",fig.pos="H">>=
  #volcano_all
  tiff(paste0(path,"DE/volcanoplot_unfiltered.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  volcano_all
  dev.off()
  
  ggdraw() +  draw_image(image_read(paste0(path,"DE/volcanoplot_unfiltered.tiff"))) 
@

\section{Filtering criteria}

In order to assess the need for filtering, a histogram of the gene-wise median expression was constructed \cite{Klaus2016}. A large fraction of genes with a median expression below the average background signal was observed (Figure \ref{DE:fig2}).
%Transcripts that do not have intensities larger than the threshold in at least 3 arrays (replicates per experimental group) were removed.

\vspace{\fill}

<<DE Limma sample cutoff,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="TRUE",out.width="500pt",out.height="650pt">>=
# Number of samples per condition and minimal sample per condition number
    no_of_samples <-table(pData(CELdata_RMA_core)$Condition)
    no_of_samples

    samples_cutoff <- min(no_of_samples)
@

<<DE Limma median intensities filtering,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="TRUE",out.width="300pt",out.height="300pt",fig.cap="\\label{DE:fig2} A large fraction of genes with a median expression below the average background signal (threshold line of 3) was observed.",fig.pos="H">>=
  # Plot histogram of the median intensities
    CELdata_RMA_core_medians <- rowMedians(Biobase::exprs(CELdata_RMA_core))
    CELdata_RMA_core_medians <- data.frame(med=CELdata_RMA_core_medians)
    med_threshold <- CELdata_RMA_core_annotated_melt_present_avbgprobes$value
    med_threshold_av <- mean(CELdata_RMA_core_annotated_melt_present_avbgprobes$value)

    log2hist <- ggplot(CELdata_RMA_core_medians,aes(med))
    log2hist <- papertheme(log2hist,sizeselect = 12) + geom_histogram(show.legend = FALSE,fill="#fbab81",alpha=0.8)  + xlab("Median log2 probe intensities") +ylab("Density") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(color = "")
    log2hist <- log2hist + geom_vline(aes(xintercept = med_threshold_av),col="#87a7ca")
    log2hist

 # Remove genes below set threshold (in any of the three samples) in the expression feature set
   med_threshold <- 4
   idx_med_threshold <- apply(Biobase::exprs(CELdata_RMA_core_annotated_Eset_db), 1, function(x){sum(x > med_threshold) >=samples_cutoff})
   idx_med_threshold
   table(idx_med_threshold)

   CELdata_RMA_core_annotated_Eset_db_medfiltered <- subset(CELdata_RMA_core_annotated_Eset_db, idx_med_threshold)
   dim(CELdata_RMA_core_annotated_Eset_db_medfiltered)

 # # ALTERNATIVE Set Cutoff based on the average intensities and specify the keep in the fit model = not based on separate replicates
 #   Cutoff <- mean(CELdata_RMA_core_annotated_melt_present_avbgprobes$value)
 #   keep <- data.fit$Amean > Cutoff
 #   length(which(keep==TRUE))
 #   # Should be used with (and data.fit is full model specified above)
 #    contrast.matrix = makeContrasts(SHIME-Blank,SHIME_LGG-Blank,SHIME_LGG-SHIME,levels=design)
 #    data.fit.con = contrasts.fit(data.fit,contrast.matrix)
 #    data.fit.eb = eBayes(data.fit.con[keep,],trend=TRUE,robust=TRUE)
 #    data.fit.eb_list <- unclass(data.fit.eb)
@

<<DE Limma genefilter function,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE>>=
 # Explore the gene filter function (vignette TopGO package filtering)
   idx_genefil <- genefilter(CELdata_RMA_core_annotated_Eset_db, filterfun(pOverA(0.20, log2(100)), function(x) (IQR(x) > 0.25)))
   idx_genefil
   CELdata_RMA_core_annotated_Eset_db_genefiltered  <- CELdata_RMA_core_annotated_Eset_db[idx_genefil,]
   dim(CELdata_RMA_core_annotated_Eset_db_genefiltered)
@

To avoid having to set a random cut-off for the selection of genes to proceed with hypothesis testing, results from the DABG approach presented above were be used to only keep genes that are significantly (p<0.05) expressed above background on at least 3 arrays (3 replicates per condition).
%Filtering was done before the linear modeling and empirical Bayes moderation but after RMA pre-processing.

<<DE Limma DABG filtering,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show="hide">>=
  # Choose DABG p-value
    DABG_pset <- 0.01
  # Eliminate unexpressed probes
    ## Filtering out genes which are not detected above background (using the p-values calculated earlier as an indication) in at least 3 samples
    expressedgenes <- apply(pacall_RMA_TSDABG_pval, 1, function(x){sum(x <DABG_pset) >=samples_cutoff})
    table(expressedgenes)
    CELdata_RMA_core_annotated_Eset_db_DABGfiltered <- subset(CELdata_RMA_core_annotated_Eset_db, expressedgenes)
    dim(CELdata_RMA_core_annotated_Eset_db_DABGfiltered)

    CELdata_RMA_core_annotated_expressed <-  CELdata_RMA_core_annotated[CELdata_RMA_core_annotated$fsetid%in%rownames(CELdata_RMA_core_annotated_Eset_db_DABGfiltered),]
    dim(CELdata_RMA_core_annotated_expressed)

    #keep <- names(data.fit$Amean)%in%CELdata_RMA_core_annotated_main_expressed$fsetid
    #length(which(keep==TRUE))
@

Additionally, probes that don't correspond to any known gene, i.e. that do not have a gene symbol assigned or probes with an ambiguous annotation that map to multiple gene symbols were excluded \cite{Klaus2016}.

%before continuing with the linear models for microarrays and differential expression, we first add “feature data”, i.e. annotation information to the transcript cluster identifiers stored in the featureData of our ExpressionSet:We used the function select from AnnotationDbi to query the gene symbols and associated short descriptions for the transcript clusters. For each cluster, we added the gene symbol (SYMBOL) and a short description of the gene the cluster represents (GENENAME). In a second step, we filtered out the probes that do not map to a gene, i.e. that do not have a gene symbol assigned.

% Many transcript-cluster identifiers will map to multiple gene symbols, i.e. they can’t be unambigously assigned. We compute a summary table in the code below to see how many there are: We have close to 2000 transcript clusters that map to multiple gene symbols. It is difficult to decide which mapping is
% “correct”. Therefore, we exclude these transcript clusters. We want to remove those probe IDs that match the ones in probe_stats, as those are the probes with multiple mappings. We assign these IDs to the variable ids_to_exclude.

<<DE Limma gene annotation extra filtering,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show="hide">>=

   # Choose either average expression CELdata_RMA_core_medfiltered or DABG filtering CELdata_RMA_core_DABGfiltered here
     CELdata_RMA_core_annotated_Eset_db_filtered <- CELdata_RMA_core_annotated_Eset_db_DABGfiltered

   # Eliminate control probes  = all probes with annotation different from main
     CELdata_RMA_core_annotated_Eset_db_filtered_annotated <- merge(exprs(CELdata_RMA_core_annotated_Eset_db_filtered),gene_annotation,by="row.names",all=FALSE,sort=FALSE)[,-1]

     CELdata_RMA_core_annotated_Eset_db_filtered <- CELdata_RMA_core_annotated_Eset_db_filtered[CELdata_RMA_core_annotated_Eset_db_filtered_annotated$type=="main",]
     dim(CELdata_RMA_core_annotated_Eset_db_filtered)

   # Annotating the filtered transcript clusters
     ## Remove transcript clusters that could not be mapped to a gene symbol
        CELdata_RMA_core_annotated_Eset_db_filtered_anno <- AnnotationDbi::select(hugene20sttranscriptcluster.db,keys = (featureNames(CELdata_RMA_core_annotated_Eset_db_filtered)),columns = c("SYMBOL", "GENENAME"),keytype = "PROBEID")
        dim(CELdata_RMA_core_annotated_Eset_db_filtered_anno)
        length(unique(CELdata_RMA_core_annotated_Eset_db_filtered_anno$PROBEID))
        CELdata_RMA_core_annotated_Eset_db_filtered_anno <- subset(CELdata_RMA_core_annotated_Eset_db_filtered_anno, !is.na(SYMBOL))
        length(CELdata_RMA_core_annotated_Eset_db_filtered_anno$PROBEID)
        length(unique(CELdata_RMA_core_annotated_Eset_db_filtered_anno$PROBEID))
        CELdata_RMA_core_annotated_Eset_db_filtered <- CELdata_RMA_core_annotated_Eset_db_filtered[unique(CELdata_RMA_core_annotated_Eset_db_filtered_anno$PROBEID),]

        dim(CELdata_RMA_core_annotated_Eset_db_filtered)
     ## Remove transcript clusters with multiple (unambiguous) mappings to gene symbols
        anno_grouped <- group_by(CELdata_RMA_core_annotated_Eset_db_filtered_anno, PROBEID)
        anno_summarized <- dplyr::summarize(anno_grouped, no_of_matches = n_distinct(SYMBOL))
        head(anno_summarized)
        anno_filtered <- filter(anno_summarized, no_of_matches > 1)
        probe_stats <- anno_filtered
        nrow(probe_stats)
        ids_to_exlude <- (featureNames(CELdata_RMA_core_annotated_Eset_db_filtered) %in% probe_stats$PROBEID)
        table(ids_to_exlude)
        ids_to_exlude

        CELdata_RMA_core_annotated_Eset_db_filtered <- subset(CELdata_RMA_core_annotated_Eset_db_filtered, !ids_to_exlude)
        validObject(CELdata_RMA_core_annotated_Eset_db_filtered)
        dim(CELdata_RMA_core_annotated_Eset_db_filtered)
        length(unique(rownames(CELdata_RMA_core_annotated_Eset_db_filtered)))

    ##  Add annotations
        fData(CELdata_RMA_core_annotated_Eset_db_filtered)$PROBEID <- rownames(fData(CELdata_RMA_core_annotated_Eset_db_filtered))
        fData(CELdata_RMA_core_annotated_Eset_db_filtered) <- left_join(fData(CELdata_RMA_core_annotated_Eset_db_filtered),CELdata_RMA_core_annotated_Eset_db_filtered_anno)
        rownames(fData(CELdata_RMA_core_annotated_Eset_db_filtered)) <- fData(CELdata_RMA_core_annotated_Eset_db_filtered)$PROBEID
        validObject(CELdata_RMA_core_annotated_Eset_db_filtered)
@

\Sexpr{dim(CELdata_RMA_core_annotated_Eset_db_filtered)[1]} genes were retained for differential expression analysis using Limma as described before (Figure \ref{DE:fig3}).

\clearpage
\section{Running limma on the DABG filtered data \label{limmafiltered}}

<<DE Limma filtered,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show="hide">>=
  # Check if the correct metadata is appended to the ExpressionFeature object
     CELdata_RMA_core_annotated_Eset_db_filtered@phenoData
     CELdata_RMA_core_annotated_Eset_db_filtered@phenoData@varMetadata
     CELdata_RMA_core_annotated_Eset_db_filtered@phenoData@data[,2]
  # Check if condition is specified as factor variable
     metadata_nocontrol$Condition <- factor(metadata_nocontrol$Condition,levels=c("Blank","SHIME","SHIME_LGG"))

  # Specify the design of the ANOVA model
     design = model.matrix(~ 0 + metadata_nocontrol$Condition)
     colnames(design)=c("Blank","SHIME","SHIME_LGG")
     design

  # Fit the ANOVA model
    data.fit = limma::lmFit(CELdata_RMA_core_annotated_Eset_db_filtered,design)
    data.fit$coefficients
    data.fit$df.residual
    hist(data.fit$Amean)
    plotSA(data.fit)
    CELdata_RMA_core_annotated_Eset_db_filtered_avexpr <- data.frame(data.fit$coefficients)

  # Specify contrasts of interest
    contrast.matrix = makeContrasts(SHIME-Blank,SHIME_LGG-Blank,SHIME_LGG-SHIME,levels=design)
    data.fit.con = contrasts.fit(data.fit,contrast.matrix)
    data.fit.eb = eBayes(data.fit.con,trend=TRUE,robust=TRUE)
    data.fit.eb_list <- unclass(data.fit.eb)

  # View ANOVA and pairwise t-test results
    ## Dimension
    dim(data.fit.eb)
    ## Log2 FC
    data.fit.eb$coefficients
    ## F test and corresponding p-value
    data.fit.eb$F
    data.fit.eb$F.p.value
    ## t test and corresponding p-value
    data.fit.eb$t
    data.fit.eb$p.value

  # Number of significant genes at the 5% significance level
    data.fit.ebsign <- data.fit.eb[data.fit.eb$F.p.value<0.05,]
    ## Dimension
    dim(data.fit.ebsign)
    colnames(data.fit.ebsign)
    rownames(data.fit.ebsign)

  # Pairwise comparisons results
    DEresults_SHIME_Blank_filtered = topTable(data.fit.eb,coef=1,number=Inf,adjust.method="BH",sort.by="p")
    DEresults_SHIME_Blank_filtered
    hist(DEresults_SHIME_Blank_filtered$P.Value, col = brewer.pal(3, name = "Set2")[1],
main = "Blank vs SHIME", xlab = "p-values")
    #p.adjust(DEresults_SHIME_Blank$P.Value,method="hochberg")
    DEresults_SHIMELGG_Blank_filtered = topTable(data.fit.eb,coef=2,number=Inf,adjust.method="BH",sort.by="P")
    DEresults_SHIMELGG_Blank_filtered
    hist(DEresults_SHIMELGG_Blank_filtered$P.Value, col = brewer.pal(3, name = "Set2")[1],
main = "Blank vs SHIME_LGG", xlab = "p-values")
    DEresults_SHIMELGG_SHIME_filtered = topTable(data.fit.eb,coef=3,number=Inf,adjust.method="BH",sort.by="P")
    DEresults_SHIMELGG_SHIME_filtered
    hist(DEresults_SHIMELGG_SHIME_filtered$P.Value, col = brewer.pal(3, name = "Set2")[1],
main = "SHIME vs SHIME_LGG", xlab = "p-values")
    DEresults_filtered <- rbind(cbind(comparison="SHIME_Blank",DEresults_SHIME_Blank_filtered),cbind(comparison="SHIMELGG_Blank",DEresults_SHIMELGG_Blank_filtered),cbind(comparison="SHIMELGG_SHIME",DEresults_SHIMELGG_SHIME_filtered))
    colnames(DEresults_filtered) <- c("Comparison","Affymetrix probe ID","Ensembl ID","Entrez ID","RefSeq ID","KEGG Pathway ID","Gene symbol","Gene name","LogFC","Average Expression","t-statistic","p-value","Adjusted p-value","Log-ods")
    dim(DEresults_filtered)
    write.csv(DEresults_filtered,paste0(path,"DE/","DEresults_filtered_all.csv"))
@

<<DE Limma filtered volcanoplots,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show="hide">>=
  # Autofunction limma
    volcanoplot(data.fit.eb,coef=1,highlight=20)
    volcanoplot(data.fit.eb,coef=2,highlight=20)
    volcanoplot(data.fit.eb,coef=3,highlight=20)

  # KDP function pretty
    volcano_SHIME_Blank <- volcanokim_limma(DEresults_SHIME_Blank_filtered,"fsetid",1,-1,p="P.Value") + theme(legend.box = "vertical")
    volcano_legend <- get_legend(volcano_SHIME_Blank)
    volcano_SHIME_Blank <- volcano_SHIME_Blank + theme(legend.position = "none") + ggtitle(expression("FC = "~frac(SHIME,Blank))) + xlim(-3,3) + geom_hline(yintercept =-log10(0.01),linetype="dashed",color="red")
    volcano_SHIMELGG_Blank <- volcanokim_limma(DEresults_SHIMELGG_Blank_filtered,"fsetid",1,-1,p="P.Value") + theme(legend.position = "none") + ggtitle(expression("FC = "~frac(SHIME~LGG,Blank))) + xlim(-2,2) + geom_hline(yintercept =-log10(0.01),linetype="dashed",color="red")
    volcano_SHIMELGG_SHIME <- volcanokim_limma(DEresults_SHIMELGG_SHIME_filtered,"fsetid",1,-1,p="P.Value") + theme(legend.position = "none") + ggtitle(expression("FC = "~frac(SHIME~LGG,SHIME))) + xlim(-2,2) + geom_hline(yintercept =-log10(0.01),linetype="dashed",color="red")

    volcano_all <- ggdraw() + draw_plot(volcano_SHIME_Blank,0,0.5,0.5,0.5) + draw_plot(volcano_SHIMELGG_Blank,0.5,0.5,0.5,0.5) + draw_plot(volcano_SHIMELGG_SHIME,0,0,0.5,0.5) + draw_plot(volcano_legend,0.5,0,0.5,0.5)
@

<<DE Limma filtered volcanoplots plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.show="TRUE",out.width="500pt",out.height="450pt",fig.cap="\\label{DE:fig3} Volcano plots of the pre-filtered gene expression data.",fig.pos="H">>=
  #volcano_all
  tiff(paste0(path,"DE/volcanplot_filtered.tiff"),width=10*dpi,height=10*dpi,res=dpi,compression="lzw")
  volcano_all
  dev.off()
  
  ggdraw() +  draw_image(image_read(paste0(path,"DE/volcanplot_filtered.tiff"))) 
@

<<DE Limma select significant genes after multiple testing,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show="hide">>=
  # Subset the results
    ## Threshold
       pvalthres <- 0.05
    ## DEresults_SHIME_Blank_topgenes <- DEresults_SHIME_Blank[DEresults_SHIME_Blank$adj.P.Val<0.05,] Cannot be done based on adjusted pvalues because none of those is still significant
       DEresults_SHIME_Blank_significantgenes <- DEresults_SHIME_Blank_filtered[DEresults_SHIME_Blank_filtered$P.Value<pvalthres,]
       DEresults_SHIME_Blank_significantgenes
       DEresults_SHIMELGG_Blank_significantgenes <- DEresults_SHIMELGG_Blank_filtered[DEresults_SHIMELGG_Blank_filtered$P.Value<pvalthres,]
       DEresults_SHIMELGG_Blank_significantgenes
       DEresults_SHIMELGG_SHIME_significantgenes <- DEresults_SHIMELGG_SHIME_filtered[DEresults_SHIMELGG_SHIME_filtered$P.Value<pvalthres,]
       DEresults_SHIMELGG_SHIME_significantgenes

  # Write out to excel table
       DEresults_filtered_significant <- rbind(cbind(comparison="SHIME_Blank",DEresults_SHIME_Blank_significantgenes),cbind(comparison="SHIMELGG_Blank",DEresults_SHIMELGG_Blank_significantgenes),cbind(comparison="SHIMELGG_SHIME",DEresults_SHIMELGG_SHIME_significantgenes))
       colnames(DEresults_filtered_significant) <- c("Comparison","Affymetrix probe ID","Ensembl ID","Entrez ID","RefSeq ID","KEGG Pathway ID","Gene symbol","Gene name","LogFC","Average Expression","t-statistic","p-value","Adjusted p-value","Log-ods")
       write.csv(DEresults_filtered_significant,paste0(path,"DE/","DEresults_filtered_significant.csv"))
@

A shortlist of top genes considered 'most' differentially expressed (with the lowest adjusted p-values and the most extreme log fold changes) was compiled for further visualization and analysis.

\vspace{\fill}

<<DE Limma select top genes after multiple testing,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show="hide">>=
  # Subset the results
    ## Threshold
       logFCthres <- 1
       pvalthres <- 0.05
    ## DEresults_SHIME_Blank_topgenes <- DEresults_SHIME_Blank[DEresults_SHIME_Blank$adj.P.Val<0.05,] Cannot be done based on adjusted pvalues because none of those is still significant
       DEresults_SHIME_Blank_topgenes <- DEresults_SHIME_Blank_filtered[abs(DEresults_SHIME_Blank_filtered$logFC)>logFCthres&DEresults_SHIME_Blank_filtered$P.Value<pvalthres,]
       DEresults_SHIME_Blank_topgenes
       DEresults_SHIMELGG_Blank_topgenes <- DEresults_SHIMELGG_Blank_filtered[abs(DEresults_SHIMELGG_Blank_filtered$logFC)>logFCthres&DEresults_SHIMELGG_Blank_filtered$P.Value<pvalthres,]
       DEresults_SHIMELGG_Blank_topgenes
       DEresults_SHIMELGG_SHIME_topgenes <- DEresults_SHIMELGG_SHIME_filtered[abs(DEresults_SHIMELGG_SHIME_filtered$logFC)>logFCthres&DEresults_SHIMELGG_SHIME_filtered$P.Value<pvalthres,]
       DEresults_SHIMELGG_SHIME_topgenes

  # Write out to excel table
       DEresults_filtered_top <- rbind(cbind(comparison="SHIME_Blank",DEresults_SHIME_Blank_topgenes),cbind(comparison="SHIMELGG_Blank",DEresults_SHIMELGG_Blank_topgenes),cbind(comparison="SHIMELGG_SHIME",DEresults_SHIMELGG_SHIME_topgenes))
       colnames(DEresults_filtered_top) <- c("Comparison","Affymetrix probe ID","Ensembl ID","Entrez ID","RefSeq ID","KEGG Pathway ID","Gene symbol","Gene name","LogFC","Average Expression","t-statistic","p-value","Adjusted p-value","Log-ods")
       dim(DEresults_filtered_top)
       write.csv(DEresults_filtered_top,paste0(path,"DE/","DEresults_filtered_top.csv"))
@

A reduced number of significant genes (p$<$0.05), with a LogFC exceeding \Sexpr{logFCthres} was visualized in heatmaps (\ref{DE:fig4}).

<<DE Limma heatmap top genes,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.show="TRUE",out.width="500pt",out.height="700pt",fig.cap="\\label{DE:fig4} Heatmaps displaying the gene expression of significant genes with abs(LogFC) exceeding 1.",fig.pos="H">>=
  # Number of rows in the heatmap
    unique(DEresults_filtered_top$`Affymetrix probe ID`)

  # Numeric dataframe with average expression per condition
    DEresults_hm <- CELdata_RMA_core_annotated_Eset_db_avexpr[unique(DEresults_filtered_top$`Affymetrix probe ID`),]
    DEresults_hm <- merge(DEresults_hm,DEresults_filtered_top,by="row.names")
    DEresults_hm$gene_id <- paste(DEresults_hm$`Affymetrix probe ID`,DEresults_hm$`Gene symbol`,DEresults_hm$`Gene name`,sep="_")
    rownames(DEresults_hm) <- DEresults_hm$gene_id
    DEresults_hm_num <- DEresults_hm %>% dplyr::select(c("Blank","SHIME","SHIME_LGG"))

    DEresults_side <- DEresults_filtered_top[DEresults_filtered_top$`Affymetrix probe ID` %in% DEresults_hm$`Affymetrix probe ID`,]
    DEresults_side$gene_id <- paste(DEresults_side$`Affymetrix probe ID`,DEresults_side$`Gene symbol`,DEresults_side$`Gene name`,sep="_")
    DEresults_side$upregulated <- "Blank"
    DEresults_side[DEresults_side$Comparison=="SHIME_Blank"&DEresults_side$LogFC>0,]$upregulated <- "SHIME"
    DEresults_side[DEresults_side$Comparison=="SHIMELGG_Blank"&DEresults_side$LogFC>0,]$upregulated <- "SHIME_LGG"
    DEresults_side[DEresults_side$Comparison=="SHIMELGG_SHIME"&DEresults_side$LogFC>0,]$upregulated <- "SHIME_LGG"
    DEresults_side[DEresults_side$Comparison=="SHIMELGG_SHIME"&DEresults_side$LogFC<0,]$upregulated <- "SHIME"
    DEresults_side <- DEresults_side[order(rownames(DEresults_side)),]

    DEresults_LFC_side <- reshape2::dcast(DEresults_side,gene_id~Comparison,value.var='LogFC')
    DEresults_LFC_side <- DEresults_LFC_side[order(rownames(DEresults_hm_num)),]

    DEresults_fill_side <- reshape2::dcast(DEresults_side,gene_id~Comparison,value.var='upregulated')
    DEresults_fill_side <- DEresults_fill_side[order(rownames(DEresults_hm_num)),]

  # Heatmap annotations
    hmfontsize <- 16
    # rowsplitPPI <- ancombc_modelfull_res_PPI$level # cool if this could be ontology based
    rowsideplot_SHIME_Blank <- abs(DEresults_LFC_side$SHIME_Blank)
    rowside_SHIME_Blank_fill <- DEresults_fill_side$SHIME_Blank
    rowside_SHIME_Blank_fill <- mapvalues(rowside_SHIME_Blank_fill,from=c("Blank","SHIME","SHIME_LGG"),to=c("#ee7600A6","#756bb1A6","#8b0a50A6"))

    rowsideplot_SHIMELGG_Blank <- abs(DEresults_LFC_side$SHIMELGG_Blank)
    rowside_SHIMELGG_Blank_fill <- DEresults_fill_side$SHIMELGG_Blank
    rowside_SHIMELGG_Blank_fill <- mapvalues(rowside_SHIMELGG_Blank_fill,from=c("Blank","SHIME","SHIME_LGG"),to=c("#ee7600A6","#756bb1A6","#8b0a50A6"))

    rowsideplot_SHIMELGG_SHIME <- abs(DEresults_LFC_side$SHIMELGG_SHIME)
    rowside_SHIMELGG_SHIME_fill <- DEresults_fill_side$SHIMELGG_SHIME
    rowside_SHIMELGG_SHIME_fill <- mapvalues(rowside_SHIMELGG_SHIME_fill,from=c("Blank","SHIME","SHIME_LGG"),to=c("#ee7600A6","#756bb1A6","#8b0a50A6"))

    colside1 <- colnames(DEresults_hm_num)
    colside1fill <- mapvalues(colside1,from=unique(colside1),to=c("#ee7600A6","#756bb1A6","#8b0a50A6"))
    names(colside1fill) <- colside1

    ha=HeatmapAnnotation(Sample=anno_block(gp = gpar(fill=colside1fill),labels=colside1))

    hb = HeatmapAnnotation(SHIME_Blank=row_anno_barplot(rowsideplot_SHIME_Blank,axis=TRUE,gp = gpar(fill = rowside_SHIME_Blank_fill),axis_param = list(gp=gpar(fontsize = hmfontsize-2),at=c(0,2),labels=c(0,2)),width = unit(2.5, "cm")),which="row",annotation_name_rot = 90)
    hc = HeatmapAnnotation(SHIMELGG_Blank=row_anno_barplot(rowsideplot_SHIMELGG_Blank,axis=TRUE,gp = gpar(fill = rowside_SHIMELGG_Blank_fill),axis_param = list(gp=gpar(fontsize = hmfontsize-2),at=c(0,1),labels=c(0,1)),width = unit(2.5, "cm")),which="row",annotation_name_rot = 90)
    hd = HeatmapAnnotation(SHIMELGG_SHIME=row_anno_barplot(rowsideplot_SHIMELGG_SHIME,axis=TRUE,gp = gpar(fill = rowside_SHIMELGG_SHIME_fill),axis_param = list(gp=gpar(fontsize = hmfontsize-2),at=c(0,1),labels=c(0,1)),width = unit(2.5, "cm")),which="row",annotation_name_rot = 90)
    he = ComplexHeatmap::rowAnnotation(rn=anno_text(paste(DEresults_hm$`Affymetrix probe ID`,DEresults_hm$`Gene name`,sep="  "),gp=gpar(fontface = "italic",fontsize=hmfontsize)))

    my_palette <- colorRamp2(c(min(DEresults_hm_num),2,4,6,7,max(DEresults_hm_num)),colors=c("black",'#ADD8E6',"#7EC0EE","blue",'#FFEC8B',"yellow"))

    heatmap_DE <- Heatmap(DEresults_hm_num,column_split=colnames(DEresults_hm_num),cluster_rows = TRUE,cluster_columns=FALSE,heatmap_legend_param =list(color_bar="continuous",title="Log2 expression",legend_direction = "horizontal",legend_width = unit(5, "cm"),title_gp=gpar(fontsize=16,fontface="bold"),labels_gp=gpar(fontsize=hmfontsize)), show_row_names = TRUE,row_names_gp = gpar(fontface = "italic",fontsize=16),show_column_names = FALSE,row_title_gp = gpar(fontface = "bold",fontsize=hmfontsize),show_heatmap_legend = FALSE, row_title_rot = 0,column_title = NULL, row_gap = unit(2, "mm"), column_gap = unit(c(2), "mm"),top_annotation=ha,col=my_palette)
    leg <- Legend(col_fun = my_palette, title = "Log2 expression",direction="horizontal",legend_width = unit(7, "cm"),legend_height =  unit(5, "cm"),labels_gp=gpar(fontsize=hmfontsize),title_gp=gpar(fontsize=hmfontsize,fontface="bold"))

   #draw(heatmap_DE + hb + hc + hd + he)
   #draw(leg, x = unit(0.83, "npc"), y = unit(1, "npc"), just = c("right", "top"))

tiff(paste0(path,"DE/DE_heatmap.tiff"),width=14*dpi,height=14*dpi,res=dpi,compression="lzw")
draw(heatmap_DE + hb + hc + hd + he, padding = unit(c(0,0,1.3,0),"cm"))
draw(leg, x = unit(0.5, "npc"), y = unit(1, "npc"), just = c("right", "top"))
dev.off()

ggdraw() +  draw_image(image_read(paste0(path,"DE/DE_heatmap.tiff"))) 
@

 
    
\chapter{Gene ontology enrichment analysis}      
The identified significantly differentially expressed genes in response to SHIME or SHIME+LGG exposure are not confined entities and several gene products may positively or negatively interact and can even be involved in a signalling cascade or contribute to the same biological process. For instance, a rapid visual inspection of the differential expression analysis results reveals a number of gene names that relate to a pro-inflammatory response.
To automate the detection of functional relations between the retrieved significantly differentially expressed genes, a gene ontology (GO) enrichment analysis was performed with the topGO package version (\Sexpr{packageVersion("topGO")}). Essentially the gene ontology (\url{http://www.geneontology.org/}) is a hierarchically organized collection of gene annotations organized in three domains: Molecular Function, Cellular Component and Biological Process \cite{Klaus2016}.

Molecular function GO terms describe activities performed by individual (or sometimes complexes composed of multiple) gene products (i.e. proteins or RNA) occurring at the molecular level without specifying the location and context in which these activities take place.
%Examples of broad functional terms are catalytic activity and transporter activity; examples of narrower functional terms are adenylate cyclase activity or Toll-like receptor binding. To avoid confusion between gene product names and their molecular functions, GO molecular functions are often appended with the word “activity” (a protein kinase would have the GO molecular function protein kinase activity).
Cellular Component GO terms refer to the locations relative to cellular structures in which a gene product performs a function, either cellular compartments (e.g., mitochondrion), or stable macromolecular complexes of which they are parts (e.g., the ribosome). %Unlike the other aspects of GO, cellular component classes refer not to processes but rather a cellular anatomy.
Biological Process GO terms, finally, delineate the larger processes, or ‘biological programs’ accomplished by multiple molecular activities. This is not equivalent to pathways since the dynamics and dependencies between genes involved in the same biological process are not specified by gene ontology.
%Examples of broad biological process terms are DNA repair or signal transduction. Examples of more specific terms are pyrimidine nucleobase biosynthetic process or glucose transmembrane transport. Note that a biological process is not equivalent to a pathway. At present, the GO does not try to represent the dynamics or dependencies that would be required to fully describe a pathway.

Gene ontology terms (BP,CC,MF) were build based on the GOTERM environment from package GO.db version \Sexpr{packageVersion("GO.db")} and extracted from the gene-to-GO mapping for the Affymetrix Human Gene 2.1 ST Array Strip (hugene20sttranscriptcluster.db) using annFUN.db.

To find gene ontology terms that are enriched in the significantly differentially expressed genes, a background set of non-differentially expressed genes with similar average expression strength is defined using the genefinder function from the genefilter package version \Sexpr{packageVersion("genefilter")}. The background was shown to have roughly the same distribution as the significant genes of interest (Figure \ref{GO:fig1}). Due to the prior filtering step, the distribution was even similar for all genes retained after DABG filtering used as input for Limma based differential expression hypothesis testing (See section \ref{limmafiltered}). This in contrast to the unfiltered gene population which is clearly enriched in unexpressed genes (expressions $\leq$ background probe intensities).
% We do this in order not to select a biased background since the gene set testing is performed by a simple Fisher test on a 2x2 table. Note that this approach is very similar to commonly used web tools like GOrilla22. When comparing the “background gene” curve to the “foreground gene” curve, we see a similar curve shape,indicating a sensible background matching (Figure 15). Note that the right-shift of the “foreground-gene” curve in comparison to the “background-gene” curve indicates that DE-genes are generally very highly expressed, so that it wasn’t possible to find background-genes with exactly equal overall expression distribution. The “all gene” curve has the leftmost curve maximum; this can be explained by a high number of lowly expressed genes in all samples and shows that a background matching is sensible in order to avoid biases.

% Note: Too many probes will result in too conservative adjusted p-values which can bias the result of tests like Fisher's exact test.

Enrichment of gene ontology terms of interest (BP, MF, CC) in the significantly differentially expressed genes (Limma p-value <0.01, see \ref{limma}) compared to the background genes was determined with Fisher's exact tests for every GO category independently and Kolmogorov-Smirnov tests in combination with a more complex elim algorithm which take the hierarchical GO dependencies into account.
%Fisher's exact test which is based on gene counts, and a Kolmogorov-Smirnov like test which computes enrichment based on gene scores. Fisher: makes a continegency table with the number of significant and non-significant genes in the specific GO term of interest vs all other GO terms
%We run two common tests: an ordinary Fisher test for every GO category, and the “elim” algorithm, which tries to incorporate the hierarchical structure of the GO and tries to “decorrelate” it in order to report the most specific significant term in the hierarchy. The algorithm starts processing the nodes / GO categories from the highest (bottommost) level and then iteratively moves to nodes from a lower level. If a node is scored as significant, all of its genes are marked as removed in all ancestor nodes. This way, the “elim” algorithm aims at finding the most specific node for every gene
%The elim method was design to be more conservative then the classic method and therefore one expects the p-values returned by the former method are lower bounded by the p-values returned by the later method.
The hierarchical gene ontology structure was pruned to remove terms with less than 10 annotated genes.
%The nodeSize parameter specifies a minimum size of a GO category we want to use: i.e. here, categories with less than 10 genes are not included in the testing.
%It is often the case that many GO terms which have few annotated genes are detected to be signicantly enriched due to artifacts in the statistical test. These small sized GO terms are of less importance for the analysis and in many cases they can be omitted. By using the nodeSize argument the user can control the size of the GO terms used in the analysis. Once the genes are annotated to the each GO term and the true path rule is applied the nodes with less than nodeSize annotated genes are removed from the GO hierarchy. We found that values between 5 and 10 for the nodeSize parameter yield more stable results. The default value for the nodeSize parameter is 1, meaning that no pruning is performed.
%The p-values computed by the runTest function are unadjusted for multiple testing. We do not advocate against adjusting the p-values of the tested groups, however in many cases adjusted p-values might be misleading.
%One way to check this hypothesis is to compare the distribution of the gene scores annotated to the specified GO term with the distribution of the scores of the complementary gene set (all the genes in the gene universe which are not annotated to the GO term). This can be easily achieved using the showGroupDensity function.

Over-represented GO terms were exported in a supplementary excel file and visualized in a GO graph displaying the
most significant GO terms (rectangles) and their distribution in the GO hierarchy (Figure \ref{GO:fig2}- Figure \ref{GO:fig3}).

<<GO background genes for gene ontology enrichment analysis,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,fig.show="hide">>=
# Define background genes
    DEback_genes_idx <- genefilter::genefinder(CELdata_RMA_core_annotated_Eset_db_filtered,unique(DEresults_filtered_significant$`Affymetrix probe ID`),method = "manhattan", scale = "none")
    DEback_genes_idx <- sapply(DEback_genes_idx, function(x)x$indices)

    DEback_genes <- featureNames(CELdata_RMA_core_annotated_Eset_db_filtered)[DEback_genes_idx]
    DEback_genes <- setdiff(DEback_genes,DEresults_filtered_significant$`Affymetrix probe ID`)

    intersect(DEback_genes, DEresults_filtered_significant$`Affymetrix probe ID`)
    length(DEback_genes)

# Plot distribution of background and foreground genes
    multidensity_genes <- data.frame(rbind(cbind(val=DEresults_unfiltered[,"Average Expression"],geneset ="All unfiltered genes"),cbind(val=DEresults_filtered[,"Average Expression"],geneset ="All filtered genes"),cbind(val=DEresults_filtered[DEresults_filtered_significant$`Affymetrix probe ID`, "Average Expression"],geneset="significant genes of interest"),cbind(val=DEresults_filtered[rownames(DEresults_filtered) %in% DEback_genes, "Average Expression"],geneset="Background")))

    log2dens <- ggplot(multidensity_genes,aes(x=as.numeric(val),fill=geneset))
    log2dens <- papertheme(log2dens,sizeselect = 12) + geom_density(alpha=0.5)  + xlab("Mean log2 probe intensities") +ylab("Density") + scale_y_continuous(labels=function(x) sprintf("%.2f", x)) + labs(color = "")
    log2dens
    
    tiff(paste0(path,"DE/back_foregroundgenes.tiff"),width=10*dpitiff,height=4*dpitiff,res=dpitiff,compression="lzw")
    log2dens
    dev.off()

# Define selection and universe of genes
    in_universe <- c(DEresults_filtered_significant$`Affymetrix probe ID`, DEback_genes)
    #in_universe <- c(DEresults_filtered_significant$`Affymetrix probe ID`,DEresults_filtered$`Affymetrix probe ID`)
    in_selection <- DEresults_filtered_significant$`Affymetrix probe ID`

# Find corresponding p-values of the universe of genes for each pairwise comparison
     pval_universe_SHIME_Blank <- DEresults_filtered[DEresults_filtered$`Affymetrix probe ID`%in%in_universe,] %>% subset(Comparison=="SHIME_Blank")
     pval_universe_SHIME_Blank_vector <- as.numeric(pval_universe_SHIME_Blank$`p-value`)
     names(pval_universe_SHIME_Blank_vector) <- pval_universe_SHIME_Blank$`Affymetrix probe ID`

     pval_universe_SHIMELGG_Blank <- DEresults_filtered[DEresults_filtered$`Affymetrix probe ID`%in%in_universe,] %>% subset(Comparison=="SHIMELGG_Blank")
     pval_universe_SHIMELGG_Blank_vector <- as.numeric(pval_universe_SHIMELGG_Blank$`p-value`)
     names(pval_universe_SHIMELGG_Blank_vector) <- pval_universe_SHIMELGG_Blank$`Affymetrix probe ID`

     pval_universe_SHIMELGG_SHIME <- DEresults_filtered[DEresults_filtered$`Affymetrix probe ID`%in%in_universe,] %>% subset(Comparison=="SHIMELGG_SHIME")
     pval_universe_SHIMELGG_SHIME_vector <- as.numeric(pval_universe_SHIMELGG_SHIME$`p-value`)
     names(pval_universe_SHIMELGG_SHIME_vector) <- pval_universe_SHIMELGG_SHIME$`Affymetrix probe ID`

  # GO selection function
    significantDiffGenes <- function(allScore) {return(allScore < 0.01)}

  # Set wd for GO figures
    setwd(paste0(path,"GO"))
@

<<GO background genes for gene ontology enrichment analysis plot,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,out.width="400pt",out.height="400pt",fig.cap="\\label{GO:fig1} Multidensity plot of the average expression strength of the significantly differentially expressed genes of interest, a background set of non-differentially expressed genes with similar average expression strength is defined using the genefinder function from the genefilter package version .",fig.pos="H">>=
ggdraw() +  draw_image(image_read(paste0(path,"DE/back_foregroundgenes.tiff"))) 
@


<<GO gene ontology enrichment analysis BP,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
# Verify available ontologies
    BPterms <- ls(GOBPTerm)
    head(BPterms)

# Construct GO_BP object
    significant_GO_BP_SHIME_Blank <- new("topGOdata", ontology = "BP", allGenes = pval_universe_SHIME_Blank_vector,geneSel=significantDiffGenes,nodeSize = 10, annot = annFUN.db, affyLib = "hugene20sttranscriptcluster.db")
    significant_GO_BP_SHIMELGG_Blank <- new("topGOdata", ontology = "BP", allGenes = pval_universe_SHIMELGG_Blank_vector,geneSel=significantDiffGenes,nodeSize = 10, annot = annFUN.db, affyLib = "hugene20sttranscriptcluster.db")
    significant_GO_BP_SHIMELGG_SHIME <- new("topGOdata", ontology = "BP", allGenes = pval_universe_SHIMELGG_SHIME_vector,geneSel=significantDiffGenes,nodeSize = 10, annot = annFUN.db, affyLib = "hugene20sttranscriptcluster.db")

# Access list of significant genes illustrated for SHIME_Blank
    sg <- sigGenes(significant_GO_BP_SHIME_Blank)
    str(sg)
    numSigGenes(significant_GO_BP_SHIME_Blank)
# Look at the number of genes attributed to different GO_BP terms
    termStat(significant_GO_BP_SHIME_Blank)
# Look at GO_BP terms
    graph(significant_GO_BP_SHIME_Blank)
    usedGO(significant_GO_BP_SHIME_Blank)

# GO_BP enrichment analysis: statistical hypothesis testing
    significant_GO_BP_SHIME_Blank_Fisher <- runTest(significant_GO_BP_SHIME_Blank, algorithm = "classic", statistic = "fisher")
    significant_GO_BP_SHIME_Blank_KS <- runTest(significant_GO_BP_SHIME_Blank, algorithm = "elim", statistic = "ks")

    significant_GO_BP_SHIMELGG_Blank_Fisher <- runTest(significant_GO_BP_SHIMELGG_Blank, algorithm = "classic", statistic = "fisher")
    significant_GO_BP_SHIMELGG_Blank_KS <- runTest(significant_GO_BP_SHIMELGG_Blank, algorithm = "elim", statistic = "ks")

    significant_GO_BP_SHIMELGG_SHIME_Fisher <- runTest(significant_GO_BP_SHIMELGG_SHIME, algorithm = "classic", statistic = "fisher")
    significant_GO_BP_SHIMELGG_SHIME_KS <- runTest(significant_GO_BP_SHIMELGG_SHIME, algorithm = "elim", statistic = "ks")

# Look at p-values, illustrated for SHIME_Blank
    significant_GO_BP_SHIME_Blank_Fisher_pval <- score(significant_GO_BP_SHIME_Blank_Fisher)
    hist(significant_GO_BP_SHIME_Blank_Fisher_pval, 50, xlab = "p-values")
    significant_GO_BP_SHIME_Blank_KS_pval <- score(significant_GO_BP_SHIME_Blank_KS)
    hist(significant_GO_BP_SHIME_Blank_KS_pval, 50, xlab = "p-values")
    cor(significant_GO_BP_SHIME_Blank_Fisher_pval,significant_GO_BP_SHIME_Blank_KS_pval)

    topGO::geneData(significant_GO_BP_SHIME_Blank_Fisher)
    topGO::geneData(significant_GO_BP_SHIME_Blank_KS)

# Export all results in table form
    significant_GO_BP_SHIME_Blank_results <- topGO::GenTable(significant_GO_BP_SHIME_Blank, classicFisher = significant_GO_BP_SHIME_Blank_Fisher,elimKS = significant_GO_BP_SHIME_Blank_KS,orderBy = "elimKS", ranksOf = "classicFisher", numChar = 750,topNodes = 1303)
    significant_GO_BP_SHIME_Blank_results
    significant_GO_BP_SHIME_Blank_results_genes <- topGO::printGenes(significant_GO_BP_SHIME_Blank, whichTerms =   significant_GO_BP_SHIME_Blank_results[1:17,"GO.ID"], chip = "hugene20sttranscriptcluster.db", numChar = 1000)
    significant_GO_BP_SHIME_Blank_results_genes <- data.frame(rbindlist(significant_GO_BP_SHIME_Blank_results_genes,idcol=TRUE))
    significant_GO_BP_SHIME_Blank_results_genes$LogFC <- mapvalues( significant_GO_BP_SHIME_Blank_results_genes$Chip.ID,from=DEresults_filtered$`Affymetrix probe`,to=DEresults_filtered$LogFC)

    significant_GO_BP_SHIMELGG_Blank_results <- topGO::GenTable(significant_GO_BP_SHIMELGG_Blank, classicFisher = significant_GO_BP_SHIMELGG_Blank_Fisher, elimKS = significant_GO_BP_SHIMELGG_Blank_KS,orderBy = "elimKS", ranksOf = "classicFisher", topNodes = 750, numChar = 1000)
    significant_GO_BP_SHIMELGG_Blank_results
    significant_GO_BP_SHIMELGG_Blank_results_genes <- printGenes(significant_GO_BP_SHIMELGG_Blank, whichTerms =   significant_GO_BP_SHIMELGG_Blank_results[1:77,"GO.ID"], chip = "hugene20sttranscriptcluster.db", numChar = 1000)
    significant_GO_BP_SHIMELGG_Blank_results_genes <- data.frame(rbindlist(significant_GO_BP_SHIMELGG_Blank_results_genes,idcol=TRUE))
    significant_GO_BP_SHIMELGG_Blank_results_genes$LogFC <- mapvalues( significant_GO_BP_SHIMELGG_Blank_results_genes$Chip.ID,from=DEresults_filtered$`Affymetrix probe`,to=DEresults_filtered$LogFC)

    significant_GO_BP_SHIMELGG_SHIME_results <- GenTable(significant_GO_BP_SHIMELGG_SHIME, classicFisher = significant_GO_BP_SHIMELGG_SHIME_Fisher,elimKS = significant_GO_BP_SHIMELGG_SHIME_KS,orderBy = "elimKS", ranksOf = "classicFisher", topNodes = 750, numChar = 1000)
    significant_GO_BP_SHIMELGG_SHIME_results
    significant_GO_BP_SHIMELGG_SHIME_results_genes <- printGenes(significant_GO_BP_SHIMELGG_SHIME, whichTerms =   significant_GO_BP_SHIMELGG_SHIME_results[1:26,"GO.ID"], chip = "hugene20sttranscriptcluster.db", numChar = 1000)
    significant_GO_BP_SHIMELGG_SHIME_results_genes <- data.frame(rbindlist(significant_GO_BP_SHIMELGG_SHIME_results_genes,idcol=TRUE))
    significant_GO_BP_SHIMELGG_SHIME_results_genes$LogFC <- mapvalues( significant_GO_BP_SHIMELGG_SHIME_results_genes$Chip.ID,from=DEresults_filtered$`Affymetrix probe`,to=DEresults_filtered$LogFC)


    significant_GO_BP_results_BP <- rbind(cbind(significant_GO_BP_SHIME_Blank_results,Comparison="SHIME_Blank"),cbind(significant_GO_BP_SHIMELGG_Blank_results,Comparison="SHIMELGG_Blank"),cbind(significant_GO_BP_SHIMELGG_SHIME_results,Comparison="SHIMELGG_SHIME"))

    significant_GO_BP_results_genes_BP <- rbind(cbind(significant_GO_BP_SHIME_Blank_results_genes,Comparison="SHIME_Blank"),cbind(significant_GO_BP_SHIMELGG_Blank_results_genes,Comparison="SHIMELGG_Blank"),cbind(significant_GO_BP_SHIMELGG_SHIME_results_genes,Comparison="SHIMELGG_SHIME"))


  # Explore vizualisation of results
    GO_BPID <- significant_GO_BP_SHIME_Blank_results[3, "GO.ID"]
    #print(showGroupDensity(significant_GO_BP_SHIME_Blank, GO_BPID, ranks = TRUE))
    
  # GO_BP graph
    setwd(paste0(path,"GO/"))
    #showSigOfNodes(significant_GO_BP_SHIME_Blank, score(significant_GO_BP_SHIME_Blank_KS), firstSigNodes = 5, useInfo = 'all')
    printGraph(significant_GO_BP_SHIME_Blank, significant_GO_BP_SHIME_Blank_KS, firstSigNodes = 5, fn.prefix = "topGO_BP", useInfo = "all", pdfSW = TRUE)
    setwd(paste0(path))
@

<<GO gene ontology enrichment analysis BP plot,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="600pt",fig.cap=c("\\label{GO:fig2} GOgraph of the 5 most significant GO BP terms, displayed as square boxes. Box color represents the relative significance, ranging from dark red (most significant) to light yellow (least significant). Black arrows indicate is-a relationships and red arrows part-of relationships. The first two lines show the GO BP identifier and a trimmed GO BP name. In the third line the raw p-value is shown. The forth line is showing the number of significant genes and the total number of genes annotated to the respective GO BP term."),fig.scap="GOgraph of the 5 most significant GO BP terms",fig.pos="H">>=
knitr::include_graphics(paste0(path,"GO/topGO_BP_elim_5_all.pdf"))
@

<<GO gene ontology enrichment analysis MF,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
# Verify available ontologies
    MFterms <- ls(GOMFTerm)
    head(MFterms)

# Construct GO_MF object
    significant_GO_MF_SHIME_Blank <- new("topGOdata", ontology = "MF", allGenes = pval_universe_SHIME_Blank_vector,geneSel=significantDiffGenes,nodeSize = 10, annot = annFUN.db, affyLib = "hugene20sttranscriptcluster.db")
    significant_GO_MF_SHIMELGG_Blank <- new("topGOdata", ontology = "MF", allGenes = pval_universe_SHIMELGG_Blank_vector,geneSel=significantDiffGenes,nodeSize = 10, annot = annFUN.db, affyLib = "hugene20sttranscriptcluster.db")
    significant_GO_MF_SHIMELGG_SHIME <- new("topGOdata", ontology = "MF", allGenes = pval_universe_SHIMELGG_SHIME_vector,geneSel=significantDiffGenes,nodeSize = 10, annot = annFUN.db, affyLib = "hugene20sttranscriptcluster.db")

# Access list of significant genes illustrated for SHIME_Blank
    sg <- sigGenes(significant_GO_MF_SHIME_Blank)
    str(sg)
    numSigGenes(significant_GO_MF_SHIME_Blank)
# Look at the number of genes attributed to different GO_MF terms
    termStat(significant_GO_MF_SHIME_Blank)
# Look at GO_MF terms
    graph(significant_GO_MF_SHIME_Blank)
    usedGO(significant_GO_MF_SHIME_Blank)

# GO_MF enrichment analysis: statistical hypothesis testing
    significant_GO_MF_SHIME_Blank_Fisher <- runTest(significant_GO_MF_SHIME_Blank, algorithm = "classic", statistic = "fisher")
    significant_GO_MF_SHIME_Blank_KS <- runTest(significant_GO_MF_SHIME_Blank, algorithm = "elim", statistic = "ks")

    significant_GO_MF_SHIMELGG_Blank_Fisher <- runTest(significant_GO_MF_SHIMELGG_Blank, algorithm = "classic", statistic = "fisher")
    significant_GO_MF_SHIMELGG_Blank_KS <- runTest(significant_GO_MF_SHIMELGG_Blank, algorithm = "elim", statistic = "ks")

    significant_GO_MF_SHIMELGG_SHIME_Fisher <- runTest(significant_GO_MF_SHIMELGG_SHIME, algorithm = "classic", statistic = "fisher")
    significant_GO_MF_SHIMELGG_SHIME_KS <- runTest(significant_GO_MF_SHIMELGG_SHIME, algorithm = "elim", statistic = "ks")

# Look at p-values, illustrated for SHIME_Blank
    significant_GO_MF_SHIME_Blank_Fisher_pval <- score(significant_GO_MF_SHIME_Blank_Fisher)
    hist(significant_GO_MF_SHIME_Blank_Fisher_pval, 50, xlab = "p-values")
    significant_GO_MF_SHIME_Blank_KS_pval <- score(significant_GO_MF_SHIME_Blank_KS)
    hist(significant_GO_MF_SHIME_Blank_KS_pval, 50, xlab = "p-values")
    cor(significant_GO_MF_SHIME_Blank_Fisher_pval,significant_GO_MF_SHIME_Blank_KS_pval)

    topGO::geneData(significant_GO_MF_SHIME_Blank_Fisher)
    topGO::geneData(significant_GO_MF_SHIME_Blank_KS)

# Export all results in table form
    significant_GO_MF_SHIME_Blank_results <- topGO::GenTable(significant_GO_MF_SHIME_Blank, classicFisher = significant_GO_MF_SHIME_Blank_Fisher,elimKS = significant_GO_MF_SHIME_Blank_KS,orderBy = "elimKS", ranksOf = "classicFisher", numChar = 1000,topNodes = 300)
    significant_GO_MF_SHIME_Blank_results
    significant_GO_MF_SHIME_Blank_results_genes <- topGO::printGenes(significant_GO_MF_SHIME_Blank, whichTerms =   significant_GO_MF_SHIME_Blank_results[1:17,"GO.ID"], chip = "hugene20sttranscriptcluster.db", numChar = 1000)
    significant_GO_MF_SHIME_Blank_results_genes <- data.frame(rbindlist(significant_GO_MF_SHIME_Blank_results_genes,idcol=TRUE))
    significant_GO_MF_SHIME_Blank_results_genes$LogFC <- mapvalues( significant_GO_MF_SHIME_Blank_results_genes$Chip.ID,from=DEresults_filtered$`Affymetrix probe`,to=DEresults_filtered$LogFC)

    significant_GO_MF_SHIMELGG_Blank_results <- topGO::GenTable(significant_GO_MF_SHIMELGG_Blank, classicFisher = significant_GO_MF_SHIMELGG_Blank_Fisher, elimKS = significant_GO_MF_SHIMELGG_Blank_KS,orderBy = "elimKS", ranksOf = "classicFisher", topNodes = 300, numChar = 1000)
    significant_GO_MF_SHIMELGG_Blank_results
    significant_GO_MF_SHIMELGG_Blank_results_genes <- printGenes(significant_GO_MF_SHIMELGG_Blank, whichTerms =   significant_GO_MF_SHIMELGG_Blank_results[1:77,"GO.ID"], chip = "hugene20sttranscriptcluster.db", numChar = 1000)
    significant_GO_MF_SHIMELGG_Blank_results_genes <- data.frame(rbindlist(significant_GO_MF_SHIMELGG_Blank_results_genes,idcol=TRUE))
    significant_GO_MF_SHIMELGG_Blank_results_genes$LogFC <- mapvalues( significant_GO_MF_SHIMELGG_Blank_results_genes$Chip.ID,from=DEresults_filtered$`Affymetrix probe`,to=DEresults_filtered$LogFC)

    significant_GO_MF_SHIMELGG_SHIME_results <- GenTable(significant_GO_MF_SHIMELGG_SHIME, classicFisher = significant_GO_MF_SHIMELGG_SHIME_Fisher,elimKS = significant_GO_MF_SHIMELGG_SHIME_KS,orderBy = "elimKS", ranksOf = "classicFisher", topNodes = 300, numChar = 1000)
    significant_GO_MF_SHIMELGG_SHIME_results
    significant_GO_MF_SHIMELGG_SHIME_results_genes <- printGenes(significant_GO_MF_SHIMELGG_SHIME, whichTerms =   significant_GO_MF_SHIMELGG_SHIME_results[1:26,"GO.ID"], chip = "hugene20sttranscriptcluster.db", numChar = 1000)
    significant_GO_MF_SHIMELGG_SHIME_results_genes <- data.frame(rbindlist(significant_GO_MF_SHIMELGG_SHIME_results_genes,idcol=TRUE))
    significant_GO_MF_SHIMELGG_SHIME_results_genes$LogFC <- mapvalues( significant_GO_MF_SHIMELGG_SHIME_results_genes$Chip.ID,from=DEresults_filtered$`Affymetrix probe`,to=DEresults_filtered$LogFC)


    significant_GO_MF_results_MF <- rbind(cbind(significant_GO_MF_SHIME_Blank_results,Comparison="SHIME_Blank"),cbind(significant_GO_MF_SHIMELGG_Blank_results,Comparison="SHIMELGG_Blank"),cbind(significant_GO_MF_SHIMELGG_SHIME_results,Comparison="SHIMELGG_SHIME"))

    significant_GO_MF_results_genes_MF <- rbind(cbind(significant_GO_MF_SHIME_Blank_results_genes,Comparison="SHIME_Blank"),cbind(significant_GO_MF_SHIMELGG_Blank_results_genes,Comparison="SHIMELGG_Blank"),cbind(significant_GO_MF_SHIMELGG_SHIME_results_genes,Comparison="SHIMELGG_SHIME"))


  # Explore vizualisation of results
    GO_MFID <- significant_GO_MF_SHIME_Blank_results[3, "GO.ID"]
    #print(showGroupDensity(significant_GO_MF_SHIME_Blank, GO_MFID, ranks = TRUE))
    
  # GO_MF graph
    setwd(paste0(path,"GO/"))
    #showSigOfNodes(significant_GO_MF_SHIME_Blank, score(significant_GO_MF_SHIME_Blank_KS), firstSigNodes = 5, useInfo = 'all')
    printGraph(significant_GO_MF_SHIME_Blank, significant_GO_MF_SHIME_Blank_KS, firstSigNodes = 5, fn.prefix = "topGO_MF", useInfo = "all", pdfSW = TRUE)
    setwd(paste0(path))
@

<<GO gene ontology enrichment analysis MF plot,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="600pt",fig.cap=c("\\label{GO:fig3} GOgraph of the 5 most significant GO MF terms, displayed as square boxes. Box color represents the relative significance, ranging from dark red (most significant) to light yellow (least significant). Black arrows indicate is-a relationships and red arrows part-of relationships. The first two lines show the GO MF identifier and a trimmed GO MF name. In the third line the raw p-value is shown. The forth line is showing the number of significant genes and the total number of genes annotated to the respective GO MF term."),fig.scap="GOgraph of the 5 most significant GO MF terms",fig.pos="H" >>=
knitr::include_graphics(paste0(path,"GO/topGO_MF_elim_5_all.pdf"))
@

<<GO gene ontology enrichment analysis CC,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
# Verify available ontologies
    CCterms <- ls(GOCCTerm)
    head(CCterms)

# Construct GO_CC object
    significant_GO_CC_SHIME_Blank <- new("topGOdata", ontology = "CC", allGenes = pval_universe_SHIME_Blank_vector,geneSel=significantDiffGenes,nodeSize = 10, annot = annFUN.db, affyLib = "hugene20sttranscriptcluster.db")
    significant_GO_CC_SHIMELGG_Blank <- new("topGOdata", ontology = "CC", allGenes = pval_universe_SHIMELGG_Blank_vector,geneSel=significantDiffGenes,nodeSize = 10, annot = annFUN.db, affyLib = "hugene20sttranscriptcluster.db")
    significant_GO_CC_SHIMELGG_SHIME <- new("topGOdata", ontology = "CC", allGenes = pval_universe_SHIMELGG_SHIME_vector,geneSel=significantDiffGenes,nodeSize = 10, annot = annFUN.db, affyLib = "hugene20sttranscriptcluster.db")

# Access list of significant genes illustrated for SHIME_Blank
    sg <- sigGenes(significant_GO_CC_SHIME_Blank)
    str(sg)
    numSigGenes(significant_GO_CC_SHIME_Blank)
# Look at the number of genes attributed to different GO_CC terms
    termStat(significant_GO_CC_SHIME_Blank)
# Look at GO_CC terms
    graph(significant_GO_CC_SHIME_Blank)
    usedGO(significant_GO_CC_SHIME_Blank)

# GO_CC enrichment analysis: statistical hypothesis testing
    significant_GO_CC_SHIME_Blank_Fisher <- runTest(significant_GO_CC_SHIME_Blank, algorithm = "classic", statistic = "fisher")
    significant_GO_CC_SHIME_Blank_KS <- runTest(significant_GO_CC_SHIME_Blank, algorithm = "elim", statistic = "ks")

    significant_GO_CC_SHIMELGG_Blank_Fisher <- runTest(significant_GO_CC_SHIMELGG_Blank, algorithm = "classic", statistic = "fisher")
    significant_GO_CC_SHIMELGG_Blank_KS <- runTest(significant_GO_CC_SHIMELGG_Blank, algorithm = "elim", statistic = "ks")

    significant_GO_CC_SHIMELGG_SHIME_Fisher <- runTest(significant_GO_CC_SHIMELGG_SHIME, algorithm = "classic", statistic = "fisher")
    significant_GO_CC_SHIMELGG_SHIME_KS <- runTest(significant_GO_CC_SHIMELGG_SHIME, algorithm = "elim", statistic = "ks")

# Look at p-values, illustrated for SHIME_Blank
    significant_GO_CC_SHIME_Blank_Fisher_pval <- score(significant_GO_CC_SHIME_Blank_Fisher)
    hist(significant_GO_CC_SHIME_Blank_Fisher_pval, 50, xlab = "p-values")
    significant_GO_CC_SHIME_Blank_KS_pval <- score(significant_GO_CC_SHIME_Blank_KS)
    hist(significant_GO_CC_SHIME_Blank_KS_pval, 50, xlab = "p-values")
    cor(significant_GO_CC_SHIME_Blank_Fisher_pval,significant_GO_CC_SHIME_Blank_KS_pval)

    topGO::geneData(significant_GO_CC_SHIME_Blank_Fisher)
    topGO::geneData(significant_GO_CC_SHIME_Blank_KS)

# Export all results in table form
    significant_GO_CC_SHIME_Blank_results <- topGO::GenTable(significant_GO_CC_SHIME_Blank, classicFisher = significant_GO_CC_SHIME_Blank_Fisher,elimKS = significant_GO_CC_SHIME_Blank_KS,orderBy = "elimKS", ranksOf = "classicFisher", numChar = 1000,topNodes = 300)
    significant_GO_CC_SHIME_Blank_results
    significant_GO_CC_SHIME_Blank_results_genes <- topGO::printGenes(significant_GO_CC_SHIME_Blank, whichTerms =   significant_GO_CC_SHIME_Blank_results[1:17,"GO.ID"], chip = "hugene20sttranscriptcluster.db", numChar = 1000)
    significant_GO_CC_SHIME_Blank_results_genes <- data.frame(rbindlist(significant_GO_CC_SHIME_Blank_results_genes,idcol=TRUE))
    significant_GO_CC_SHIME_Blank_results_genes$LogFC <- mapvalues( significant_GO_CC_SHIME_Blank_results_genes$Chip.ID,from=DEresults_filtered$`Affymetrix probe`,to=DEresults_filtered$LogFC)

    significant_GO_CC_SHIMELGG_Blank_results <- topGO::GenTable(significant_GO_CC_SHIMELGG_Blank, classicFisher = significant_GO_CC_SHIMELGG_Blank_Fisher, elimKS = significant_GO_CC_SHIMELGG_Blank_KS,orderBy = "elimKS", ranksOf = "classicFisher", topNodes = 300, numChar = 1000)
    significant_GO_CC_SHIMELGG_Blank_results
    significant_GO_CC_SHIMELGG_Blank_results_genes <- printGenes(significant_GO_CC_SHIMELGG_Blank, whichTerms =   significant_GO_CC_SHIMELGG_Blank_results[1:77,"GO.ID"], chip = "hugene20sttranscriptcluster.db", numChar = 1000)
    significant_GO_CC_SHIMELGG_Blank_results_genes <- data.frame(rbindlist(significant_GO_CC_SHIMELGG_Blank_results_genes,idcol=TRUE))
    significant_GO_CC_SHIMELGG_Blank_results_genes$LogFC <- mapvalues( significant_GO_CC_SHIMELGG_Blank_results_genes$Chip.ID,from=DEresults_filtered$`Affymetrix probe`,to=DEresults_filtered$LogFC)

    significant_GO_CC_SHIMELGG_SHIME_results <- GenTable(significant_GO_CC_SHIMELGG_SHIME, classicFisher = significant_GO_CC_SHIMELGG_SHIME_Fisher,elimKS = significant_GO_CC_SHIMELGG_SHIME_KS,orderBy = "elimKS", ranksOf = "classicFisher", topNodes = 300, numChar = 1000)
    significant_GO_CC_SHIMELGG_SHIME_results
    significant_GO_CC_SHIMELGG_SHIME_results_genes <- printGenes(significant_GO_CC_SHIMELGG_SHIME, whichTerms =   significant_GO_CC_SHIMELGG_SHIME_results[1:26,"GO.ID"], chip = "hugene20sttranscriptcluster.db", numChar = 1000)
    significant_GO_CC_SHIMELGG_SHIME_results_genes <- data.frame(rbindlist(significant_GO_CC_SHIMELGG_SHIME_results_genes,idcol=TRUE))
    significant_GO_CC_SHIMELGG_SHIME_results_genes$LogFC <- mapvalues( significant_GO_CC_SHIMELGG_SHIME_results_genes$Chip.ID,from=DEresults_filtered$`Affymetrix probe`,to=DEresults_filtered$LogFC)


    significant_GO_CC_results_CC <- rbind(cbind(significant_GO_CC_SHIME_Blank_results,Comparison="SHIME_Blank"),cbind(significant_GO_CC_SHIMELGG_Blank_results,Comparison="SHIMELGG_Blank"),cbind(significant_GO_CC_SHIMELGG_SHIME_results,Comparison="SHIMELGG_SHIME"))

    significant_GO_CC_results_genes_CC <- rbind(cbind(significant_GO_CC_SHIME_Blank_results_genes,Comparison="SHIME_Blank"),cbind(significant_GO_CC_SHIMELGG_Blank_results_genes,Comparison="SHIMELGG_Blank"),cbind(significant_GO_CC_SHIMELGG_SHIME_results_genes,Comparison="SHIMELGG_SHIME"))


  # Explore vizualisation of results
    GO_CCID <- significant_GO_CC_SHIME_Blank_results[3, "GO.ID"]
    #print(showGroupDensity(significant_GO_CC_SHIME_Blank, GO_CCID, ranks = TRUE))

  # GO_CC graph
    showSigOfNodes(significant_GO_CC_SHIME_Blank, score(significant_GO_CC_SHIME_Blank_KS), firstSigNodes = 5, useInfo = 'all')

# Reset wd
  setwd(paste0(path))
  
# GO_CC graph
    setwd(paste0(path,"GO/"))
    #showSigOfNodes(significant_GO_CC_SHIME_Blank, score(significant_GO_CC_SHIME_Blank_KS), firstSigNodes = 5, useInfo = 'all')
    printGraph(significant_GO_CC_SHIME_Blank, significant_GO_CC_SHIME_Blank_KS, firstSigNodes = 5, fn.prefix = "topGO_CC", useInfo = "all", pdfSW = TRUE)
    setwd(paste0(path))
@

<<GO gene ontology enrichment analysis CC plot,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width="500pt",out.height="600pt",fig.cap=c("\\label{GO:fig4} GOgraph of the 5 most significant GO CC terms, displayed as square boxes. Box color represents the relative significance, ranging from dark red (most significant) to light yellow (least significant). Black arrows indicate is-a relationships and red arrows part-of relationships. The first two lines show the GO CC identifier and a trimmed GO CC name. In the third line the raw p-value is shown. The forth line is showing the number of significant genes and the total number of genes annotated to the respective GO CC term."),fig.scap="GOgraph of the 5 most significant GO CC terms",fig.pos="H">>=
knitr::include_graphics(paste0(path,"GO/topGO_CC_elim_5_all.pdf"))
@

<<GO gene ontology enrichment analysis BP-MF-CC,include=FALSE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
significant_GO_results <- rbind(significant_GO_BP_results_BP,significant_GO_MF_results_MF,significant_GO_CC_results_CC)

significant_GO_results_genes <- rbind(significant_GO_BP_results_genes_BP,significant_GO_MF_results_genes_MF,significant_GO_CC_results_genes_CC)
@







% For most biologists using expression analysis in functional genomics studies, the desired
% analysis end point is a new or an improved pathway model of the biological process of
% interest. Pathway pictures are a useful and powerful way to summarize the network of
% molecular interactions that make up the biological process under study. Placing global gene
% expression data within the context of a pathway image enables you to identify affected
% pathways.

\chapter{KEGG pathway and gene ontolgy based gene-set analysis}
Just like GO enrichment analysis, gene-set analysis (GSA) takes into account functional relationships between genes. But unlike GO enrichment analysis which starts from the results of a prior per-gene differential expression analysis, GSA focuses on sets of related genes and aims to identify significantly up- or downregulated gene-sets. Such coordinated differential expression analysis over gene set offers a number of advantages compared to classical individual gene approaches, including greater robustness, sensitivity and biological relevance \cite{Luo2009}. This is especially true considering the functional redundancy of individual genes and the level of noise in high-throughput microarray data. Moreover, consistent perturbations over such gene sets frequently suggest mechanistic changes.

Gene-sets are pre-defined groups of genes, which are functionally related. Functional relationships can be derived from KEGG pathways, Gene Ontology terms, gene groups that share some other functional annotations, including common transcriptional regulators (like transcription factors, small interfering RNA's or siRNA, genomic locations etc.

GSA was performed with up-to-date (\Sexpr{date()}) KEGG pathway and gene ontology based gene-sets in combination with a parametric gene randomization procedure implemented in the GAGE (generally applicable gene set enrichment for pathway analysis) package, version \Sexpr{packageVersion('gage')}.

% kegg.gs only include the subset of canonical signaling and metabolic pathways from KEGG pathway database, and kegg.gs.dise is the subset of disease pathways. And it is recommended to do KEGG pathway analysis with either kegg.gs or kegg.gs.dise seperately (rather than combined altogether) for better defined results. go.gs derived from human GO database only includes 1000 gene sets due to size limit. For full go.gs or gene sets data for other species, we may always use the gageData package. If you don't find the gene set data for your target species, you may use kegg.gsets or go.gsets to compile pathway gene set data any time needed as long as it is one of the 3000 KEGG species or a species with gene annotation package supplied in Bioconductor or the user. You may want to save the new gene set data for later use. An another advantage of using kegg.gsets is that you get the most updated pathway gene set data as it is retrieved from KEGG in real time.

Prior to GSA in GAGE, Affymetrix gene identifiers were mapped to the matching Entrez identifiers used in the KEGG and GO databases. One-directional (either up- or down-regulation) expression changes were assessed with parametric unpaired two-sample t-tests on gene sets using LogFC as per-gene statistics, followed by robust p-value summarization using Stouffer's method and Benjamini \& Hochberg FDR correction (q-value). The average of the individual LogFC statistics from multiple single array based gene-set tests was displayed in bar graphs for the significant KEGG pathways (Figure) and gene ontology terms (Figure ) (p<0.01). FDR adjusted p-values were reported and bars were color-coded according to the pathway/gene ontology categories.

% The results of such 1-directional analysis is a list of two matrices, corresponding to the two directions. Each result matrix contains multiple columns of test statistics and p-/q-values for all tested gene sets. Among them, p.val is the global p-value and q.val is the corresponding FDR q-value. Gene sets are ranked by significance. As described in GAGE paper (Luo et al., 2009), it is worthy to run gage with same.dir=F option on KEGG pathways too to capture pathways perturbed towards both directions simultaneously. Note we normally do not use same.dir=F option on GO groups, which are mostly gene sets coregulated towards the same direction.

There are frequently multiple significant gene-sets that share multiple member genes or represent the same
regulatory mechanism. Therefore, we identified non-redundant gene-sets, not displaying significant overlap with other gene-sets in the core genes contributing most to the gene-set overall significance. The core genes were identified in the volcanoplots obtained with Limma and the LogFC in individual genes confirmed the general trends at higher levels (pathways, gene ontology).
%Such redundancy in significant gene set could be misleading too. A pathway or functional group itself is not relevant, but may be called significant because it shares multiple perturbed genes with one really significant gene set. We derive the non-redundant significant gene set lists. Here, function esset.grp calls redundant gene sets to be those that overlap heavily in their core genes. Core genes are those member genes that really contribute to the significance of the gene set in GAGE analysis. Argument pc is the cutoff p-value for the overlap between gene sets, default to 10e-10, may need trial-and-error to find the optimal value in minor cases. Note that we use small pc because redundant gene sets are not just significant in overlap, but are HIGHLY significant so.
The non-redundant KEGG-based gene-sets were also explored with pathview version \Sexpr{packageVersion('pathview')}. The perturbed expression patterns were mapped onto the KEGG pathway view \cite{Luo2009}.

%Pathview automatically downloads the pathway graph data, parses the data file, maps user data to the pathway, and renders pathway graph with the mapped data.
%Note that pathview can view our expression perturbation patterns on two styles of pathway graphs: KEGG view or Graphviz view ((Figure 4). All we need is to supply our data (expression changes) and specify the target pathway.

%We may extract the gene expression data for top gene sets, output and visualize these expression data for  further interpretation. Although we can check expression data in each top gene set one by one, here we work on the top 3 up-regulated KEGG pathways in a batch. The key functions we use here are, essGene (for extract genes with substantial or above-background expression changes in gene sets) and geneData (for output and visualization of expression data in gene sets).

\section{KEGG pathway analysis}

<< GAGE gene-set analysis KEGG,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
# Species supported by Bioconductor and KEGG code corresponding to humans
  data(bods)
  print(bods)

# Generate up-to-date KEGG pathway gene sets
  kg.hsa=kegg.gsets("hsa")
  kegg.gs=kg.hsa$kg.sets[kg.hsa$sigmet.idx]
  #save(kegg.gs, file="kegg.hsa.sigmet.gsets.RData")
  head(kegg.gs[[1]])

# Create expresion dataset with Entrez Gene IDs
  Entrez_gage <- mol.sum(mol.data = CELdata_RMA_core_expr, id.map = as.matrix(mapping_Entrez),sum.method = "mean")

# Run 1-directional gage based on KEGG
  # Note on alternative gage options: rank.test = T, saaTest = gs.KSTest
  gage_KEGG_SHIME_Blank <- gage(Entrez_gage, gsets = kegg.gs, ref = c(1,2,3),samp = c(4,5,6), compare ="unpaired")
  gage_KEGG_SHIMELGG_Blank <- gage(Entrez_gage, gsets = kegg.gs, ref = c(1,2,3),samp = c(7,8,9), compare ="unpaired")
  gage_KEGG_SHIMELGG_SHIME <- gage(Entrez_gage, gsets = kegg.gs, ref = c(4,5,6),samp = c(7,8,9), compare ="unpaired")

# Run 2-directional gage based on KEGG
  gage_KEGG2dir_SHIME_Blank <- gage(Entrez_gage, gsets = kegg.gs, ref = c(1,2,3),samp = c(4,5,6), compare ="unpaired",same.dir=F)
  gage_KEGG2dir_SHIMELGG_Blank <- gage(Entrez_gage, gsets = kegg.gs, ref = c(1,2,3),samp = c(7,8,9), compare ="unpaired",same.dir=F)
  gage_KEGG2dir_SHIMELGG_SHIME <- gage(Entrez_gage, gsets = kegg.gs, ref = c(4,5,6),samp = c(7,8,9), compare ="unpaired",same.dir=F)
# Inspect gage results
  head(gage_KEGG_SHIME_Blank$greater, 4)
  head(gage_KEGG_SHIME_Blank$less, 4)
  head(gage_KEGG_SHIME_Blank$stats, 4)

  head(gage_KEGG_SHIMELGG_Blank$greater, 4)
  head(gage_KEGG_SHIMELGG_Blank$less, 4)
  head(gage_KEGG_SHIMELGG_Blank$stats, 4)

  head(gage_KEGG_SHIMELGG_SHIME$greater, 4)
  head(gage_KEGG_SHIMELGG_SHIME$less, 4)
  head(gage_KEGG_SHIMELGG_SHIME$stats, 4)

# Export GAGE results in separate dataframes
  gage_KEGG_SHIME_Blank_df <- rbindlist(l=lapply(gage_KEGG_SHIME_Blank, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG_SHIME_Blank_df) <- c(".id","KEGGpathway","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_KEGG_SHIMELGG_Blank_df <- rbindlist(l=lapply(gage_KEGG_SHIMELGG_Blank, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG_SHIMELGG_Blank_df) <- c(".id","KEGGpathway","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_KEGG_SHIMELGG_SHIME_df <- rbindlist(l=lapply(gage_KEGG_SHIMELGG_SHIME, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG_SHIMELGG_SHIME_df) <- c(".id","KEGGpathway","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")

  gage_KEGG2dir_SHIME_Blank_df <- rbindlist(l=lapply(gage_KEGG2dir_SHIME_Blank, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG2dir_SHIME_Blank_df) <- c(".id","KEGGpathway","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_KEGG2dir_SHIMELGG_Blank_df <- rbindlist(l=lapply(gage_KEGG2dir_SHIMELGG_Blank, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG2dir_SHIMELGG_Blank_df) <- c(".id","KEGGpathway","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_KEGG2dir_SHIMELGG_SHIME_df <- rbindlist(l=lapply(gage_KEGG2dir_SHIMELGG_SHIME, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG2dir_SHIMELGG_SHIME_df) <- c(".id","KEGGpathway","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")

# Export GAGE results in 1 dataframe
  gage_KEGG_df <- rbind(cbind(Comparison="SHIME_Blank",gage_KEGG_SHIME_Blank_df),cbind(Comparison="SHIMELGG_Blank",gage_KEGG_SHIMELGG_Blank_df),cbind(Comparison="SHIMELGG_SHIME",gage_KEGG_SHIMELGG_SHIME_df))

# Significant results cutoff at 0.01
  gage_KEGG_SHIME_Blank_sign <- sigGeneSet(gage_KEGG_SHIME_Blank, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))
  gage_KEGG_SHIMELGG_Blank_sign <- sigGeneSet(gage_KEGG_SHIMELGG_Blank, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))
  gage_KEGG_SHIMELGG_SHIME_sign <- sigGeneSet(gage_KEGG_SHIMELGG_SHIME, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))

  gage_KEGG2dir_SHIME_Blank_sign <- sigGeneSet(gage_KEGG2dir_SHIME_Blank, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))
  gage_KEGG2dir_SHIMELGG_Blank_sign <- sigGeneSet(gage_KEGG2dir_SHIMELGG_Blank, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))
  gage_KEGG2dir_SHIMELGG_SHIME_sign <- sigGeneSet(gage_KEGG2dir_SHIMELGG_SHIME, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))

# Export significant GAGE results in separate dataframes
  gage_KEGG_SHIME_Blank_sign_df <- rbindlist(l=lapply(gage_KEGG_SHIME_Blank_sign, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG_SHIME_Blank_sign_df) <- c(".id","KEGGpathway","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_KEGG_SHIMELGG_Blank_sign_df <- rbindlist(l=lapply(gage_KEGG_SHIMELGG_Blank_sign, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG_SHIMELGG_Blank_sign_df) <- c(".id","KEGGpathway","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_KEGG_SHIMELGG_SHIME_sign_df <- rbindlist(l=lapply(gage_KEGG_SHIMELGG_SHIME_sign, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG_SHIMELGG_SHIME_sign_df) <- c(".id","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3","KEGGpathway")

  gage_KEGG2dir_SHIME_Blank_sign_df <- rbindlist(l=lapply(gage_KEGG2dir_SHIME_Blank_sign, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG2dir_SHIME_Blank_sign_df) <- c(".id","KEGGpathway","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_KEGG2dir_SHIMELGG_Blank_sign_df <- rbindlist(l=lapply(gage_KEGG2dir_SHIMELGG_Blank_sign, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG2dir_SHIMELGG_Blank_sign_df) <- c(".id","KEGGpathway","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_KEGG2dir_SHIMELGG_SHIME_sign_df <- rbindlist(l=lapply(gage_KEGG2dir_SHIMELGG_SHIME_sign, function(x) {if(any(class(x)=="matrix")) data.frame(KEGGpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_KEGG2dir_SHIMELGG_SHIME_sign_df) <- c(".id","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")

# Combine significant pathways in one dataframe
  gage_KEGG_sign_df <- rbind(cbind(Comparison="SHIME_Blank",data.frame(gage_KEGG_SHIME_Blank_sign_df)),cbind(Comparison="SHIMELGG_Blank",data.frame(gage_KEGG_SHIMELGG_Blank_sign_df)),cbind(Comparison="SHIMELGG_SHIME",data.frame(gage_KEGG_SHIMELGG_SHIME_sign_df)[colnames(gage_KEGG_SHIME_Blank_sign_df)]))

  gage_KEGG_sign_df <- gage_KEGG_sign_df[gage_KEGG_sign_df$.id!="stats",]
  gage_KEGG_sign_df$KEGGpathway <- factor(gage_KEGG_sign_df$KEGGpathway,levels=rev(unique(gage_KEGG_sign_df$KEGGpathway)))

# Remove redundant gene-sets
  gage_KEGG_SHIME_Blank_sig_up <- esset.grp(gage_KEGG_SHIME_Blank$greater,Entrez_gage, gsets = kegg.gs, ref = c(1,2,3), samp = c(4,5,6), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  #gage_KEGG_SHIME_Blank_sig_down <- esset.grp(gage_KEGG_SHIME_Blank$less,Entrez_gage, gsets = kegg.gs, ref = c(1,2,3), samp = c(4,5,6), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

  gage_KEGG_SHIMELGG_Blank_sig_up <- esset.grp(gage_KEGG_SHIMELGG_Blank$greater,Entrez_gage, gsets = kegg.gs, ref = c(1,2,3), samp = c(7,8,9), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  #gage_KEGG_SHIMELGG_Blank_sig_down <- esset.grp(gage_KEGG_SHIMELGG_Blank$less,Entrez_gage, gsets = kegg.gs, ref = c(1,2,3), samp = c(7,8,9), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

  #gage_KEGG_SHIMELGG_SHIME_sig_up <- esset.grp(gage_KEGG_SHIMELGG_SHIME$greater,Entrez_gage, gsets = kegg.gs, ref = c(4,5,6), samp = c(7,8,9), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  gage_KEGG_SHIMELGG_SHIME_sig_down <- esset.grp(gage_KEGG_SHIMELGG_SHIME$less,Entrez_gage, gsets = kegg.gs, ref = c(4,5,6), samp = c(7,8,9), test4up = F,  output=FALSE, make.plot = T , use.q=TRUE,cutoff=0.01,pc=10^-10)

# Inspect significant non-redundant gene-sets
  names(gage_KEGG_SHIME_Blank_sig_up)
  gage_KEGG_SHIME_Blank_sig_up$essentialSets
  gage_KEGG_SHIMELGG_Blank_sig_up$essentialSets
  gage_KEGG_SHIMELGG_SHIME_sig_down$essentialSets
  gage_KEGG_SHIME_Blank_sig_up$setGroups
  gage_KEGG_SHIME_Blank_sig_up$allSets
  gage_KEGG_SHIME_Blank_sig_up$allSetsconnectedComponent
  gage_KEGG_SHIME_Blank_sig_up$overlapCounts
  gage_KEGG_SHIME_Blank_sig_up$overlapPvals
  gage_KEGG_SHIME_Blank_sig_up$coreGeneSets

# Make list of core genes
  gage_KEGG_SHIME_Blank_core <- rbind(cbind(Comparison="SHIME_Blank",Direction="Up",reshape::melt(gage_KEGG_SHIME_Blank_sig_up$coreGeneSets)))
  gage_KEGG_SHIMELGG_Blank_core <- rbind(cbind(Comparison="SHIMELGG_Blank",Direction="Up",reshape::melt(gage_KEGG_SHIMELGG_Blank_sig_up$coreGeneSets)))
  gage_KEGG_SHIMELGG_SHIME_core <- cbind(Comparison="SHIMELGG_SHIME",Direction="Down",reshape::melt(gage_KEGG_SHIMELGG_SHIME_sig_down$coreGeneSets[lengths(gage_KEGG_SHIMELGG_SHIME_sig_down$coreGeneSets)>0]))

  gage_KEGG_core <- rbind(gage_KEGG_SHIME_Blank_core,gage_KEGG_SHIMELGG_Blank_core,gage_KEGG_SHIMELGG_SHIME_core)

# Visualize gage results
  ## Pairwise comparisons: difference in expression
  Entrez_gage_SHIME_min_Blank <- rowMeans(Entrez_gage[ ,c(4,5,6)]) - rowMeans(Entrez_gage[ ,c(1,2,3)])
  Entrez_gage_SHIMELGG_min_Blank <- rowMeans(Entrez_gage[ ,c(7,8,9)]) - rowMeans(Entrez_gage[ ,c(1,2,3)])
  Entrez_gage_SHIMELGG_min_SHIME <- rowMeans(Entrez_gage[ ,c(7,8,9)]) - rowMeans(Entrez_gage[ ,c(4,5,6)])
  Entrez_gage_diff <- cbind(SHIME_Blank =Entrez_gage_SHIME_min_Blank,SHIMELGG_Blank = Entrez_gage_SHIMELGG_min_Blank,SHIMELGG_SHIME= Entrez_gage_SHIMELGG_min_SHIME)
  ## Test for the TNF pathway
  path.ids=c("hsa04668 TNF signaling pathway")
  path.ids2 <- substr(path.ids, 1, 8)
  ## Temporarily change wd to the KEGG folder
  setwd(paste0(path,"KEGG/"))
  #native KEGG view
  #pv.out.list <- sapply(path.ids2, function(pid) pathview(gene.data = Entrez_gage_diff,pathway.id = pid, species = "hsa",pdf.size=c(21,10),kegg.dir=paste0(path,"KEGG/"),both.dirs=list(gene=TRUE,CPD=FALSE),low=list(gene="red", cpd = "red"),mid=list(gene="gray", cpd = "gray"),high=list(gene="green",cpd ="yellow"), limit = list(gene =c(-1,1), cpd=1),out.suffix="test_TNF_pathview_native"))
  #Graphviz view
  #pv.out.list <- sapply(path.ids2, function(pid) pathview(gene.data = Entrez_gage_diff , pathway.id = pid, species = "hsa", kegg.native=F,sign.pos="bottomleft",low=list(gene="red", cpd = "blue"),mid=list(gene="gray", cpd = "gray"),high=list(gene="green",cpd ="yellow"), limit = list(gene =c(-2,2), cpd=1),out.suffix="test_TNF_pathview_graphviz"))

  # Test for the most significant pathways and map onto KEGG for each comparison separately
  pathways_to_view_SHIME_Blank <- c(gage_KEGG_SHIME_Blank_sig_up$essentialSets) 
  # ,gage_KEGG_SHIME_Blank_sig_down$essentialSets
  pv.out.list <- sapply(substr(pathways_to_view_SHIME_Blank, 1, 8), function(pid) pathview(gene.data = Entrez_gage_SHIME_min_Blank, pathway.id = pid, species = "hsa",kegg.dir=paste0(path,"KEGG/"),low=list(gene="red", cpd = "blue"),mid=list(gene="gray", cpd = "gray"),high=list(gene="green",cpd ="yellow"), limit = list(gene =c(-2,2), cpd=1),out.suffix="_SHIME_Blank_pathview_native"))

  pathways_to_view_SHIMELGG_Blank <- c(gage_KEGG_SHIMELGG_Blank_sig_up$essentialSets)
  # ,gage_KEGG_SHIMELGG_Blank_sig_down$essentialSets
  pv.out.list <- sapply(substr(pathways_to_view_SHIMELGG_Blank, 1, 8), function(pid) pathview(gene.data = Entrez_gage_SHIMELGG_min_Blank, pathway.id = pid, species = "hsa",kegg.dir=paste0(path,"KEGG/"),low=list(gene="red", cpd = "blue"),mid=list(gene="gray", cpd = "gray"),high=list(gene="green",cpd ="yellow"), limit = list(gene =c(-2,2), cpd=1),out.suffix="_SHIMELGG_Blank_pathview_native"))

  pathways_to_view_SHIMELGG_SHIME <- c(gage_KEGG_SHIMELGG_SHIME_sig_down$essentialSets)
  pv.out.list <- sapply(substr(pathways_to_view_SHIMELGG_SHIME, 1, 8)[-30], function(pid) pathview(gene.data = Entrez_gage_SHIMELGG_min_SHIME, pathway.id = pid, species = "hsa",kegg.dir=paste0(path,"KEGG/"),low=list(gene="red", cpd = "blue"),mid=list(gene="gray", cpd = "gray"),high=list(gene="green",cpd ="yellow"), limit = list(gene =c(-2,2), cpd=1),out.suffix="_SHIMELGG_SHIME_pathview_native"))

  ## Plot most significant pathways mapped onto KEGG for all comparisons in 1 plot (multi)
  pathways_to_view <- c(pathways_to_view_SHIME_Blank,pathways_to_view_SHIMELGG_SHIME) #,pathways_to_view_SHIMELGG_Blank
  pv.out.list <- sapply(substr(pathways_to_view, 1, 8), function(pid) pathview(gene.data = Entrez_gage_diff[,c(1,3)], pathway.id = pid, species = "hsa",kegg.dir=paste0(path,"KEGG/"),low=list(gene="red", cpd = "blue"),mid=list(gene="gray", cpd = "gray"),high=list(gene="green",cpd ="yellow"), limit = list(gene =c(-2,2), cpd=1),out.suffix="_pathview_native"))
  ## Restore wd
  setwd(paste0(path))

# Find individual gene names contributing to all significant pathways
  kegg.gs["hsa04668 TNF signaling pathway"]
  significant_pathways_geneIDs <- c()
  for (i in unique(gage_KEGG_sign_df$KEGGpathway)){
  print(kegg.gs[i])
  print(unlist(kegg.gs[i]))
  significant_pathways_geneIDs <- c(significant_pathways_geneIDs,unlist(kegg.gs[i]))}
  significant_pathways_geneIDs <- unlist(kegg.gs[unique(as.character(gage_KEGG_sign_df$KEGGpathway))])

# Find expression data of all genes contributing to all significant pathways
  significant_pathways_expdata <- Entrez_gage[rownames(Entrez_gage)%in%unique(significant_pathways_geneIDs),]

# Find expression data of all genes expressed above background contributing to all significant pathways
  gage_KEGG_DABG <- reshape2::melt(kegg.gs[unique(as.character(gage_KEGG_sign_df$KEGGpathway))])
  gage_KEGG_SHIME_Blank_DABG <- reshape2::melt(kegg.gs[unique(as.character(gage_KEGG_SHIME_Blank_sign_df$KEGGpathway))])
  gage_KEGG_SHIMELGG_Blank_DABG <- reshape2::melt(kegg.gs[unique(as.character(gage_KEGG_SHIMELGG_Blank_sign_df$KEGGpathway))])
  gage_KEGG_SHIMELGG_SHIME_DABG <- reshape2::melt(kegg.gs[unique(as.character(gage_KEGG_SHIMELGG_SHIME_sign_df$KEGGpathway))])

  significant_pathways <- unique(unlist(kegg.gs[unique(as.character(gage_KEGG_sign_df$KEGGpathway))]))
  significant_pathways_DABG_expdata <- essGene(significant_pathways, Entrez_gage, ref =c(1,2,3), samp = c(4,5,6,7,8,9),compare="unpaired")

# Find expression data of all core genes in all significant pathays
  significant_pathways_expdata_coregenes <- Entrez_gage[rownames(Entrez_gage)%in%unique(gage_KEGG_core$value),]
@

\begin{landscape}
<< GAGE gene-set analysis KEGG plots,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width=400,out.height=400,fig.cap="\\label{KEGG1:fig1} Significantly (p$<$0.01) up- (positive LogFC) and downregulated (negative LogFC) KEGG pathways as assessed by gene-set analysis (GSA) in GAGE. P-values are adjusted for multiple testing with Benjamini \\& Hochberg FDR correction. Bars are colored by the pathway category: pro-inflammatory response (pink), viral interaction (purple), RNA (green) and protein (yellow) processing, signaling patways (teal), cellular transport (brown) and cellular differentiation (blue).",fig.scap="Significantly (p$<$0.01) up- (positive LogFC) and downregulated (negative LogFC) KEGG pathways as assessed by gene-set analysis (GSA) in GAGE.",fig.pos="H">>=
# Visualize: bar = stat.mean colored by qval
  unique(gage_KEGG_sign_df$KEGGpathway)
  options(digits=2)

  gageplot_names <- as_labeller(c(`SHIME_Blank`='LogFC~"="~frac(SHIME,Blank)',`SHIMELGG_SHIME`='LogFC~"="~frac(SHIME+LGG,SHIME)'),label_parsed)
  gage_KEGG_sign_df$labelpos <- mapvalues(gage_KEGG_sign_df$Comparison,from=unique(gage_KEGG_sign_df$Comparison),to=c(0.5,2,-0.3))
  gage_KEGG_sign_df$labelpos <- as.numeric(gage_KEGG_sign_df$labelpos)

  p <- ggplot(data=gage_KEGG_sign_df[gage_KEGG_sign_df$Comparison!="SHIMELGG_Blank",],aes(x=as.numeric(stat.mean),y=KEGGpathway))
  p <- p + geom_bar(aes(fill=KEGGpathway),stat="identity") + facet_grid(.~Comparison,scales="free", labeller = gageplot_names)
  p <- papertheme(p,sizeselect=16) + theme(axis.text.x = element_text(angle =0),strip.text.y =element_text(angle = 0, hjust = 1),panel.background = element_rect(color="black",size=1))
  p <- p + ylab("Significant KEGG pathways (p<0.01)") + xlab("Mean LogFC") + theme(legend.position = "top", legend.direction="horizontal")
  #p <- p + scale_fill_continuous(name="FDR adjusted global p-value",low="#66CCFF",high="#003366")
   p <- p + scale_fill_manual(name="Pathway",values=c("no"="grey","hsa04668 TNF signaling pathway"="#ff084aFF","hsa04621 NOD-like receptor signaling pathway"="#ff084aE6","hsa04064 NF-kappa B signaling pathway"="#ff084aD6","hsa04657 IL-17 signaling pathway"="#ff084aBF","hsa04217 Necroptosis"="#ff084aB3","hsa04060 Cytokine-cytokine receptor interaction"="#ff084a80","hsa04625 C-type lectin receptor signaling pathway"="#ff084a73","hsa04623 Cytosolic DNA-sensing pathway"="#ff084aA6","hsa04210 Apoptosis" ="#ff084a66","hsa04620 Toll-like receptor signaling pathway"="#ff084a59","hsa04659 Th17 cell differentiation"="#ff084a4D","hsa04062 Chemokine signaling pathway"="#ff084a40","hsa04650 Natural killer cell mediated cytotoxicity"="#ff084a33","hsa04612 Antigen processing and presentation"="#ff084a26","hsa04660 T cell receptor signaling pathway"="#ff084a1A","hsa04658 Th1 and Th2 cell differentiation"="#ff084a0D","hsa04622 RIG-I-like receptor signaling pathway"="#be29ecFF","hsa04061 Viral protein interaction with cytokine and cytokine receptor"="#be29ec80","hsa04010 MAPK signaling pathway"="#107dacFF","hsa04630 JAK-STAT signaling pathway"="#107dac80","hsa04218 Cellular senescence"="#576396FF","hsa04380 Osteoclast differentiation"="#576396BF","hsa04917 Prolactin signaling pathway"="#57639680","hsa04722 Neurotrophin signaling pathway"="#57639640","hsa04141 Protein processing in endoplasmic reticulum"="#789420D9","hsa03008 Ribosome biogenesis in eukaryotes"="#789420B3","hsa03050 Proteasome"="#7894208C","hsa04120 Ubiquitin mediated proteolysis"="#78942066","hsa03010 Ribosome"="#78942040","hsa04144 Endocytosis"="#856466","hsa03040 Spliceosome"="#f9b949FF","hsa03013 RNA transport" ="#f9b94980","hsa03015 mRNA surveillance pathway"="#f9b94940","hsa03018 RNA degradation"="#f9b9491A","hsa04066 HIF-1 signaling pathway"="#f9dbbc","hsa04926 Relaxin signaling pathway" ="#669cc0","hsa04742 Taste transduction"="#3f6a2e", "hsa04740 Olfactory transduction" ="#527842","hsa04080 Neuroactive ligand-receptor interaction" = "#ccdeea","hsa04071 Sphingolipid signaling pathway"="#00243c"))
  p <- p + geom_text(aes(x=labelpos,y=KEGGpathway,label=paste("p=",sprintf("%.e",q.val),sep=" ")),size=6,family='sans')
  p <- p + theme(legend.position = "none")
  #p
  gage_bar <- p

# Link to individual genes and Limma results - color volcano plots by pathways!
  ## SHIME-Blank
  gage_KEGG_SHIME_Blank_core
  DEresults_SHIME_Blank_unfiltered$pathway <- mapvalues(DEresults_SHIME_Blank_unfiltered$ENTREZID,from=gage_KEGG_SHIME_Blank_core$value,to=gage_KEGG_SHIME_Blank_core$L1)
  DEresults_SHIME_Blank_unfiltered$pathway[-grep("hsa",DEresults_SHIME_Blank_unfiltered$pathway)] <- "no"
  DEresults_SHIME_Blank_unfiltered$pathway[is.na(DEresults_SHIME_Blank_unfiltered$pathway)] <- "no"
  DEresults_SHIME_Blank_unfiltered[DEresults_SHIME_Blank_unfiltered$logFC<0,]$pathway <- "no"
  DEresults_SHIME_Blank_unfiltered$pathway

  plot <- ggplot(DEresults_SHIME_Blank_unfiltered[order(factor(DEresults_SHIME_Blank_unfiltered$pathway),decreasing=TRUE),],aes(y=-log10(P.Value),x=logFC)) + geom_point(aes(size=AveExpr,color=pathway),alpha=0.4)
  plot <- plot + ylab("-log10(p-value)") + xlab("LogFC")
  plot <- papertheme(plot,sizeselect=16)+ theme(legend.justification = "center")
  plot <- plot + scale_color_manual(name="Pathway",values=c("no"="#ccd0ccA4","hsa04668 TNF signaling pathway"="#ff084aFF","hsa04621 NOD-like receptor signaling pathway"="#ff084aE6","hsa04064 NF-kappa B signaling pathway"="#ff084aD6","hsa04657 IL-17 signaling pathway"="#ff084aBF","hsa04217 Necroptosis"="#ff084aB3","hsa04060 Cytokine-cytokine receptor interaction"="#ff084a80","hsa04625 C-type lectin receptor signaling pathway"="#ff084a73","hsa04623 Cytosolic DNA-sensing pathway"="#ff084aA6","hsa04210 Apoptosis" ="#ff084a66","hsa04620 Toll-like receptor signaling pathway"="#ff084a59","hsa04659 Th17 cell differentiation"="#ff084a4D","hsa04062 Chemokine signaling pathway"="#ff084a40","hsa04650 Natural killer cell mediated cytotoxicity"="#ff084a33","hsa04612 Antigen processing and presentation"="#ff084a26","hsa04660 T cell receptor signaling pathway"="#ff084a1A","hsa04658 Th1 and Th2 cell differentiation"="#ff084a0D","hsa04622 RIG-I-like receptor signaling pathway"="#be29ecFF","hsa04061 Viral protein interaction with cytokine and cytokine receptor"="#be29ec80","hsa04010 MAPK signaling pathway"="#107dacFF","hsa04630 JAK-STAT signaling pathway"="#107dac80","hsa04218 Cellular senescence"="#576396FF","hsa04380 Osteoclast differentiation"="#576396BF","hsa04917 Prolactin signaling pathway"="#57639680","hsa04722 Neurotrophin signaling pathway"="#57639640","hsa03040 Spliceosome"="#789420FF","hsa04141 Protein processing in endoplasmic reticulum"="#789420D9","hsa03008 Ribosome biogenesis in eukaryotes"="#789420B3","hsa03050 Proteasome"="#7894208C","hsa04120 Ubiquitin mediated proteolysis"="#78942066","hsa03010 Ribosome"="#78942040","hsa04144 Endocytosis"="#856466","hsa03013 RNA transport" ="#f9b949FF","hsa03015 mRNA surveillance pathway"="#f9b94980","hsa03018 RNA degradation"="#f9b94940","hsa04066 HIF-1 signaling pathway"="#f9dbbc","hsa04926 Relaxin signaling pathway" ="#669cc0","hsa04742 Taste transduction"="#3f6a2e", "hsa04740 Olfactory transduction" ="#527842","hsa04080 Neuroactive ligand-receptor interaction" = "#ccdeea","hsa04071 Sphingolipid signaling pathway"="#00243c"))
  plot <- plot + scale_alpha_manual(values=c("no"=0.9))
  plot <- plot + scale_size_continuous(name="Average expression",labels=function(x) format(x,scientific=FALSE,digits=1))
  plot <- plot + scale_y_continuous(labels=function(l) sprintf("%1.0f",l))
  plot <- plot + scale_x_continuous(labels=function(l) sprintf("%1.0f",l))
  plot <- plot + geom_text_repel(data=DEresults_SHIME_Blank_unfiltered[DEresults_SHIME_Blank_unfiltered$pathway!="no"&DEresults_SHIME_Blank_unfiltered$P.Value<0.05,],aes(y=-log10(P.Value),x=logFC,label=DEresults_SHIME_Blank_unfiltered[DEresults_SHIME_Blank_unfiltered$pathway!="no"&DEresults_SHIME_Blank_unfiltered$P.Value<0.05,]$GENENAME,color=pathway),size=5,show.legend=F,fontface = "italic", max.overlaps = 15,family="sans")
  plot <- plot + geom_hline(yintercept =-log10(0.05),linetype="dashed")
  plot<- plot + theme(legend.position="none")
  #plot
  volcano_gage_SHIME_Blank <- plot

  ## SHIMELGG SHIME
  gage_KEGG_SHIMELGG_SHIME_core
  DEresults_SHIMELGG_SHIME_unfiltered$pathway <- mapvalues(DEresults_SHIMELGG_SHIME_unfiltered$ENTREZID,from=gage_KEGG_SHIMELGG_SHIME_core$value,to=gage_KEGG_SHIMELGG_SHIME_core$L1)
  DEresults_SHIMELGG_SHIME_unfiltered$pathway[-grep("hsa",DEresults_SHIMELGG_SHIME_unfiltered$pathway)] <- "no"
  DEresults_SHIMELGG_SHIME_unfiltered$pathway[is.na(DEresults_SHIMELGG_SHIME_unfiltered$pathway)] <- "no"
  DEresults_SHIMELGG_SHIME_unfiltered[DEresults_SHIMELGG_SHIME_unfiltered$logFC>0,]$pathway <- "no"
  DEresults_SHIMELGG_SHIME_unfiltered$pathway

  plot <- ggplot(DEresults_SHIMELGG_SHIME_unfiltered[order(factor(DEresults_SHIMELGG_SHIME_unfiltered$pathway),decreasing=TRUE),],aes(y=-log10(P.Value),x=logFC)) + geom_point(aes(size=AveExpr,color=pathway),alpha=0.4)
  plot <- plot + ylab("-log10(p-value)")  + xlab("LogFC")
  plot <- papertheme(plot,sizeselect=16)+ theme(legend.justification = "center")
  plot <- plot + scale_color_manual(name="Pathway",values=c("no"="#ccd0ccA4","hsa04668 TNF signaling pathway"="#ff084aFF","hsa04621 NOD-like receptor signaling pathway"="#ff084aE6","hsa04064 NF-kappa B signaling pathway"="#ff084aD6","hsa04657 IL-17 signaling pathway"="#ff084aBF","hsa04217 Necroptosis"="#ff084aB3","hsa04060 Cytokine-cytokine receptor interaction"="#ff084a80","hsa04625 C-type lectin receptor signaling pathway"="#ff084a73","hsa04623 Cytosolic DNA-sensing pathway"="#ff084aA6","hsa04210 Apoptosis" ="#ff084a66","hsa04620 Toll-like receptor signaling pathway"="#ff084a59","hsa04659 Th17 cell differentiation"="#ff084a4D","hsa04062 Chemokine signaling pathway"="#ff084a40","hsa04650 Natural killer cell mediated cytotoxicity"="#ff084a33","hsa04612 Antigen processing and presentation"="#ff084a26","hsa04660 T cell receptor signaling pathway"="#ff084a1A","hsa04658 Th1 and Th2 cell differentiation"="#ff084a0D","hsa04622 RIG-I-like receptor signaling pathway"="#be29ecFF","hsa04061 Viral protein interaction with cytokine and cytokine receptor"="#be29ec80","hsa04010 MAPK signaling pathway"="#107dacFF","hsa04630 JAK-STAT signaling pathway"="#107dac80","hsa04218 Cellular senescence"="#576396FF","hsa04380 Osteoclast differentiation"="#576396BF","hsa04917 Prolactin signaling pathway"="#57639680","hsa04722 Neurotrophin signaling pathway"="#57639640","hsa03040 Spliceosome"="#789420FF","hsa04141 Protein processing in endoplasmic reticulum"="#789420D9","hsa03008 Ribosome biogenesis in eukaryotes"="#789420B3","hsa03050 Proteasome"="#7894208C","hsa04120 Ubiquitin mediated proteolysis"="#78942066","hsa03010 Ribosome"="#78942040","hsa04144 Endocytosis"="#856466","hsa03013 RNA transport" ="#f9b949FF","hsa03015 mRNA surveillance pathway"="#f9b94980","hsa03018 RNA degradation"="#f9b94940","hsa04066 HIF-1 signaling pathway"="#f9dbbc","hsa04926 Relaxin signaling pathway" ="#669cc0","hsa04742 Taste transduction"="#3f6a2e", "hsa04740 Olfactory transduction" ="#527842","hsa04080 Neuroactive ligand-receptor interaction" = "#ccdeea","hsa04071 Sphingolipid signaling pathway"="#00243c"))
  plot <- plot + scale_alpha_manual(values=c("no"=0.9))
  plot <- plot + scale_size_continuous(name="Average expression",labels=function(x) format(x,scientific=FALSE,digits=1))
  plot <- plot + scale_y_continuous(labels=function(l) sprintf("%1.0f",l))
  plot <- plot + scale_x_continuous(labels=function(l) sprintf("%1.0f",l))
  plot <- plot + geom_text_repel(data=DEresults_SHIMELGG_SHIME_unfiltered[DEresults_SHIMELGG_SHIME_unfiltered$pathway!="no"&DEresults_SHIMELGG_SHIME_unfiltered$P.Value<0.05,],aes(y=-log10(P.Value),x=logFC,label=DEresults_SHIMELGG_SHIME_unfiltered[DEresults_SHIMELGG_SHIME_unfiltered$pathway!="no"&DEresults_SHIMELGG_SHIME_unfiltered$P.Value<0.05,]$GENENAME,color=pathway),size=5,show.legend=F,fontface = "italic", max.overlaps = 10)
  plot <- plot + geom_hline(yintercept =-log10(0.05),linetype="dashed")
  plot<- plot + theme(legend.position="none")
  #plot
  volcano_gage_SHIMELGG_SHIME <- plot

# Combine all graphs
  volcano_gage <- plot_grid(volcano_gage_SHIME_Blank,volcano_gage_SHIMELGG_SHIME,ncol=2,nrow=1,rel_widths=c(0.5,0.5),rel_heights = c(1,1),align="vh",axis="lbtr")
  #volcano_gage

  #KEGG_gage <- plot_grid(volcano_gage,gage_bar,ncol=1,nrow=2,rel_widths=c(1.5,1),rel_heights = c(0.4,0.6),align="v",axis="lr")
  #KEGG_gage

  KEGG_gage <- ggdraw() + draw_plot(gage_bar,0,0.4,1,0.6) + draw_plot(volcano_gage,0.33,0,0.67,0.4)

  tiff(paste0(path,"KEGG/KEGG_sign.tiff"),width=20*dpitiff,height=14*dpitiff,res=dpitiff,compression="lzw")
  grid.draw(KEGG_gage)
  dev.off()
  
  ggdraw() +  draw_image(image_read(paste0(path,"KEGG/KEGG_sign.tiff"))) 
@
\end{landscape}

% in therminal run: 
% cd KEGG/
% rename 's/__/_/g' *.png
% rename 's/\.(?=[^.]*\.)/_/g' *.txt

<< GAGE gene-set analysis KEGG pathview plots vertical,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.cap=c("\\label{KEGG1:fig2} KEGG pathview of the ribosome biogenesis pathway in eukayrotes, which was significantly (Adjusted p-value = 2e-06) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig5} KEGG pathview of the mRNA surveillance pathway, which was significantly (Adjusted p-value = 0.00026) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig6} KEGG pathview of the RNA degradation pathway, which was significantly (Adjusted p-value = 0.00031) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig7} KEGG pathview of the spliceosome pathway, which was significantly (Adjusted p-value = 4.1e-07) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig8} KEGG pathview of the proteasome pathway, which was significantly (Adjusted p-value = 8.3e-06) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig12} KEGG pathview of the ubiquitin mediated proteolysis pathway, which was significantly (Adjusted p-value = 2.7e-05) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition significantly (4.5e-03) toned down the SHIME effect (grey and red coloring).","\\label{KEGG1:fig20} KEGG pathview of the olfactory transduction pathway, which was  upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig21} KEGG pathview of the taste transduction pathway, which was  upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly."),fig.scap=c("KEGG pathview of the ribosome biogenesis pathway in eukayrotes, which was significantly (Adjusted p-value = 2e-06) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the mRNA surveillance pathway, which was significantly (Adjusted p-value = 0.00026) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the RNA degradation pathway, which was significantly (Adjusted p-value = 0.00031) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the spliceosome pathway, which was significantly (Adjusted p-value = 4.1e-07) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the proteasome pathway, which was significantly (Adjusted p-value = 8.3e-06) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the ubiquitin mediated proteolysis pathway, which was significantly (Adjusted p-value = 2.7e-05) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the olfactory transduction pathway, which was  upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the taste transduction pathway, which was upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample."),out.width="500pt",out.height="600pt",fig.pos="H">>=
# Import all .png plots and display them
  files <- list.files(path = paste0(path,"KEGG" ),pattern = "^hsa(.*)._pathview_native.multi.png$",full.names = TRUE)
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa03008_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa03015_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa03018_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa03040_pathview_native_multi.png")   
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa03050_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04120_pathview_native_multi.png") 
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04740_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04742_pathview_native_multi.png")
@

\begin{landscape}
<< GAGE gene-set analysis KEGG pathview plots horizontal,include=TRUE,results='asis',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.cap=c("\\label{KEGG1:fig3} KEGG pathview of the ribosome pathway, which was significantly (Adjusted p-value = 0.00022) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig4} KEGG pathview of the RNA transport pathway, which was significantly (Adjusted p-value = 1e-05) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig9} KEGG pathview of the MAPK signaling pathway, which was significantly (Adjusted p-value = 8.5e-06) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition significantly (p = 9.9e-03) toned down the SHIME effect (grey and red coloring).","\\label{KEGG1:fig10} KEGG pathview of the HIF-1 signaling pathway, which was significantly (Adjusted p-value = 0.0052) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig11} KEGG pathview of the neuroactive ligand-receptor pathway, which was upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig13} KEGG pathview of the protein processing in endoplasmic reticulum, which was significantly (2.0e-06) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition significantly (p = 6.6e-04) toned down the SHIME effect (grey and red coloring).","\\label{KEGG1:fig14} KEGG pathview of endocytosis, which was significantly (0.00024) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition significantly (p = 0.00046) toned down the SHIME effect (grey and red coloring).","\\label{KEGG1:fig15} KEGG pathview of necroptosis, which was significantly (1.2e-07) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition significantly (p = 7.4e-03) toned down the SHIME effect (grey and red coloring).","\\label{KEGG1:fig16} KEGG pathview of the cellular senescence pathway, which was significantly (0.0029) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig17} KEGG pathview of the antigen processing and presentation pathway, which was significantly (0.0028) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig18} KEGG pathview of the natural killer cell mediated cytotoxicity pathway, which was significantly (0.0028) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition toned down the SHIME effect (grey and red coloring), though not significantly.","\\label{KEGG1:fig19} KEGG pathview of the TNF signaling pathway, which was significantly (3.3e-14) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample. The difference in gene expression between a SHIME and Blank sample and the difference in gene expression between a SHIME sample amended with LGG and the SHIME sample without LGG were mapped onto the pathway with a color coding in boxes which were divided in two states. Green coloring revealed up-regulation of several genes by SHIME stimulation. LGG addition significantly (7.6e-05) toned down the SHIME effect (grey and red coloring)."),fig.scap=c("KEGG pathview of the ribosome pathway, which was significantly (Adjusted p-value = 0.00022) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the RNA transport pathway, which was significantly (Adjusted p-value = 1e-05) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the MAPK signaling pathway, which was significantly (Adjusted p-value = 8.5e-06) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the HIF-1 signaling pathway, which was significantly (Adjusted p-value = 0.0052) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the neuroactive ligand-receptor pathway, which was upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the protein processing in endoplasmic reticulum, which was significantly (2.0e-06) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of endocytosis, which was significantly (0.00024) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of necroptosis, which was significantly (1.2e-07) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the cellular senescence pathway, which was significantly (0.0029) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the antigen processing and presentation pathway, which was significantly (0.0028) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the natural killer cell mediated cytotoxicity pathway, which was significantly (0.0028) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample.","KEGG pathview of the TNF signaling pathway, which was significantly (3.3e-14) upregulated after exposure of the triple coculture cell model to the distal colon SHIME sample."),fig.pos="H",fig.width=10,fig.height=8,out.width="600pt",out.height="450pt">>=
# Import all .png plots and display them
  files <- list.files(path = paste0(path,"KEGG" ),pattern = "^hsa(.*)._pathview_native.multi.png$",full.names = TRUE)
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa03010_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa03013_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04010_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04066_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04080_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04141_pathview_native_multi.png")
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04144_pathview_native_multi.png") 
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04217_pathview_native_multi.png") 
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04218_pathview_native_multi.png")  
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04612_pathview_native_multi.png") 
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04650_pathview_native_multi.png") 
  knitr::include_graphics("/Projects1/Kim/2021_AnneloreBeterams_MicroArrayTranscriptomics/KEGG/hsa04668_pathview_native_multi.png")  
@
\end{landscape}



\section{Gene ontology based gene-set analysis}

<< GAGE gene-set analysis GO,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
# Species supported by Bioconductor and KEGG code corresponding to humans
  data(bods)
  print(bods)

# Generate up-to-date GO datasets
  go.hs=go.gsets(species="human")
  go.bp=go.hs$go.sets[go.hs$go.subs$BP]
  go.mf=go.hs$go.sets[go.hs$go.subs$MF]
  go.cc=go.hs$go.sets[go.hs$go.subs$CC]
  #save(go.bp, go.mf, go.cc, file="go.hs.gsets.RData")
  head(go.bp)

# Create expresion dataset with Entrez Gene IDs
  Entrez_gage <- mol.sum(mol.data = CELdata_RMA_core_expr, id.map = as.matrix(mapping_Entrez),sum.method = "mean")

# Run gage based on GO
  gage_GOBP_SHIME_Blank <- gage(Entrez_gage, gsets = go.bp, ref = c(1,2,3),samp = c(4,5,6), compare ="unpaired")
  gage_GOBP_SHIMELGG_Blank <- gage(Entrez_gage, gsets = go.bp, ref = c(1,2,3),samp = c(7,8,9), compare ="unpaired")
  gage_GOBP_SHIMELGG_SHIME <- gage(Entrez_gage, gsets = go.bp, ref = c(4,5,6),samp = c(7,8,9), compare ="unpaired")

  gage_GOMF_SHIME_Blank <- gage(Entrez_gage, gsets = go.mf, ref = c(1,2,3),samp = c(4,5,6), compare ="unpaired")
  gage_GOMF_SHIMELGG_Blank <- gage(Entrez_gage, gsets = go.mf, ref = c(1,2,3),samp = c(7,8,9), compare ="unpaired")
  gage_GOMF_SHIMELGG_SHIME <- gage(Entrez_gage, gsets = go.mf, ref = c(4,5,6),samp = c(7,8,9), compare ="unpaired")

  gage_GOCC_SHIME_Blank <- gage(Entrez_gage, gsets = go.cc, ref = c(1,2,3),samp = c(4,5,6), compare ="unpaired")
  gage_GOCC_SHIMELGG_Blank <- gage(Entrez_gage, gsets = go.cc, ref = c(1,2,3),samp = c(7,8,9), compare ="unpaired")
  gage_GOCC_SHIMELGG_SHIME <- gage(Entrez_gage, gsets = go.cc, ref = c(4,5,6),samp = c(7,8,9), compare ="unpaired")

# Inspect gage results
  head(gage_GOBP_SHIME_Blank$greater, 4)
  head(gage_GOBP_SHIME_Blank$less, 4)

# Export GAGE results in separate dataframes
  gage_GOBP_SHIME_Blank_df <- rbindlist(l=lapply(gage_GOBP_SHIME_Blank, function(x) {if(any(class(x)=="matrix")) data.frame(GOBP = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOBP_SHIME_Blank_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOBP_SHIMELGG_Blank_df <- rbindlist(l=lapply(gage_GOBP_SHIMELGG_Blank, function(x) {if(any(class(x)=="matrix")) data.frame(GOBP = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOBP_SHIMELGG_Blank_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOBP_SHIMELGG_SHIME_df <- rbindlist(l=lapply(gage_GOBP_SHIMELGG_SHIME, function(x) {if(any(class(x)=="matrix")) data.frame(GOBP = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOBP_SHIMELGG_SHIME_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")

  gage_GOMF_SHIME_Blank_df <- rbindlist(l=lapply(gage_GOMF_SHIME_Blank, function(x) {if(any(class(x)=="matrix")) data.frame(GOMF = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOMF_SHIME_Blank_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOMF_SHIMELGG_Blank_df <- rbindlist(l=lapply(gage_GOMF_SHIMELGG_Blank, function(x) {if(any(class(x)=="matrix")) data.frame(GOMF = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOMF_SHIMELGG_Blank_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOMF_SHIMELGG_SHIME_df <- rbindlist(l=lapply(gage_GOMF_SHIMELGG_SHIME, function(x) {if(any(class(x)=="matrix")) data.frame(GOMF = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOMF_SHIMELGG_SHIME_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")

  gage_GOCC_SHIME_Blank_df <- rbindlist(l=lapply(gage_GOCC_SHIME_Blank, function(x) {if(any(class(x)=="matrix")) data.frame(GOCC = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOCC_SHIME_Blank_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOCC_SHIMELGG_Blank_df <- rbindlist(l=lapply(gage_GOCC_SHIMELGG_Blank, function(x) {if(any(class(x)=="matrix")) data.frame(GOCC = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOCC_SHIMELGG_Blank_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOCC_SHIMELGG_SHIME_df <- rbindlist(l=lapply(gage_GOCC_SHIMELGG_SHIME, function(x) {if(any(class(x)=="matrix")) data.frame(GOCC = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOCC_SHIMELGG_SHIME_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")

# Export GAGE results in 1 dataframe
  gage_GOBP_df <- rbind(cbind(Comparison="SHIME_Blank",gage_GOBP_SHIME_Blank_df),cbind(Comparison="SHIMELGG_Blank",gage_GOBP_SHIMELGG_Blank_df),cbind(Comparison="SHIMELGG_SHIME",gage_GOBP_SHIMELGG_SHIME_df))

  gage_GOMF_df <- rbind(cbind(Comparison="SHIME_Blank",gage_GOMF_SHIME_Blank_df),cbind(Comparison="SHIMELGG_Blank",gage_GOMF_SHIMELGG_Blank_df),cbind(Comparison="SHIMELGG_SHIME",gage_GOMF_SHIMELGG_SHIME_df))

  gage_GOCC_df <- rbind(cbind(Comparison="SHIME_Blank",gage_GOCC_SHIME_Blank_df),cbind(Comparison="SHIMELGG_Blank",gage_GOCC_SHIMELGG_Blank_df),cbind(Comparison="SHIMELGG_SHIME",gage_GOCC_SHIMELGG_SHIME_df))

  gage_GO_df <- rbind(cbind(Category="BP",gage_GOBP_df),cbind(Category="MF",gage_GOMF_df),cbind(Category="CC",gage_GOCC_df))

# Significant results cutoff at 0.01
  gage_GOBP_SHIME_Blank_sign <- sigGeneSet(gage_GOBP_SHIME_Blank, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))
  gage_GOBP_SHIMELGG_Blank_sign <- sigGeneSet(gage_GOBP_SHIMELGG_Blank, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))
  gage_GOBP_SHIMELGG_SHIME_sign <- sigGeneSet(gage_GOBP_SHIMELGG_SHIME, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))

  gage_GOMF_SHIME_Blank_sign <- sigGeneSet(gage_GOMF_SHIME_Blank, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))
  gage_GOMF_SHIMELGG_Blank_sign <- sigGeneSet(gage_GOMF_SHIMELGG_Blank, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))
  gage_GOMF_SHIMELGG_SHIME_sign <- sigGeneSet(gage_GOMF_SHIMELGG_SHIME, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))

  gage_GOCC_SHIME_Blank_sign <- sigGeneSet(gage_GOCC_SHIME_Blank, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))
  gage_GOCC_SHIMELGG_Blank_sign <- sigGeneSet(gage_GOCC_SHIMELGG_Blank, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))
  gage_GOCC_SHIMELGG_SHIME_sign <- sigGeneSet(gage_GOCC_SHIMELGG_SHIME, cutoff=0.01,heatmap=FALSE, pdf.size = c(21,10))

# Export significant GAGE results in separate dataframes
  gage_GOBP_SHIME_Blank_sign_df <- rbindlist(l=lapply(gage_GOBP_SHIME_Blank_sign, function(x) {if(any(class(x)=="matrix")) data.frame(GOBPpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOBP_SHIME_Blank_sign_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOBP_SHIMELGG_Blank_sign_df <- rbindlist(l=lapply(gage_GOBP_SHIMELGG_Blank_sign, function(x) {if(any(class(x)=="matrix")) data.frame(GOBPpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOBP_SHIMELGG_Blank_sign_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOBP_SHIMELGG_SHIME_sign_df <- rbindlist(l=lapply(gage_GOBP_SHIMELGG_SHIME_sign, function(x) {if(any(class(x)=="matrix")) data.frame(GOBPpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOBP_SHIMELGG_SHIME_sign_df) <- c(".id","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3","Ontology")

  gage_GOMF_SHIME_Blank_sign_df <- rbindlist(l=lapply(gage_GOMF_SHIME_Blank_sign, function(x) {if(any(class(x)=="matrix")) data.frame(GOMFpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOMF_SHIME_Blank_sign_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOMF_SHIMELGG_Blank_sign_df <- rbindlist(l=lapply(gage_GOMF_SHIMELGG_Blank_sign, function(x) {if(any(class(x)=="matrix")) data.frame(GOMFpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOMF_SHIMELGG_Blank_sign_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOMF_SHIMELGG_SHIME_sign_df <- rbindlist(l=lapply(gage_GOMF_SHIMELGG_SHIME_sign, function(x) {if(any(class(x)=="matrix")) data.frame(GOMFpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOMF_SHIMELGG_SHIME_sign_df) <- c(".id","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3","Ontology")

  gage_GOCC_SHIME_Blank_sign_df <- rbindlist(l=lapply(gage_GOCC_SHIME_Blank_sign, function(x) {if(any(class(x)=="matrix")) data.frame(GOCCpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOCC_SHIME_Blank_sign_df) <- c(".id","Ontology","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOCC_SHIMELGG_Blank_sign_df <- rbindlist(l=lapply(gage_GOCC_SHIMELGG_Blank_sign, function(x) {if(any(class(x)=="matrix")) data.frame(GOCCpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOCC_SHIMELGG_Blank_sign_df) <- c(".id","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3")
  gage_GOCC_SHIMELGG_SHIME_sign_df <- rbindlist(l=lapply(gage_GOCC_SHIMELGG_SHIME_sign, function(x) {if(any(class(x)=="matrix")) data.frame(GOCCpathway = row.names(x), x) else x}),idcol=TRUE,fill=TRUE)
  colnames(gage_GOCC_SHIMELGG_SHIME_sign_df) <- c(".id","p.geomean","stat.mean","p.val","q.val","set.size","Sample1","Sample2","Sample3","Ontology")

# Combine significant pathways in one dataframe
  gage_GOBP_sign_df <- rbind(cbind(Comparison="SHIME_Blank",data.frame(gage_GOBP_SHIME_Blank_sign_df)),cbind(Comparison="SHIMELGG_Blank",data.frame(gage_GOBP_SHIMELGG_Blank_sign_df)),cbind(Comparison="SHIMELGG_SHIME",data.frame(gage_GOBP_SHIMELGG_SHIME_sign_df)[colnames(gage_GOBP_SHIME_Blank_sign_df)]))

  gage_GOMF_sign_df <- rbind(cbind(Comparison="SHIME_Blank",data.frame(gage_GOMF_SHIME_Blank_sign_df)),cbind(Comparison="SHIMELGG_Blank",data.frame(gage_GOMF_SHIMELGG_Blank_sign_df)),cbind(Comparison="SHIMELGG_SHIME",data.frame(gage_GOMF_SHIMELGG_SHIME_sign_df)[colnames(gage_GOMF_SHIME_Blank_sign_df)]))

  gage_GOCC_sign_df <- rbind(cbind(Comparison="SHIME_Blank",data.frame(gage_GOCC_SHIME_Blank_sign_df)),cbind(Comparison="SHIMELGG_SHIME",data.frame(gage_GOCC_SHIMELGG_SHIME_sign_df)[colnames(gage_GOCC_SHIME_Blank_sign_df)]))

  gage_GO_sign_df <- rbind(cbind(Category="BP",gage_GOBP_sign_df),cbind(Category="MF",gage_GOMF_sign_df),cbind(Category="CC",gage_GOCC_sign_df))

  gage_GO_sign_df <- gage_GO_sign_df[gage_GO_sign_df$.id!="stats",]
  gage_GO_sign_df$Ontology <- factor(gage_GO_sign_df$Ontology,levels=rev(unique(gage_GO_sign_df$Ontology)))

# Remove redundant gene-sets
  gage_GOBP_SHIME_Blank_sig_up <- esset.grp(gage_GOBP_SHIME_Blank$greater,Entrez_gage, gsets = go.bp, ref = c(1,2,3), samp = c(4,5,6), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
 #gage_GOBP_SHIME_Blank_sig_down <- esset.grp(gage_GOBP_SHIME_Blank$less,Entrez_gage, gsets = go.bp, ref = c(1,2,3), samp = c(4,5,6), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

  gage_GOBP_SHIMELGG_Blank_sig_up <- esset.grp(gage_GOBP_SHIMELGG_Blank$greater,Entrez_gage, gsets = go.bp, ref = c(1,2,3), samp = c(7,8,9), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  #gage_GOBP_SHIMELGG_Blank_sig_down <- esset.grp(gage_GOBP_SHIMELGG_Blank$less,Entrez_gage, gsets = go.bp, ref = c(1,2,3), samp = c(7,8,9), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

  #gage_GOBP_SHIMELGG_SHIME_sig_up <- esset.grp(gage_GOBP_SHIMELGG_SHIME$greater,Entrez_gage, gsets = go.bp, ref = c(4,5,6), samp = c(7,8,9), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  gage_GOBP_SHIMELGG_SHIME_sig_down <- esset.grp(gage_GOBP_SHIMELGG_SHIME$less,Entrez_gage, gsets = go.bp, ref = c(4,5,6), samp = c(7,8,9), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

  gage_GOMF_SHIME_Blank_sig_up <- esset.grp(gage_GOMF_SHIME_Blank$greater,Entrez_gage, gsets = go.mf, ref = c(1,2,3), samp = c(4,5,6), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  #gage_GOMF_SHIME_Blank_sig_down <- esset.grp(gage_GOMF_SHIME_Blank$less,Entrez_gage, gsets = go.mf, ref = c(1,2,3), samp = c(4,5,6), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

  gage_GOMF_SHIMELGG_Blank_sig_up <- esset.grp(gage_GOMF_SHIMELGG_Blank$greater,Entrez_gage, gsets = go.mf, ref = c(1,2,3), samp = c(7,8,9), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  #gage_GOMF_SHIMELGG_Blank_sig_down <- esset.grp(gage_GOMF_SHIMELGG_Blank$less,Entrez_gage, gsets = go.mf, ref = c(1,2,3), samp = c(7,8,9), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

  #gage_GOMF_SHIMELGG_SHIME_sig_up <- esset.grp(gage_GOMF_SHIMELGG_SHIME$greater,Entrez_gage, gsets = go.mf, ref = c(4,5,6), samp = c(7,8,9), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  gage_GOMF_SHIMELGG_SHIME_sig_down <- esset.grp(gage_GOMF_SHIMELGG_SHIME$less,Entrez_gage, gsets = go.mf, ref = c(4,5,6), samp = c(7,8,9), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

  gage_GOCC_SHIME_Blank_sig_up <- esset.grp(gage_GOCC_SHIME_Blank$greater,Entrez_gage, gsets = go.cc, ref = c(1,2,3), samp = c(4,5,6), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  #gage_GOCC_SHIME_Blank_sig_down <- esset.grp(gage_GOCC_SHIME_Blank$less,Entrez_gage, gsets = go.cc, ref = c(1,2,3), samp = c(4,5,6), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

  #gage_GOCC_SHIMELGG_Blank_sig_up <- esset.grp(gage_GOCC_SHIMELGG_Blank$greater,Entrez_gage, gsets = go.cc, ref = c(1,2,3), samp = c(7,8,9), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  #gage_GOCC_SHIMELGG_Blank_sig_down <- esset.grp(gage_GOCC_SHIMELGG_Blank$less,Entrez_gage, gsets = go.cc, ref = c(1,2,3), samp = c(7,8,9), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

  #gage_GOCC_SHIMELGG_SHIME_sig_up <- esset.grp(gage_GOCC_SHIMELGG_SHIME$greater,Entrez_gage, gsets = go.cc, ref = c(4,5,6), samp = c(7,8,9), test4up = T,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)
  gage_GOCC_SHIMELGG_SHIME_sig_down <- esset.grp(gage_GOCC_SHIMELGG_SHIME$less,Entrez_gage, gsets = go.cc, ref = c(4,5,6), samp = c(7,8,9), test4up = F,  output=FALSE, make.plot = F , use.q=TRUE,cutoff=0.01,pc=10^-10)

# Inspect significant non-redundant gene-sets
  names(gage_GOBP_SHIME_Blank_sig_up)
  gage_GOBP_SHIME_Blank_sig_up$essentialSets
  gage_GOBP_SHIMELGG_Blank_sig_up$essentialSets
  gage_GOBP_SHIMELGG_SHIME_sig_down$essentialSets
  gage_GOBP_SHIME_Blank_sig_up$setGroups
  gage_GOBP_SHIME_Blank_sig_up$allSets
  gage_GOBP_SHIME_Blank_sig_up$allSetsconnectedComponent
  gage_GOBP_SHIME_Blank_sig_up$overlapCounts
  gage_GOBP_SHIME_Blank_sig_up$overlapPvals
  gage_GOBP_SHIME_Blank_sig_up$coreGeneSets

# Make list of core genes
  gage_GOBP_SHIME_Blank_core <- rbind(cbind(Comparison="SHIME_Blank",Direction="Up",reshape::melt(gage_GOBP_SHIME_Blank_sig_up$coreGeneSets)))
  gage_GOBP_SHIMELGG_Blank_core <- rbind(cbind(Comparison="SHIMELGG_Blank",Direction="Up",reshape::melt(gage_GOBP_SHIMELGG_Blank_sig_up$coreGeneSets)))
  gage_GOBP_SHIMELGG_SHIME_core <- cbind(Comparison="SHIMELGG_SHIME",Direction="Down",reshape::melt(gage_GOBP_SHIMELGG_SHIME_sig_down$coreGeneSets[lengths(gage_GOBP_SHIMELGG_SHIME_sig_down$coreGeneSets)>0]))
  gage_GOBP_core <- rbind(gage_GOBP_SHIME_Blank_core,gage_GOBP_SHIMELGG_Blank_core,gage_GOBP_SHIMELGG_SHIME_core)

  gage_GOMF_SHIME_Blank_core <- rbind(cbind(Comparison="SHIME_Blank",Direction="Up",reshape::melt(gage_GOMF_SHIME_Blank_sig_up$coreGeneSets)))
  gage_GOMF_SHIMELGG_Blank_core <- rbind(cbind(Comparison="SHIMELGG_Blank",Direction="Up",reshape::melt(gage_GOMF_SHIMELGG_Blank_sig_up$coreGeneSets)))
  gage_GOMF_SHIMELGG_SHIME_core <- cbind(Comparison="SHIMELGG_SHIME",Direction="Down",reshape::melt(gage_GOMF_SHIMELGG_SHIME_sig_down$coreGeneSets[lengths(gage_GOMF_SHIMELGG_SHIME_sig_down$coreGeneSets)>0]))
  gage_GOMF_core <- rbind(gage_GOMF_SHIME_Blank_core,gage_GOMF_SHIMELGG_Blank_core,gage_GOMF_SHIMELGG_SHIME_core)

  gage_GOCC_SHIME_Blank_core <- rbind(cbind(Comparison="SHIME_Blank",Direction="Up",reshape::melt(gage_GOCC_SHIME_Blank_sig_up$coreGeneSets)))
  #gage_GOCC_SHIMELGG_Blank_core <- rbind(cbind(Comparison="SHIMELGG_Blank",Direction="Up",reshape::melt(gage_GOCC_SHIMELGG_Blank_sig_up$coreGeneSets)))
  gage_GOCC_SHIMELGG_SHIME_core <- cbind(Comparison="SHIMELGG_SHIME",Direction="Down",reshape::melt(gage_GOCC_SHIMELGG_SHIME_sig_down$coreGeneSets[lengths(gage_GOCC_SHIMELGG_SHIME_sig_down$coreGeneSets)>0]))
  gage_GOCC_core <- rbind(gage_GOCC_SHIME_Blank_core,gage_GOCC_SHIMELGG_SHIME_core)

  gage_GO_core <- rbind(cbind(Category="BP",gage_GOBP_core),cbind(Category="MF",gage_GOMF_core),cbind(Category="CC",gage_GOCC_core))

# Find individual gene names contributing to all significant GOterms
  # significant_GOterms_geneIDs <- c()
  # for (i in unique(gage_GOBP_sign_df$Ontology)){
  # print(go.bp[i])
  # print(unlist(go.bp[i]))
  # significant_GOterms_geneIDs <- c(significant_GOterms_geneIDs,unlist(go.bp[i]))}
  significant_GOBP_geneIDs <- unlist(go.bp[unique(as.character(gage_GO_sign_df$Ontology))])
  significant_GOMF_geneIDs <- unlist(go.bp[unique(as.character(gage_GO_sign_df$Ontology))])
  significant_GOCC_geneIDs <- unlist(go.bp[unique(as.character(gage_GO_sign_df$Ontology))])
  significant_GOterms_geneIDs <- c(significant_GOBP_geneIDs,significant_GOMF_geneIDs,significant_GOCC_geneIDs)

# Find expression data of all genes contributing to all significant GOterms
  significant_GOterms_expdata <- Entrez_gage[rownames(Entrez_gage)%in%unique(significant_GOterms_geneIDs),]

# Find expression data of all genes expressed above background contributing to all significant GOterms
  gage_GOBP_DABG <- reshape2::melt(go.bp[unique(as.character(gage_GOBP_sign_df$Ontology))])
  gage_GOMF_DABG <- reshape2::melt(go.mf[unique(as.character(gage_GOMF_sign_df$Ontology))])
  gage_GOCC_DABG <- reshape2::melt(go.cc[unique(as.character(gage_GOCC_sign_df$Ontology))])

  gage_GOBP_SHIME_Blank_DABG <- reshape2::melt(go.bp[unique(as.character(gage_GOBP_SHIME_Blank_sign_df$Ontology))])
  gage_GOBP_SHIMELGG_Blank_DABG <- reshape2::melt(go.bp[unique(as.character(gage_GOBP_SHIMELGG_Blank_sign_df$Ontology))])
  gage_GOBP_SHIMELGG_SHIME_DABG <- reshape2::melt(go.bp[unique(as.character(gage_GOBP_SHIMELGG_SHIME_sign_df$Ontology))])

  gage_GOMF_SHIME_Blank_DABG <- reshape2::melt(go.mf[unique(as.character(gage_GOMF_SHIME_Blank_sign_df$Ontology))])
  gage_GOMF_SHIMELGG_Blank_DABG <- reshape2::melt(go.mf[unique(as.character(gage_GOMF_SHIMELGG_Blank_sign_df$Ontology))])
  gage_GOMF_SHIMELGG_SHIME_DABG <- reshape2::melt(go.mf[unique(as.character(gage_GOMF_SHIMELGG_SHIME_sign_df$Ontology))])

  gage_GOCC_SHIME_Blank_DABG <- reshape2::melt(go.cc[unique(as.character(gage_GOCC_SHIME_Blank_sign_df$Ontology))])
  gage_GOCC_SHIMELGG_Blank_DABG <- reshape2::melt(go.cc[unique(as.character(gage_GOCC_SHIMELGG_Blank_sign_df$Ontology))])
  gage_GOCC_SHIMELGG_SHIME_DABG <- reshape2::melt(go.cc[unique(as.character(gage_GOCC_SHIMELGG_SHIME_sign_df$Ontology))])

  significant_GOterms_DABG_expdata <- essGene(significant_GOterms_geneIDs, Entrez_gage, ref =c(1,2,3), samp = c(4,5,6,7,8,9),compare="unpaired")

# Find expression data of all core genes in all significant GOterms
  significant_GOterms_expdata_coregenes <- Entrez_gage[rownames(Entrez_gage)%in%unique(gage_GO_core$value),]
@

\begin{landscape}
<< GAGE gene-set analysis GO plots,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.width=450,out.height=400,fig.cap="\\label{GAGEGO:fig1} Significantly (p$<$0.01) up- (positive LogFC) and downregulated (negative LogFC) GO BP terms as assessed by gene-set analysis (GSA) in GAGE. P-values are adjusted for multiple testing with Benjamini \\& Hochberg FDR correction. Bars are colored by the GO term category: pro-inflammatory response (pink), viral interaction (purple), RNA (green) and protein (yellow) processing, signaling patways (teal), cellular transport (brown) and cellular differentiation (blue).",fig.scap="Significantly (p$<$0.01) up- (positive LogFC) and downregulated (negative LogFC) GO BP terms as assessed by gene-set analysis (GSA) in GAGE.",fig.pos="H">>=+9
# Narrow down selection of terms
  terms <- subset(gage_GOBP_sign_df,Comparison=="SHIME_Blank"&q.val<5*10^-13|Comparison=="SHIMELGG_SHIME"&q.val<2.55*10^-4) %>% dplyr::select(Ontology)
  gage_GOBP_sign_df_plot <- gage_GOBP_sign_df[gage_GOBP_sign_df$Ontology%in%terms$Ontology,]
  gage_GOBP_sign_df_plot <- gage_GOBP_sign_df_plot[order(gage_GOBP_sign_df_plot$stat.mean),]
  gage_GOBP_sign_df_plot <- gage_GOBP_sign_df_plot %>% subset(.id!="stats")

# Visualize: bar = stat.mean colored by qval
  unique(gage_GOBP_sign_df_plot$Ontology)
  options(digits=2)

  gageplot_names <- as_labeller(c(`SHIME_Blank`='LogFC~"="~frac(SHIME,Blank)',`SHIMELGG_SHIME`='LogFC~"="~frac(SHIME+LGG,SHIME)'),label_parsed)
  gage_GOBP_sign_df_plot$labelpos <- mapvalues(gage_GOBP_sign_df_plot$Comparison,from=unique(gage_GOBP_sign_df_plot$Comparison),to=c(-1.5,2,2.5))
  gage_GOBP_sign_df_plot$labelpos <- as.numeric(gage_GOBP_sign_df_plot$labelpos)

  p <- ggplot(data=gage_GOBP_sign_df_plot[gage_GOBP_sign_df_plot$Comparison!="SHIMELGG_Blank",],aes(x=as.numeric(stat.mean),y=Ontology))
  p <- p + geom_bar(aes(fill=Ontology),stat="identity") + facet_grid(.~Comparison,scales="free", labeller = gageplot_names)
  p <- papertheme(p,sizeselect=16) + theme(axis.text.x = element_text(angle =0),strip.text.y =element_text(angle = 0, hjust = 1),panel.background = element_rect(color="black",size=1))
  p <- p + ylab("Significant BP ontology terms (p<0.01)") + xlab("Mean LogFC") + theme(legend.position = "top", legend.direction="horizontal")
  #p <- p + scale_fill_continuous(name="FDR adjusted global p-value",low="#66CCFF",high="#003366")
   p <- p + scale_fill_manual(name="Pathway",values=c("no"="grey","GO:0009615 response to virus"="#be29ecFF","GO:0051607 defense response to virus"="#be29ec80","GO:0019058 viral life cycle"="#be29ec40","GO:0042254 ribosome biogenesis"="#789420FF","GO:0002831 regulation of response to biotic stimulus"="#107dacFF","GO:0140546 defense response to symbiont"="#f5deb3","GO:0022613 ribonucleoprotein complex biogenesis"="#789420E6","GO:0045088 regulation of innate immune response"="#ff084aFF","GO:0034340 response to type I interferon"="#ff084aE6","GO:0006364 rRNA processing"="#789420D9","GO:0060337 type I interferon signaling pathway"="#ff084aD6","GO:0071357 cellular response to type I interferon"="#ff084aBF","GO:0031349 positive regulation of defense response"="#ff084aB3","GO:0043903 regulation of biological process involved in symbiotic interaction"="#f5deb380","GO:0034660 ncRNA metabolic process"="#789420BF","GO:0050792 regulation of viral process"="#be29ec33","GO:0016072 rRNA metabolic process"="#789420B3","GO:0034341 response to interferon-gamma"="#ff084a80","GO:0034470 ncRNA processing"="#78942099","GO:0006401 RNA catabolic process"="#78942080","GO:0051169 nuclear transport"="#3f6a2e","GO:0006913 nucleocytoplasmic transport"="#3f6a2e80","GO:0031331 positive regulation of cellular catabolic process"="#669cc0","GO:0070646 protein modification by small protein removal"="#78942066","GO:0009896 positive regulation of catabolic process"="#669cc0","GO:0010498 proteasomal protein catabolic process"="#7894204D","GO:0016579 protein deubiquitination"="#78942040","GO:0042176 regulation of protein catabolic process"="#669cc080","GO:0008380 RNA splicing"="#78942033","GO:0043161 proteasome-mediated ubiquitin-dependent protein catabolic process"="#7894201A","GO:0051168 nuclear export"="#ccdeea","GO:1903311 regulation of mRNA metabolic process"="#7894201A","GO:0006611 protein export from nucleus"="#3f6a2e40","GO:0015931 nucleobase-containing compound transport"="#3f6a2e33","GO:0006403 RNA localization"="#7894201A"))
  p <- p + geom_text(aes(x=labelpos,y=Ontology,label=paste("p=",sprintf("%.e",q.val),sep=" ")),size=6,family='sans')
  p <- p + theme(legend.position = "none")
  #p
  gage_bar <- p

# Link to individual genes and Limma results - color volcano plots by pathways!
  
  ## SHIME-Blank
  DEresults_SHIME_Blank_unfiltered_plot <- DEresults_SHIME_Blank_unfiltered
  gage_GOBP_SHIME_Blank_core
  DEresults_SHIME_Blank_unfiltered_plot$ontology <- mapvalues(DEresults_SHIME_Blank_unfiltered_plot$ENTREZID,from=gage_GOBP_SHIME_Blank_core$value,to=gage_GOBP_SHIME_Blank_core$L1)
  DEresults_SHIME_Blank_unfiltered_plot$ontology[!DEresults_SHIME_Blank_unfiltered_plot$ontology%in%c(terms$Ontology,"no")] <- "notinselection"
  DEresults_SHIME_Blank_unfiltered_plot$ontology[-grep("GO",DEresults_SHIME_Blank_unfiltered_plot$ontology)] <- "no"
  DEresults_SHIME_Blank_unfiltered_plot$ontology[is.na(DEresults_SHIME_Blank_unfiltered_plot$ontology)] <- "no"
  DEresults_SHIME_Blank_unfiltered_plot[DEresults_SHIME_Blank_unfiltered_plot$logFC<0,]$ontology <- "no"
  DEresults_SHIME_Blank_unfiltered_plot$ontology

  plot <- ggplot(DEresults_SHIME_Blank_unfiltered_plot[order(factor(DEresults_SHIME_Blank_unfiltered_plot$ontology),decreasing=TRUE),],aes(y=-log10(P.Value),x=logFC)) + geom_point(aes(size=AveExpr,color=ontology),alpha=0.4)
  plot <- plot + ylab("-log10(p-value)") + xlab("LogFC")
  plot <- papertheme(plot,sizeselect=16)+ theme(legend.justification = "center")
  plot <- plot + scale_alpha_manual(values=c("no"=0.9))
  plot <- plot + scale_size_continuous(name="Average expression",labels=function(x) format(x,scientific=FALSE,digits=1))
  plot <- plot + scale_color_manual(name="Ontology",values=c("no"="grey","notinselection"="#999999","GO:0009615 response to virus"="#be29ecFF","GO:0051607 defense response to virus"="#be29ec80","GO:0019058 viral life cycle"="#be29ec40","GO:0042254 ribosome biogenesis"="#789420B3","GO:0002831 regulation of response to biotic stimulus"="#107dacFF","GO:0140546 defense response to symbiont"="#f5deb3","GO:0022613 ribonucleoprotein complex biogenesis"="#789420FF","GO:0045088 regulation of innate immune response"="#ff084aFF","GO:0034340 response to type I interferon"="#ff084aE6","GO:0006364 rRNA processing"="#789420D9","GO:0060337 type I interferon signaling pathway"="#ff084aD6","GO:0071357 cellular response to type I interferon"="#ff084aBF","GO:0031349 positive regulation of defense response"="#ff084aB3","GO:0043903 regulation of biological process involved in symbiotic interaction"="#f5deb380","GO:0034660 ncRNA metabolic process"="#789420B3","GO:0050792 regulation of viral process"="#be29ec33","GO:0016072 rRNA metabolic process"="#7894208C","GO:0034341 response to interferon-gamma"="#ff084a80","GO:0034470 ncRNA processing"="#78942066","GO:0006401 RNA catabolic process"="#78942040","GO:0051169 nuclear transport"="#3f6a2e","GO:0006913 nucleocytoplasmic transport"="#3f6a2e80","GO:0031331 positive regulation of cellular catabolic process"="#669cc0","GO:0070646 protein modification by small protein removal"="#78942033","GO:0009896 positive regulation of catabolic process"="#669cc0","GO:0010498 proteasomal protein catabolic process"="#78942026","GO:0016579 protein deubiquitination"="#7894201A","GO:0042176 regulation of protein catabolic process"="#669cc080","GO:0008380 RNA splicing"="#7894200A","GO:0043161 proteasome-mediated ubiquitin-dependent protein catabolic process"="#78942057","GO:0051168 nuclear export"="#ccdeea","GO:1903311 regulation of mRNA metabolic process"="#78942057","GO:0006611 protein export from nucleus"="#3f6a2e40","GO:0015931 nucleobase-containing compound transport"="#3f6a2e33","GO:0006403 RNA localization"="#7894200A"))
  plot <- plot + scale_y_continuous(labels=function(l) sprintf("%1.0f",l))
  plot <- plot + scale_x_continuous(labels=function(l) sprintf("%1.0f",l))
  plot <- plot + geom_text_repel(data=DEresults_SHIME_Blank_unfiltered_plot[DEresults_SHIME_Blank_unfiltered_plot$ontology!="no"&DEresults_SHIME_Blank_unfiltered_plot$P.Value<0.05,],aes(y=-log10(P.Value),x=logFC,label=DEresults_SHIME_Blank_unfiltered_plot[DEresults_SHIME_Blank_unfiltered_plot$ontology!="no"&DEresults_SHIME_Blank_unfiltered_plot$P.Value<0.05,]$GENENAME,color=ontology),size=5,show.legend=F,fontface = "italic", max.overlaps = 15,family="sans")
  plot <- plot + geom_hline(yintercept =-log10(0.05),linetype="dashed")
  plot<- plot + theme(legend.position="none")
  #plot
  volcano_gage_SHIME_Blank <- plot

  ## SHIMELGG SHIME
  DEresults_SHIMELGG_SHIME_unfiltered_plot <- DEresults_SHIMELGG_SHIME_unfiltered
  gage_GOBP_SHIMELGG_SHIME_core
  DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology <- mapvalues(DEresults_SHIMELGG_SHIME_unfiltered_plot$ENTREZID,from=gage_GOBP_SHIMELGG_SHIME_core$value,to=gage_GOBP_SHIMELGG_SHIME_core$L1)
  DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology[!DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology%in%c(terms$Ontology,"no")] <- "notinselection"
  DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology[-grep("GO",DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology)] <- "no"
  DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology[is.na(DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology)] <- "no"
  DEresults_SHIMELGG_SHIME_unfiltered_plot[DEresults_SHIMELGG_SHIME_unfiltered_plot$logFC>0,]$ontology <- "no"
  DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology

  plot <- ggplot(DEresults_SHIMELGG_SHIME_unfiltered_plot[order(factor(DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology),decreasing=TRUE),],aes(y=-log10(P.Value),x=logFC)) + geom_point(aes(size=AveExpr,color=ontology),alpha=0.4)
  plot <- plot + ylab("-log10(p-value)")  + xlab("LogFC")
  plot <- papertheme(plot,sizeselect=16)+ theme(legend.justification = "center")

  plot <- plot + scale_alpha_manual(values=c("no"=0.9))
  plot <- plot + scale_size_continuous(name="Average expression",labels=function(x) format(x,scientific=FALSE,digits=1))
   plot <- plot + scale_color_manual(name="Ontology",values=c("no"="grey","notinselection"="#999999","GO:0009615 response to virus"="#be29ecFF","GO:0051607 defense response to virus"="#be29ec80","GO:0019058 viral life cycle"="#be29ec40","GO:0042254 ribosome biogenesis"="#789420B3","GO:0002831 regulation of response to biotic stimulus"="#107dacFF","GO:0140546 defense response to symbiont"="#f5deb3","GO:0022613 ribonucleoprotein complex biogenesis"="#789420FF","GO:0045088 regulation of innate immune response"="#ff084aFF","GO:0034340 response to type I interferon"="#ff084aE6","GO:0006364 rRNA processing"="#789420D9","GO:0060337 type I interferon signaling pathway"="#ff084aD6","GO:0071357 cellular response to type I interferon"="#ff084aBF","GO:0031349 positive regulation of defense response"="#ff084aB3","GO:0043903 regulation of biological process involved in symbiotic interaction"="#f5deb380","GO:0034660 ncRNA metabolic process"="#789420B3","GO:0050792 regulation of viral process"="#be29ec33","GO:0016072 rRNA metabolic process"="#7894208C","GO:0034341 response to interferon-gamma"="#ff084a80","GO:0034470 ncRNA processing"="#78942066","GO:0006401 RNA catabolic process"="#78942040","GO:0051169 nuclear transport"="#3f6a2e","GO:0006913 nucleocytoplasmic transport"="#3f6a2e80","GO:0031331 positive regulation of cellular catabolic process"="#669cc0","GO:0070646 protein modification by small protein removal"="#78942033","GO:0009896 positive regulation of catabolic process"="#669cc0","GO:0010498 proteasomal protein catabolic process"="#78942026","GO:0016579 protein deubiquitination"="#7894201A","GO:0042176 regulation of protein catabolic process"="#669cc080","GO:0008380 RNA splicing"="#7894200A","GO:0043161 proteasome-mediated ubiquitin-dependent protein catabolic process"="#78942057","GO:0051168 nuclear export"="#ccdeea","GO:1903311 regulation of mRNA metabolic process"="#78942057","GO:0006611 protein export from nucleus"="#3f6a2e40","GO:0015931 nucleobase-containing compound transport"="#3f6a2e33","GO:0006403 RNA localization"="#7894200A"))
  plot <- plot + scale_y_continuous(labels=function(l) sprintf("%1.0f",l))
  plot <- plot + scale_x_continuous(labels=function(l) sprintf("%1.0f",l))
  plot <- plot + geom_text_repel(data=DEresults_SHIMELGG_SHIME_unfiltered_plot[DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology!="no"&DEresults_SHIMELGG_SHIME_unfiltered_plot$P.Value<0.05,],aes(y=-log10(P.Value),x=logFC,label=DEresults_SHIMELGG_SHIME_unfiltered_plot[DEresults_SHIMELGG_SHIME_unfiltered_plot$ontology!="no"&DEresults_SHIMELGG_SHIME_unfiltered_plot$P.Value<0.05,]$GENENAME,color=ontology),size=5,show.legend=F,fontface = "italic", max.overlaps = 10)
  plot <- plot + geom_hline(yintercept =-log10(0.05),linetype="dashed")
  plot<- plot + theme(legend.position="none")
  #plot
  volcano_gage_SHIMELGG_SHIME <- plot

# Combine all graphs
  volcano_gage <- plot_grid(volcano_gage_SHIME_Blank,volcano_gage_SHIMELGG_SHIME,ncol=2,nrow=1,rel_widths=c(0.5,0.5),rel_heights = c(1,1),align="vh",axis="lbtr")
  #volcano_gage

  GOBP_gage <- plot_grid(volcano_gage,gage_bar,ncol=1,nrow=2,rel_widths=c(1.5,1),rel_heights = c(0.4,0.6),align="v",axis="lr")
  #GOBP_gage

  GOBP_gage <- ggdraw() + draw_plot(gage_bar,0,0.4,1,0.6) + draw_plot(volcano_gage,0.33,0,0.67,0.4)

  tiff(paste0(path,"GO/GOBP_sign.tiff"),width=20*dpi,height=14*dpi,res=dpi,compression="lzw")
  GOBP_gage
  dev.off()

  ggdraw() +  draw_image(image_read(paste0(path,"GO/GOBP_sign.tiff")))
@
\end{landscape}

%If you are interested in working with other major pathway databases, including Reactome, MetaCyc, SMPDB, PANTHER, METACROP etc, you can use SBGNview. Please check SBGNview + GAGE based pathway analysis work





\chapter{Integrative analysis}
Results from the transcriptomics differential expression analysis were combined with functional data from mucus layer thickness, cytotoxic stress and cytokine production, flow cytometry cell counts and SCFA concentration measurements through DIABLO (Data Integration Analysis for Biomarker discovery using Latent variable approaches for Omics studies) from the mixOmics framework \Sexpr{packageVersion('mixOmics')} \cite{Singh2019}. DIABLO is a latent variable multivariate dimension reduction method that aims to identify the correlated variables that best explain the categorical outcome variable of interest (triple coculture cell model treatment: Blank, SHIME or SHIME + LGG). DIABLO thereto extends sparse generalized canonical correlation analysis, which uses singular value decomposition to select co-expressed variables from several omics datasets, to a classification framework.

% DIABLO maxmizes the common or correlated information between multiple datasets
% DIABLO extends sparse generalized canonical correlation analysis (sGCCA) [24] to a classification framework. sGCCA is a multivariate dimension reduction technique that uses singular value decomposition and selects co-expressed (correlated) variables from several omics datasets in a computationally and statistically efficient manner. sGCCA maximizes the covariance between linear combinations of variables (latent component scores) and projects the data into the smaller dimensional subspace spanned by the components. The selection of the correlated molecules across omics levels is performed internally in sGCCA with l1 –penalization on the variable coefficient vector defining the linear combinations.

The DIABLO model consisted of a design matrix containing the transcriptomics expression data and functional host-microbe interaction data, constructed with a link of 0.1. Global model performance was assessed by 5-fold cross validation, repeated 10 times, and 2 components were selected to fit the final model based on the overall and balanced error rates for the centroids distance criterion (Figure \ref{DIABLO:fig1}).

%The purpose of the full design is to select highly correlated variables regardless of their discriminatory power whereas the null design selects discriminatory variables regardless of the correlation structure between variables

Next, smart feature selection was applied and the optimal number of variables was determined based on a 10x3-fold cross validation. The performance of the final model with 2 components, each with 6 functional respectively 10 transcriptomics variables was verified using the balanced classification error rate with majority vote and centroids distance.

The correlation between variables from the transcriptomics expression data and metadata was successfully maximized (0.95 and 0.55 for the first and second component; Figure \ref{DIABLO:fig2}-\ref{DIABLO:fig3}). While a two-component model was sufficient to discriminate the blank, SHIME and SHIME+LGG cell models in both datasets, the discriminatory power was higher for the transcriptomics than the microbe-host functional data (Figure \ref{DIABLO:fig4}-\ref{DIABLO:fig5}).

The variables contributing most to the two components in both data types were displayed in Figure \ref{DIABLO:fig6}.

Finally, the correlations between and within variables from each dataset were computed using a similarity score that is analogous to a Pearson correlation coefficient and represented in a Circos plot (Figure \ref{DIABLO:fig7}) \cite{Gonzalez2012}.


<<Mixomics integration,results='hide',include=TRUE,warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,fig.cap=c("\\label{DIABLO:fig1} Overall and balanced classification error rate (BER) using Maximum, Centroids or Mahalanobis distances","\\label{DIABLO:fig2} Correlation between features in the expression and metadata along the first component.","\\label{DIABLO:fig3} Correlation between features in the expression and metadata along the second component.","\\label{DIABLO:fig4} Sample projection for the separate datasets","\\label{DIABLO:fig5} Sample projection with arrows indicating the location of each sample in the expression and metadata confirms the agreement between datasets at sample level","\\label{DIABLO:fig6} Correlation circle plot highlighting the contribution of each selected variable to each component."),fig.pos="H">>=
# Metadata formatting
metadata_nocontrol[,7:26] <- data.frame(apply(metadata_nocontrol[,7:26],2,function(x){as.numeric(gsub(",",".",na.omit(x)))}))

# Define datasets
hostmicrobe_circos <- metadata_nocontrol %>% dplyr::select(c(IL8:RelativeIL10,LDH:Mucus,FCM,Total_SCFA))
expr_circos <- t(exprs(CELdata_RMA_core[unique(DEresults_hm$`Affymetrix probe ID`),]))

rownames(hostmicrobe_circos) <- gsub("_","",rownames(hostmicrobe_circos))
rownames(expr_circos) <- gsub("_","",rownames(expr_circos))

colnames(expr_circos) <- mapvalues(colnames(expr_circos),from=DEresults_hm$`Affymetrix probe ID`,to=paste(DEresults_hm$`Affymetrix probe ID`,DEresults_hm$`Gene name`,sep=" "))

diablodata <- list(host_microbe=hostmicrobe_circos,expression=expr_circos)

# check dimension
lapply(diablodata, dim)

# outcome: condition
Y <- factor(metadata_nocontrol$Condition,levels=c("Blank","SHIME","SHIME_LGG"))
summary(Y)
length(Y)

# Design
design = matrix(0.1, ncol = length(diablodata), nrow = length(diablodata),dimnames = list(names(diablodata),names(diablodata)))
diag(design) = 0
design

# Tuning the number of components
sgccda.res = block.splsda(X = diablodata, Y = Y, ncomp = 3,design = design)

# this code takes a couple of min to run
perf.diablo = perf(sgccda.res, validation = 'Mfold', folds = 5, nrepeat = 10,cpus=40)

#perf.diablo  # lists the different outputs
plot(perf.diablo)

perf.diablo$choice.ncomp$WeightedVote
ncomp = perf.diablo$choice.ncomp$WeightedVote["Overall.ER", "centroids.dist"]

# Keep variables tuning
test.keepX = list (host_microbe=c(1:9),expression=c(seq(10,50,10)))

tune.TCGA = tune.block.splsda(X = diablodata, Y = Y, ncomp = 2,test.keepX = test.keepX, design = design,validation = 'Mfold', folds = 3, nrepeat = 10,BPPARAM = BiocParallel::SnowParam(workers=40), dist = "centroids.dist")

list.keepX = tune.TCGA$choice.keepX
list.keepX
list.keepX$host_microbe[1] <- 6
list.keepX$host_microbe[2] <- 6
list.keepX$expression[1] <- 10
list.keepX$expression[2] <- 10

# Final model
sgccda.res = block.splsda(X = diablodata, Y = Y, ncomp = 2,keepX = list.keepX, design = design)
sgccda.res$design

selectVar(sgccda.res, block = 'host_microbe', comp = 1)$host_microbe$name
selectVar(sgccda.res, block = 'expression', comp = 1)$expression$name
selectVar(sgccda.res, block = 'host_microbe', comp = 2)$host_microbe$name
selectVar(sgccda.res, block = 'expression', comp = 2)$expression$name

# Sample plots
plotDiablo(sgccda.res, ncomp = 1,col.per.group=c('Blank'="#ee7600A6",'SHIME'="#756bb1A6",'SHIME_LGG'="#8b0a50A6"))
plotDiablo(sgccda.res, ncomp = 2,col.per.group=c('Blank'="#ee7600A6",'SHIME'="#756bb1A6",'SHIME_LGG'="#8b0a50A6"))
options(digits=2)
plotIndiv(sgccda.res, ind.names = FALSE, legend = TRUE, title = 'DIABLO',col.per.group=c('Blank'="#ee7600A6",'SHIME'="#756bb1A6",'SHIME_LGG'="#8b0a50A6"))
plotArrow(sgccda.res, ind.names = FALSE, legend = TRUE, title = 'DIABLO',col.per.group=c('Blank'="#ee7600A6",'SHIME'="#756bb1A6",'SHIME_LGG'="#8b0a50A6"))

plotVar(sgccda.res, var.names = TRUE, style = 'graphics', legend = TRUE,pch = c(16, 17), cex = c(0.8,0.8), col = c('darkorchid', 'lightgreen'))

#network(sgccda.res, blocks = c(1,2),color.node = c('darkorchid','lightgreen'), cutoff = 0.4)
#plotLoadings(sgccda.res, comp = 1, contrib = 'max', method = 'median')
#plotLoadings(sgccda.res, comp = 2, contrib = 'max', method = 'median')
#cimDiablo(sgccda.res)

# performance
perf.diablo = perf(sgccda.res, validation = 'Mfold', folds = 4, nrepeat = 10,dist = 'centroids.dist',cpus=40)

#perf.diablo  # lists the different outputs

# Performance with Majority vote
perf.diablo$MajorityVote.error.rate

perf.diablo$WeightedVote.error.rate

auc.splsda = auroc(sgccda.res, roc.block = "miRNA", roc.comp = 2)
@

\begin{landscape}
<<Mixomics integration plot,results='hide',include=TRUE,warning=FALSE,message=FALSE,cache=FALSE,dpi=dpi,out.height=500,out.width=500,fig.cap='\\label{DIABLO:fig7} Circos plot displaying correlations (inner circle: red-negative and green-positive) among the selected functional and transcriptomics variables most predictive for triple coculture cell model treatment (outer lines:Blank-orange, SHIME-purple, SHIME+LGG - violetred).',fig.scap="Circos plot displaying correlations among the selected functional and transcriptomics variables most predictive for triple coculture cell model treatment.">>=

#circosPlot(sgccda.res, cutoff = 0.7, line = TRUE,color.blocks= c('darkorchid', 'lemonchiffon'),color.cor = c("green","red"), size.labels = 1,size.variables=0.5,color.Y=c("#ee7600A6","#756bb1A6","#8b0a50A6"))

tiff(paste0(path,"DIABLO/circos.tiff"),width=16*dpi,height=16*dpi,res=dpi,compression="lzw")
circosPlot(sgccda.res, cutoff = 0, line = TRUE,
           color.blocks= c('darkorchid', 'lemonchiffon'),
           color.cor = c("green","red"), size.labels = 2,size.variables=1,color.Y=c("#ee7600A6","#756bb1A6","#8b0a50A6"),legend=FALSE)
dev.off()

ggdraw() +  draw_image(image_read(paste0(path,"DIABLO/circos.tiff")))
@
\end{landscape}

\chapter{Exported results}

All differential expression results obtained with Limma, topGO and GAGE were exported to a supplementary excel file.

<<All results to xslx,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
  wb <- createWorkbook()
  addWorksheet(wb, "validation_genesofinterest")

  addWorksheet(wb, "Limma_filtered")
  addWorksheet(wb, "Limma_filtered_sign")
  addWorksheet(wb, "Limma_filtered_sign_topLFC")
  addWorksheet(wb, "Limma_unfiltered")

  addWorksheet(wb, "TopGOenrichment_GOTerms")
  addWorksheet(wb, "TopGOenrichment_GOTerms_genes")

  addWorksheet(wb, "GAGE_GSA_KEGGpathways")
  addWorksheet(wb, "GAGE_GSA_KEGGpathways_sign")
  addWorksheet(wb, "GAGE_GSA_KEGGpathways_sign_nr")

  addWorksheet(wb, "GAGE_GSA_GOTerms")
  addWorksheet(wb, "GAGE_GSA_GOTerms_sign")
  addWorksheet(wb, "GAGE_GSA_GOTerms_sign_nr")


  writeData(wb, 1,genesofinterest_IDs_expression)

  writeData(wb, 2,DEresults_filtered)
  writeData(wb, 3,DEresults_filtered_significant)
  writeData(wb, 4,DEresults_filtered_top)
  writeData(wb, 5,DEresults_unfiltered)

  writeData(wb, 6,significant_GO_results)
  writeData(wb, 7,significant_GO_results_genes)

  writeData(wb, 8,gage_KEGG_df)
  writeData(wb, 9,gage_KEGG_sign_df)
  writeData(wb, 10,gage_KEGG_core)

  writeData(wb, 11,gage_GO_df)
  writeData(wb, 12,gage_GO_sign_df)
  writeData(wb, 13,gage_GO_core)

  saveWorkbook(wb, file = paste0(path,"/S6_result_tables_transcriptomics.xlsx"), overwrite = TRUE)
@







\chapter{Online resources}

\begin{itemize}
\item \parbox[t]{\dimexpr\linewidth-\leftmargin\relax}{\url{https://wiki.bits.vib.be/index.php/Analyze_your_own_microarray_data_in_R/Bioconductor}}
\item \url{http://tools.thermofisher.com/content/sfs/brochures/exon_gene_arrays_qa_whitepaper.pdf}
\item \url{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6347406/}
\item \url{https://www.bioconductor.org/packages/release/bioc/vignettes/yaqcaffy/inst/doc/yaqcaffy.pdf}
\item \parbox[t]{\dimexpr\linewidth-\leftmargin\relax}{\url{https://storage.googleapis.com/plos-corpus-prod/10.1371/journal.pone.0029059/1/pone.0029059.s008.pdf?X-Goog-Algorithm=GOOG4-RSA-SHA256&X-Goog-Credential=wombat-sa\%40plos-prod.iam.gserviceaccount.com\%2F20210401\%2Fauto\%2Fstorage\%2Fgoog4_request&X-Goog-Date=20210401T153107Z&X-Goog-Expires=3600&X-Goog-SignedHeaders=host&X-Goog-Signature=3dfed70bed1ee74dac38de0e018d71ae71720508f6e5319ae73858e89af94804a91e89e3a85d8258fbff018289d9a7b9638da369ffb6a421fe412b1b37ed17b8bd4bfbf2f8532a1be5c0e57b4f15c499fbeccfec0ec272f6aa77d5e7b94fccfbdd83fd09b8694ccc9adfd97d0c94c8f68e3e3544eb2bcdbf48f5d8506d2ccbda56985ecf1842c859f97c693d581a794768fa78550e8d94a5e079c9bdfaa9c9578aeb33b172084c42c19cad29c5160f8bfeff1021c9c3a4cb6346077702a3d54cc453d536a15079dd134783c5c49d7c5198e79cb6cfd669fbd2a527fc6dc7fab1aa26486b56eea493534f2e3eea2464dba381fad677c8fcbe781c26c85d67c604}}
\item \url{https://www.fda.gov/science-research/bioinformatics-tools/microarraysequencing-quality-control-maqcseqc}
\item \url{https://mgimond.github.io/ES218/Week11a.html}
\item \url{https://www.r-bloggers.com/2015/12/tutorial-rna-seq-differential-expression-pathway-analysis-with-sailfish-deseq2-gage-and-pathview/}
\item \url{https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-020-07337-9}
\item \url{https://varemo.github.io/GSA_tutorial/functional_annotation.html}
\end{itemize}





{\footnotesize
\bibliography{ref}}
\bibliographystyle{acm}
 
\end{document}
% 
%    
% 
% % \section{Reactome pathway}
% % The package ReactomePA offers the possibility to test enrichment of specific pathways using the free,
% % opensource, curated and peer reviewed Reactome pathway database. The package requires entrez identifiers, so
% % we convert our PROBEIDs (transcript cluster identifiers) to entrez identifiers using the function mapIDs from the
% % package AnnotationDbi. This will create a named vector that maps the PROBEIDs to the entrez ones, with the
% % PROBEIDs as names and the entrez ids as vector elements. We can now run the enrichment analysis that performs a statistical test based on the hypergeoemtric distribution that is the same as a one sided Fisher-test, which topGO calls “Fisher-classic”. 
% % 
% % The “enrichment map” from the package enrichplot displays the results of the enrichment analysis as a graph,
% % where the color represents the p-value of the pathway and the edge-thickness (that is the line connecting two
% % pathways) is proportional to the number of overlapping genes between two pathways.
% % 
% % << Reactome pathway analysis,include=TRUE,results='hide',warning=FALSE,message=FALSE,cache=TRUE,dpi=dpi,fig.show="hide">>=
% % entrez_ids <- mapIds(hugene20sttranscriptcluster.db,keys = rownames(DEresults_filtered),keytype = "PROBEID",column = "ENTREZID")
% %   
% % reactome_enrich <- enrichPathway(gene = entrez_ids[DEresults_filtered_top$`Affymetrix probe ID`],universe = entrez_ids[c(DEresults_filtered_top$`Affymetrix probe ID`,DEback_genes)],organism = "human",pvalueCutoff = 0.5,qvalueCutoff = 0.9,readable = TRUE)
% % 
% % head(summary(reactome_enrich))[1:6]
% % 
% % barplot(reactome_enrich)
% % 
% % x2 <- pairwise_termsim(reactome_enrich) 
% % emapplot(x2)
% % 
% % enrichplot::emapplot(reactome_enrich, showCategory = 10)
% % @
% % 
% % 
% % %The package clusterProfiler27 can also perform these analyses using downloaded KEGG data. Furthermore, the package EnrichmentBrowser28 additionally offers network-based enrichment analysis of individual pathways. This allows the mapping of the expression data at hand to known regulatory interactions.
%     
% 
% 
% 
%     
%     
% %     
% %  \section{Regulators of transcription}   
% %     
% % Another area of follow-up is to analyze promoter sequences of regulated transcripts to
% % identify elements that may be involved in transcriptional regulation. There are two primary
% % directions that can be taken. The first involves looking for previously characterized elements
% % in the promoters of transcripts that appear to be regulated by a known transcription factor.
% % For example, Figure 33 shows a series of transcripts that appear to show an immediate-early
% % response profile to stimulation with retinoic acid (through a nuclear receptor) in developing
% % mouse neutrophils. The promoters of these transcripts may contain a Retinoic Acid
% % Response Element (RARE). Indeed the gene MAD is known to contain a RARE in its
% % promoter and shows a typical immediate-early response to the signal. Known sequence
% % motifs can be located in promoter sequences using a variety of sequence search and
% % alignment tools, such as those provided by the NCBI. Promoter sequences for many wellcharacterized
% % genes are available in public databases, such as GenBank and RefSeq, and their
% % annotations continue to improve with time. In addition, the growing Eukaryotic Promoter     Database (EPD) is a dedicated, though currently limited, resource on promoter information
% % of eukaryotes (http://www.epd.isb-sib.ch).
% % 
% % 
% % The second direction of follow-up on promoter sequences is searching for novel motifs in
% % the promoters of transcripts that appear to be co-regulated (13). This may be a more
% % challenging task, especially if the putative transcription factor is unknown. This direction of
% % research will continue to expand as more is understood about transcription factors and their
% % binding sites on gene promoters. In addition to the EPD, a useful resource is TRANSFAC:
% % the Transcription Factor Database (http://transfac.gbf.de/TRANSFAC/).
% 
% 
